# Другие распространенные задачи маршрутизации

В этом руководстве рассматриваются другие распространенные задачи, связанные с использованием роутера Angular в вашем
приложении.

## Получение информации о маршруте

Часто при навигации пользователя по приложению необходимо передавать информацию от одного компонента к другому.
Например, рассмотрим приложение, отображающее список покупок.
У каждого товара в списке есть уникальный `id`.
Чтобы отредактировать товар, пользователи нажимают кнопку «Редактировать», которая открывает компонент
`EditGroceryItem`.
Вы хотите, чтобы этот компонент получил `id` товара, чтобы отобразить пользователю правильную информацию.

Используйте маршрут для передачи такого типа информации в компоненты вашего приложения.
Для этого используйте функцию `withComponentInputBinding` вместе с `provideRouter` или опцию `bindToComponentInputs` в
`RouterModule.forRoot`.

Чтобы получить информацию из маршрута:

<docs-workflow>

<docs-step title="Добавьте `withComponentInputBinding`">

Добавьте функцию `withComponentInputBinding` в метод `provideRouter`.

```ts
providers: [
  provideRouter(appRoutes, withComponentInputBinding()),
]
```

</docs-step>

<docs-step title="Добавьте `input` в компонент">

Обновите компонент, добавив свойство `input()`, имя которого совпадает с именем параметра.

```ts
id = input.required<string>()
hero = computed(() => this.service.getHero(id()));
```

</docs-step>
<docs-step title="Необязательно: Использование значения по умолчанию">
Роутер присваивает значения всем input-свойствам на основе текущего маршрута, когда включен `withComponentInputBinding`.
Роутер присваивает `undefined`, если данные маршрута не соответствуют ключу input-свойства, например, когда отсутствует необязательный параметр запроса (query parameter).
Вам следует включить `undefined` в тип `input`, если есть вероятность, что маршрут не сопоставит значение для этого input-свойства.

Предоставьте значение по умолчанию, используя опцию `transform` в input или управляя локальным состоянием с помощью
`linkedSignal`.

```ts
id = input.required({
  transform: (maybeUndefined: string | undefined) => maybeUndefined ?? '0',
});
// или
id = input<string|undefined>();
internalId = linkedSignal(() => this.id() ?? getDefaultId());
```

</docs-step>
</docs-workflow>

NOTE: Вы можете привязать все данные маршрута (пары ключ-значение) к input-свойствам компонента: статические или
разрешенные (resolved) данные маршрута, параметры пути, матричные параметры и параметры запроса.
Если вы хотите использовать информацию о маршруте родительских компонентов, вам необходимо установить опцию роутера
`paramsInheritanceStrategy`:
`withRouterConfig({paramsInheritanceStrategy: 'always'})`.
См. [опции конфигурации роутера](guide/routing/customizing-route-behavior#router-configuration-options) для получения
подробной информации о других доступных настройках.

## Отображение страницы 404

Чтобы отобразить страницу 404,
настройте [wildcard-маршрут](guide/routing/common-router-tasks#setting-up-wildcard-routes), установив свойство
`component` на компонент, который вы хотите использовать для страницы 404, следующим образом:

```ts
const routes: Routes = [
  { path: 'first-component', component: FirstComponent },
  { path: 'second-component', component: SecondComponent },
  { path: '**', component: PageNotFoundComponent },  // Wildcard-маршрут для страницы 404
];
```

Последний маршрут с путем `**` является wildcard-маршрутом (маршрутом с подстановочным знаком).
Роутер выбирает этот маршрут, если запрошенный URL не соответствует ни одному из путей выше в списке, и отправляет
пользователя на `PageNotFoundComponent`.

## Массив параметров ссылки

Массив параметров ссылки содержит следующие элементы для навигации роутера:

- Путь маршрута к целевому компоненту
- Обязательные и необязательные параметры маршрута, которые включаются в URL

Привяжите директиву `RouterLink` к такому массиву следующим образом:

```angular-html
<a [routerLink]="['/heroes']">Heroes</a>
```

Ниже приведен пример массива из двух элементов при указании параметра маршрута:

```angular-html
<a [routerLink]="['/hero', hero.id]">
  <span class="badge">{{ hero.id }}</span>{{ hero.name }}
</a>
```

Необязательные параметры маршрута передаются в объекте, например `{ foo: 'foo' }`:

```angular-html
<a [routerLink]="['/crisis-center', { foo: 'foo' }]">Crisis Center</a>
```

Этот синтаксис передает матричные параметры, которые являются необязательными параметрами, связанными с конкретным
сегментом URL. Узнайте больше о [матричных параметрах](/guide/routing/read-route-state#matrix-parameters).

Эти три примера покрывают потребности приложения с одним уровнем маршрутизации.
Однако при использовании дочернего роутера, например, в кризисном центре, вы создаете новые возможности для массива
ссылок.

Следующий минимальный пример `RouterLink` основан на указанном маршруте по умолчанию для дочернего маршрута кризисного
центра.

```angular-html
<a [routerLink]="['/crisis-center']">Crisis Center</a>
```

Обратите внимание на следующее:

- Первый элемент в массиве определяет родительский маршрут \(`/crisis-center`\)
- Для этого родительского маршрута нет параметров
- Для дочернего маршрута нет значения по умолчанию, поэтому вам нужно выбрать его
- Вы переходите к `CrisisListComponent`, чей путь маршрута — `/`, но вам не нужно явно добавлять косую черту

Рассмотрим следующую ссылку роутера, которая выполняет навигацию от корня приложения к Dragon Crisis:

```angular-html
<a [routerLink]="['/crisis-center', 1]">Dragon Crisis</a>
```

- Первый элемент в массиве определяет родительский маршрут \(`/crisis-center`\)
- Для этого родительского маршрута нет параметров
- Второй элемент определяет детали дочернего маршрута о конкретном кризисе \(`/:id`\)
- Дочерний маршрут деталей требует параметр маршрута `id`
- Вы добавили `id` для Dragon Crisis в качестве второго элемента в массиве \(`1`\)
- Результирующий путь — `/crisis-center/1`

Вы также можете переопределить шаблон `AppComponent` исключительно с маршрутами Crisis Center:

```angular-ts
@Component({
  template: `
    <h1 class="title">Angular Router</h1>
    <nav>
      <a [routerLink]="['/crisis-center']">Crisis Center</a>
      <a [routerLink]="['/crisis-center/1', { foo: 'foo' }]">Dragon Crisis</a>
      <a [routerLink]="['/crisis-center/2']">Shark Crisis</a>
    </nav>
    <router-outlet />
  `
})
export class AppComponent {}
```

В итоге, вы можете создавать приложения с одним, двумя или более уровнями маршрутизации.
Массив параметров ссылки предоставляет гибкость для представления любой глубины маршрутизации и любой допустимой
последовательности путей маршрута, \(обязательных\) параметров роутера и \(необязательных\) объектов параметров
маршрута.

## `LocationStrategy` и стили URL браузера

Когда роутер переходит к новому представлению компонента, он обновляет location и историю браузера URL-адресом для этого
представления.

Современные браузеры HTML5
поддерживают [history.pushState](https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries 'HTML5 browser history push-state') —
технику, которая изменяет location и историю браузера без запуска запроса страницы к серверу.
Роутер может составить «естественный» URL, который неотличим от того, который в противном случае потребовал бы загрузки
страницы.

Вот URL Crisis Center в этом стиле «HTML5 pushState»:

```text
localhost:3002/crisis-center
```

Старые браузеры отправляют запросы страницы на сервер при изменении URL location, если только изменение не происходит
после символа «#» \(называемого «хешем»\).
Роутеры могут воспользоваться этим исключением, составляя URL-адреса маршрутов внутри приложения с использованием хешей.
Вот «hash URL», который ведет в Crisis Center.

```text
localhost:3002/src/#/crisis-center
```

Роутер поддерживает оба стиля с помощью двух провайдеров `LocationStrategy`:

| Провайдеры             | Детали                                |
| :--------------------- | :------------------------------------ |
| `PathLocationStrategy` | Стиль «HTML5 pushState» по умолчанию. |
| `HashLocationStrategy` | Стиль «hash URL».                     |

Функция `RouterModule.forRoot()` устанавливает `LocationStrategy` в `PathLocationStrategy`, что делает его стратегией по
умолчанию.
У вас также есть возможность переключиться на `HashLocationStrategy` с помощью переопределения во время процесса
начальной загрузки (bootstrapping).

HELPFUL: Для получения дополнительной информации о провайдерах и процессе начальной загрузки
см. [Внедрение зависимостей](guide/di/dependency-injection-providers).
