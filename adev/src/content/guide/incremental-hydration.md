# Инкрементальная гидратация

**Инкрементальная гидратация** — это продвинутый тип [гидратации](guide/hydration), который позволяет оставлять части
приложения дегидратированными и _инкрементально_ (постепенно) запускать гидратацию этих частей по мере необходимости.

## Зачем использовать инкрементальную гидратацию?

Инкрементальная гидратация — это улучшение производительности, основанное на полной гидратации приложения. Она позволяет
создавать меньшие начальные бандлы, сохраняя при этом пользовательский опыт, сравнимый с полной гидратацией приложения.
Меньшие бандлы улучшают время начальной загрузки, уменьшая [First Input Delay (FID)](https://web.dev/fid)
и [Cumulative Layout Shift (CLS)](https://web.dev/cls).

Инкрементальная гидратация также позволяет использовать откладываемые представления (`@defer`) для контента, который
раньше нельзя было отложить. В частности, теперь вы можете использовать откладываемые представления для контента на
первом экране (above the fold). До появления инкрементальной гидратации размещение блока `@defer` на первом экране
приводило к рендерингу контента-заполнителя (placeholder), который затем заменялся основным контентом шаблона блока
`@defer`. Это приводило к сдвигу макета. Инкрементальная гидратация означает, что основной шаблон блока `@defer` будет
отрендерен без сдвига макета при гидратации.

## Как включить инкрементальную гидратацию в Angular?

Вы можете включить инкрементальную гидратацию для приложений, которые уже используют рендеринг на стороне сервера (SSR)
с гидратацией. Сначала следуйте [Руководству по Angular SSR](guide/ssr) для включения рендеринга на стороне сервера
и [Руководству по гидратации Angular](guide/hydration) для включения гидратации.

Включите инкрементальную гидратацию, добавив функцию `withIncrementalHydration()` в провайдер `provideClientHydration`.

```typescript
import {
  bootstrapApplication,
  provideClientHydration,
  withIncrementalHydration,
} from '@angular/platform-browser';
...

bootstrapApplication(AppComponent, {
  providers: [provideClientHydration(withIncrementalHydration())]
});
```

Инкрементальная гидратация зависит от [воспроизведения событий](guide/hydration#capturing-and-replaying-events) и
включает его автоматически. Если у вас уже есть `withEventReplay()` в списке, вы можете безопасно удалить его после
включения инкрементальной гидратации.

## Как работает инкрементальная гидратация?

Инкрементальная гидратация строится поверх полной [гидратации](guide/hydration)
приложения, [откладываемых представлений](guide/defer)
и [воспроизведения событий](guide/hydration#capturing-and-replaying-events). С помощью инкрементальной гидратации вы
можете добавлять дополнительные триггеры к блокам `@defer`, которые определяют границы инкрементальной гидратации.
Добавление триггера `hydrate` к блоку defer сообщает Angular, что он должен загрузить зависимости этого блока во время
рендеринга на стороне сервера и отрендерить основной шаблон вместо `@placeholder`. При рендеринге на стороне клиента
зависимости по-прежнему откладываются, и контент блока defer остается дегидратированным до срабатывания его триггера
`hydrate`. Этот триггер дает команду блоку defer загрузить свои зависимости и гидратировать контент. Любые браузерные
события (особенно те, которые соответствуют слушателям, зарегистрированным в вашем компоненте), вызванные пользователем
до гидратации, ставятся в очередь и воспроизводятся после завершения процесса гидратации.

## Управление гидратацией контента с помощью триггеров

Вы можете указать **триггеры гидратации** (hydrate triggers), которые управляют тем, когда Angular загружает и
гидратирует отложенный контент. Это дополнительные триггеры, которые можно использовать наряду с обычными триггерами
`@defer`.

Каждый блок `@defer` может иметь несколько триггеров гидратации, разделенных точкой с запятой (`;`). Angular запускает
гидратацию, когда срабатывает _любой_ из триггеров.

Существует три типа триггеров гидратации: `hydrate on`, `hydrate when` и `hydrate never`.

### `hydrate on`

`hydrate on` задает условие, при котором запускается гидратация для блока `@defer`.

Доступны следующие триггеры:

| Триггер                                             | Описание                                                                      |
| --------------------------------------------------- | ----------------------------------------------------------------------------- |
| [`hydrate on idle`](#hydrate-on-idle)               | Запускается, когда браузер находится в состоянии простоя (idle).              |
| [`hydrate on viewport`](#hydrate-on-viewport)       | Запускается, когда указанный контент попадает в область просмотра (viewport). |
| [`hydrate on interaction`](#hydrate-on-interaction) | Запускается, когда пользователь взаимодействует с указанным элементом.        |
| [`hydrate on hover`](#hydrate-on-hover)             | Запускается, когда мышь наводится на указанную область.                       |
| [`hydrate on immediate`](#hydrate-on-immediate)     | Запускается сразу после завершения рендеринга неотложенного контента.         |
| [`hydrate on timer`](#hydrate-on-timer)             | Запускается через определенный промежуток времени.                            |

#### `hydrate on idle`

Триггер `hydrate on idle` загружает зависимости откладываемого представления и гидратирует контент, как только браузер
переходит в состояние простоя, основываясь на `requestIdleCallback`.

```angular-html
@defer (hydrate on idle) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

#### `hydrate on viewport`

Триггер `hydrate on viewport` загружает зависимости откладываемого представления и гидратирует соответствующую часть
страницы приложения, когда указанный контент попадает в область просмотра (viewport),
используя [Intersection Observer API](https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API).

```angular-html
@defer (hydrate on viewport) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

#### `hydrate on interaction`

Триггер `hydrate on interaction` загружает зависимости откладываемого представления и гидратирует контент, когда
пользователь взаимодействует с указанным элементом посредством событий `click` или `keydown`.

```angular-html
@defer (hydrate on interaction) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

#### `hydrate on hover`

Триггер `hydrate on hover` загружает зависимости откладываемого представления и гидратирует контент, когда мышь
наводится на триггерную область, посредством событий `mouseover` и `focusin`.

```angular-html
@defer (hydrate on hover) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

#### `hydrate on immediate`

Триггер `hydrate on immediate` загружает зависимости откладываемого представления и гидратирует контент немедленно. Это
означает, что отложенный блок загружается сразу после того, как весь остальной неотложенный контент завершил рендеринг.

```angular-html
@defer (hydrate on immediate) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

#### `hydrate on timer`

Триггер `hydrate on timer` загружает зависимости откладываемого представления и гидратирует контент через заданный
промежуток времени.

```angular-html
@defer (hydrate on timer(500ms)) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

Параметр длительности должен быть указан в миллисекундах (`ms`) или секундах (`s`).

### `hydrate when`

Триггер `hydrate when` принимает пользовательское условное выражение, загружает зависимости откладываемого представления
и гидратирует контент, когда условие становится истинным (truthy).

```angular-html
@defer (hydrate when condition) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

ПРИМЕЧАНИЕ: Условия `hydrate when` срабатывают только тогда, когда они находятся в самом верхнем дегидратированном блоке
`@defer`. Условие, предоставленное для триггера, указывается в родительском компоненте, который должен существовать до
того, как триггер сможет сработать. Если родительский блок дегидратирован, это выражение еще не может быть разрешено
Angular.

### `hydrate never`

`hydrate never` позволяет пользователям указать, что контент в блоке defer должен оставаться дегидратированным
неограниченное время, фактически становясь статическим контентом. Обратите внимание, что это относится только к
начальному рендерингу. При последующем рендеринге на стороне клиента блок `@defer` с `hydrate never` все равно будет
загружать зависимости, так как гидратация применяется только к начальной загрузке контента, отрендеренного на сервере. В
примере ниже последующие рендеры на стороне клиента загрузят зависимости блока `@defer` при попадании в область
просмотра (viewport).

```angular-html
@defer (on viewport; hydrate never) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

ПРИМЕЧАНИЕ: Использование `hydrate never` предотвращает гидратацию всего вложенного поддерева данного блока `@defer`.
Никакие другие триггеры `hydrate` не сработают для контента, вложенного в этот блок.

## Триггеры гидратации вместе с обычными триггерами

Триггеры гидратации — это дополнительные триггеры, которые используются вместе с обычными триггерами в блоке `@defer`.
Гидратация — это оптимизация начальной загрузки, и это означает, что триггеры гидратации применяются только к этой
начальной загрузке. Любой последующий рендеринг на стороне клиента будет использовать обычный триггер.

```angular-html
@defer (on idle; hydrate on interaction) {
  <example-cmp />
} @placeholder{
  <div>Example Placeholder</div>
}
```

В этом примере при начальной загрузке применяется `hydrate on interaction`. Гидратация будет запущена при взаимодействии
с компонентом `<example-cmp />`. При любой последующей загрузке страницы, которая рендерится на стороне клиента (
например, когда пользователь нажимает на routerLink, загружающий страницу с этим компонентом), будет применяться
`on idle`.

## Как работает инкрементальная гидратация с вложенными блоками `@defer`?

Система компонентов и зависимостей Angular является иерархической, что означает, что для гидратации любого компонента
требуется, чтобы все его родители также были гидратированы. Поэтому, если гидратация запускается для дочернего блока
`@defer` во вложенном наборе дегидратированных блоков `@defer`, гидратация запускается от самого верхнего
дегидратированного блока `@defer` вниз до вызванного дочернего элемента и срабатывает в этом порядке.

```angular-html
@defer (hydrate on interaction) {
  <parent-block-cmp />
  @defer (hydrate on hover) {
    <child-block-cmp />
  } @placeholder {
    <div>Child placeholder</div>
  }
} @placeholder{
  <div>Parent Placeholder</div>
}
```

В приведенном выше примере наведение курсора на вложенный блок `@defer` запускает гидратацию. Родительский блок `@defer`
с `<parent-block-cmp />` гидратируется первым, затем гидратируется дочерний блок `@defer` с `<child-block-cmp />`.

## Ограничения

Инкрементальная гидратация имеет те же ограничения, что и полная гидратация приложения, включая ограничения на прямые
манипуляции с DOM и требование валидной HTML-структуры. Посетите
раздел [Ограничения гидратации](guide/hydration#constraints) для получения более подробной информации.

## Нужно ли мне по-прежнему указывать блоки `@placeholder`?

Да. Контент блока `@placeholder` не используется для инкрементальной гидратации, но `@placeholder` все равно необходим
для случаев последующего рендеринга на стороне клиента. Если ваш контент не находился на маршруте, который был частью
начальной загрузки, то любой переход на маршрут, содержащий контент вашего блока `@defer`, рендерится как обычный блок
`@defer`. Поэтому в таких случаях рендеринга на стороне клиента отображается `@placeholder`.
