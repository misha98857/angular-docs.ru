# Безопасность `HttpClient`

`HttpClient` включает встроенную поддержку двух распространенных механизмов безопасности HTTP: защиты от XSSI и защиты
от XSRF/CSRF.

TIP: Также рассмотрите возможность
внедрения [Content Security Policy](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy) для
ваших API.

## Защита от XSSI

Cross-Site Script Inclusion (XSSI) — это разновидность
атаки [межсайтового скриптинга (Cross-Site Scripting)](https://en.wikipedia.org/wiki/Cross-site_scripting), при которой
злоумышленник загружает JSON-данные из ваших API-эндпоинтов как `<script>` на подконтрольной ему странице. Затем могут
использоваться различные методы JavaScript для доступа к этим данным.

Распространенным методом предотвращения XSSI является добавление к JSON-ответам "неисполняемого префикса", обычно
`)]}',\n`. Этот префикс предотвращает интерпретацию JSON-ответа как валидного исполняемого JavaScript. Когда API
загружается как данные, префикс может быть удален перед парсингом JSON.

`HttpClient` автоматически удаляет этот префикс XSSI (если он присутствует) при парсинге JSON из ответа.

## Защита от XSRF/CSRF

[Межсайтовая подделка запроса (XSRF или CSRF)](https://en.wikipedia.org/wiki/Cross-site_request_forgery) — это техника
атаки, с помощью которой злоумышленник может обманом заставить аутентифицированного пользователя неосознанно выполнить
действия на вашем веб-сайте.

`HttpClient`
поддерживает [распространенный механизм](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token),
используемый для предотвращения XSRF-атак. При выполнении HTTP-запросов Interceptor считывает токен из cookie (по
умолчанию `XSRF-TOKEN`) и устанавливает его в качестве HTTP-заголовка `X-XSRF-TOKEN`. Поскольку только код, запущенный
на вашем домене, может прочитать cookie, бэкенд может быть уверен, что HTTP-запрос пришел из вашего клиентского
приложения, а не от злоумышленника.

По умолчанию Interceptor отправляет этот заголовок во всех изменяющих запросах (таких как `POST`) к относительным URL,
но не в запросах GET/HEAD или запросах с абсолютным URL.

<docs-callout helpful title="Почему не защищаются GET-запросы?">
Защита от CSRF необходима только для запросов, которые могут изменить состояние на бэкенде. По своей природе CSRF-атаки пересекают границы доменов, и веб-[политика одинакового источника (same-origin policy)](https://developer.mozilla.org/docs/Web/Security/Same-origin_policy) предотвратит получение атакующей страницей результатов аутентифицированных GET-запросов.
</docs-callout>

Чтобы воспользоваться этим преимуществом, ваш сервер должен установить токен в сессионную cookie, доступную для
JavaScript, с именем `XSRF-TOKEN` при загрузке страницы или при первом GET-запросе. При последующих запросах сервер
может проверить, совпадает ли cookie с HTTP-заголовком `X-XSRF-TOKEN`, и, следовательно, быть уверенным, что запрос мог
отправить только код, запущенный на вашем домене. Токен должен быть уникальным для каждого пользователя и поддаваться
проверке сервером; это не позволяет клиенту создавать свои собственные токены. Для дополнительной безопасности
установите токен как дайджест аутентификационной cookie вашего сайта с "солью".

Чтобы предотвратить коллизии в средах, где несколько приложений Angular используют один и тот же домен или поддомен,
задайте каждому приложению уникальное имя cookie.

<docs-callout important title="HttpClient поддерживает только клиентскую часть схемы защиты XSRF">
  Ваш бэкенд-сервис должен быть настроен на установку cookie для вашей страницы и проверку наличия заголовка во всех соответствующих запросах. Невыполнение этого требования делает защиту Angular по умолчанию неэффективной.
</docs-callout>

### Настройка пользовательских имен cookie/заголовков

Если ваш бэкенд-сервис использует другие имена для cookie или заголовка токена XSRF, используйте `withXsrfConfiguration`
для переопределения значений по умолчанию.

Добавьте его в вызов `provideHttpClient` следующим образом:

```ts
export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withXsrfConfiguration({
        cookieName: 'CUSTOM_XSRF_TOKEN',
        headerName: 'X-Custom-Xsrf-Header',
      }),
    ),
  ]
};
```

### Отключение защиты XSRF

Если встроенный механизм защиты XSRF не подходит для вашего приложения, вы можете отключить его, используя функцию
`withNoXsrfProtection`:

```ts
export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withNoXsrfProtection(),
    ),
  ]
};
```
