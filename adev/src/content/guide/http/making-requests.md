# Выполнение HTTP-запросов

`HttpClient` имеет методы, соответствующие различным HTTP-глаголам, используемым для выполнения запросов, как для
загрузки данных, так и для внесения изменений на сервере. Каждый метод возвращает [RxJS
`Observable`](https://rxjs.dev/guide/observable), который при подписке отправляет запрос и выдает результаты, когда
сервер отвечает.

ПРИМЕЧАНИЕ: На `Observable`, созданные `HttpClient`, можно подписываться любое количество раз, и для каждой подписки
будет выполняться новый запрос к бэкенду.

С помощью объекта опций, передаваемого в метод запроса, можно настраивать различные свойства запроса и тип возвращаемого
ответа.

## Получение JSON-данных

Получение данных с бэкенда часто требует выполнения GET-запроса с использованием метода [
`HttpClient.get()`](api/common/http/HttpClient#get). Этот метод принимает два аргумента: строковый URL-адрес конечной
точки (endpoint), откуда нужно получить данные, и _необязательный объект опций_ для настройки запроса.

Например, чтобы получить данные конфигурации из гипотетического API с помощью метода `HttpClient.get()`:

```ts
http.get<Config>('/api/config').subscribe(config => {
  // process the configuration.
});
```

Обратите внимание на аргумент обобщенного типа (generic), который указывает, что данные, возвращаемые сервером, будут
иметь тип `Config`. Этот аргумент необязателен; если его опустить, возвращаемые данные будут иметь тип `Object`.

СОВЕТ: При работе с данными неопределенной структуры и потенциальными значениями `undefined` или `null`, рассмотрите
возможность использования типа `unknown` вместо `Object` в качестве типа ответа.

ВАЖНО: Обобщенный тип методов запроса — это **утверждение** (assertion) о типе данных, возвращаемых сервером.
`HttpClient` не проверяет, соответствуют ли фактические возвращаемые данные этому типу.

## Получение других типов данных

По умолчанию `HttpClient` предполагает, что серверы возвращают JSON-данные. При взаимодействии с API, не использующим
JSON, вы можете сообщить `HttpClient`, какой тип ответа ожидать и возвращать при выполнении запроса. Это делается с
помощью опции `responseType`.

| **Значение `responseType`** | **Тип возвращаемого ответа**                                                                                                                    |
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| `'json'` (по умолчанию)     | JSON-данные указанного обобщенного типа                                                                                                         |
| `'text'`                    | строковые данные                                                                                                                                |
| `'arraybuffer'`             | [`ArrayBuffer`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), содержащий необработанные байты ответа |
| `'blob'`                    | экземпляр [`Blob`](https://developer.mozilla.org/docs/Web/API/Blob)                                                                             |

Например, вы можете попросить `HttpClient` загрузить необработанные байты изображения `.jpeg` в `ArrayBuffer`:

```ts
http.get('/images/dog.jpg', {responseType: 'arraybuffer'}).subscribe(buffer => {
  console.log('The image is ' + buffer.byteLength + ' bytes large');
});
```

<docs-callout important title="Литеральное значение для `responseType`">
Поскольку значение `responseType` влияет на тип, возвращаемый `HttpClient`, оно должно иметь литеральный тип, а не тип `string`.

Это происходит автоматически, если объект опций, переданный в метод запроса, является литеральным объектом. Однако, если
вы выносите опции запроса в переменную или вспомогательный метод, вам может потребоваться явно указать его как литерал,
например `responseType: 'text' as const`.
</docs-callout>

## Изменение состояния сервера

Серверные API, выполняющие изменения (мутации), часто требуют выполнения POST-запросов с телом запроса, указывающим
новое состояние или вносимые изменения.

Метод [`HttpClient.post()`](api/common/http/HttpClient#post) ведет себя аналогично `get()` и принимает дополнительный
аргумент `body` перед опциями:

```ts
http.post<Config>('/api/config', newConfig).subscribe(config => {
  console.log('Updated config:', config);
});
```

В качестве `body` запроса можно передавать множество различных типов значений, и `HttpClient` сериализует их
соответствующим образом:

| **Тип `body`**                                                                                                                 | **Сериализуется как**                                             |
| ------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------- |
| string                                                                                                                         | Обычный текст                                                     |
| number, boolean, array или plain object                                                                                        | JSON                                                              |
| [`ArrayBuffer`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)                        | необработанные данные из буфера                                   |
| [`Blob`](https://developer.mozilla.org/docs/Web/API/Blob)                                                                      | необработанные данные с типом контента `Blob`                     |
| [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData)                                                              | данные, закодированные как `multipart/form-data`                  |
| [`HttpParams`](api/common/http/HttpParams) или [`URLSearchParams`](https://developer.mozilla.org/docs/Web/API/URLSearchParams) | строка, отформатированная как `application/x-www-form-urlencoded` |

ВАЖНО: Не забудьте вызвать `.subscribe()` для `Observable` запросов на изменение, чтобы фактически отправить запрос.

## Установка параметров URL

Укажите параметры запроса, которые должны быть включены в URL запроса, используя опцию `params`.

Передача литерала объекта — самый простой способ настройки параметров URL:

```ts
http.get('/api/config', {
  params: {filter: 'all'},
}).subscribe(config => {
  // ...
});
```

В качестве альтернативы передайте экземпляр `HttpParams`, если вам нужен больший контроль над созданием или
сериализацией параметров.

ВАЖНО: Экземпляры `HttpParams` являются _неизменяемыми_ (immutable) и не могут быть изменены напрямую. Вместо этого
методы изменения, такие как `append()`, возвращают новый экземпляр `HttpParams` с примененными изменениями.

```ts
const baseParams = new HttpParams().set('filter', 'all');

http.get('/api/config', {
  params: baseParams.set('details', 'enabled'),
}).subscribe(config => {
  // ...
});
```

Вы можете создать экземпляр `HttpParams` с пользовательским `HttpParameterCodec`, который определяет, как `HttpClient`
будет кодировать параметры в URL.

### Пользовательское кодирование параметров

По умолчанию `HttpParams` использует встроенный [`HttpUrlEncodingCodec`](api/common/http/HttpUrlEncodingCodec) для
кодирования и декодирования ключей и значений параметров.

Вы можете предоставить собственную реализацию [`HttpParameterCodec`](api/common/http/HttpParameterCodec), чтобы
настроить применение кодирования и декодирования.

```ts
import { HttpClient, HttpParams, HttpParameterCodec } from '@angular/common/http';
import { inject } from '@angular/core';

export class CustomHttpParamEncoder  implements HttpParameterCodec {
  encodeKey(key: string): string   {
    return encodeURIComponent(key);
  }

  encodeValue(value: string): string {
    return encodeURIComponent(value);
  }

  decodeKey(key: string): string {
    return decodeURIComponent(key);
  }

  decodeValue(value: string): string {
    return decodeURIComponent(value);
  }
}

export class ApiService {
  private http = inject(HttpClient);

  search() {
    const params = new HttpParams({
      encoder: new CustomHttpParamEncoder(),
    })
    .set('email', 'dev+alerts@example.com')
    .set('q', 'a & b? c/d = e');

    return this.http.get('/api/items', { params });
  }
}
```

## Установка заголовков запроса

Укажите заголовки запроса, которые должны быть включены в запрос, используя опцию `headers`.

Передача литерала объекта — самый простой способ настройки заголовков запроса:

```ts
http.get('/api/config', {
  headers: {
    'X-Debug-Level': 'verbose',
  }
}).subscribe(config => {
  // ...
});
```

В качестве альтернативы передайте экземпляр `HttpHeaders`, если вам нужен больший контроль над созданием заголовков.

ВАЖНО: Экземпляры `HttpHeaders` являются _неизменяемыми_ и не могут быть изменены напрямую. Вместо этого методы
изменения, такие как `append()`, возвращают новый экземпляр `HttpHeaders` с примененными изменениями.

```ts
const baseHeaders = new HttpHeaders().set('X-Debug-Level', 'minimal');

http.get<Config>('/api/config', {
  headers: baseHeaders.set('X-Debug-Level', 'verbose'),
}).subscribe(config => {
  // ...
});
```

## Взаимодействие с событиями ответа сервера

Для удобства `HttpClient` по умолчанию возвращает `Observable` с данными, возвращенными сервером (тело ответа). Иногда
желательно изучить фактический ответ, например, чтобы получить определенные заголовки ответа.

Чтобы получить доступ ко всему ответу, установите опцию `observe` в значение `'response'`:

```ts
http.get<Config>('/api/config', {observe: 'response'}).subscribe(res => {
  console.log('Response status:', res.status);
  console.log('Body:', res.body);
});
```

<docs-callout important title="Литеральное значение для `observe`">
Поскольку значение `observe` влияет на тип, возвращаемый `HttpClient`, оно должно иметь литеральный тип, а не тип `string`.

Это происходит автоматически, если объект опций, переданный в метод запроса, является литеральным объектом. Однако, если
вы выносите опции запроса в переменную или вспомогательный метод, вам может потребоваться явно указать его как литерал,
например `observe: 'response' as const`.
</docs-callout>

## Получение необработанных событий прогресса

В дополнение к телу ответа или объекту ответа, `HttpClient` также может возвращать поток необработанных _событий_,
соответствующих определенным моментам жизненного цикла запроса. Эти события включают моменты отправки запроса, получения
заголовков ответа и завершения получения тела. Эти события также могут включать _события прогресса_, которые сообщают о
статусе загрузки (upload) и скачивания (download) для больших тел запросов или ответов.

События прогресса отключены по умолчанию (так как они влияют на производительность), но их можно включить с помощью
опции `reportProgress`.

ПРИМЕЧАНИЕ: Необязательная реализация `HttpClient` на основе `fetch` не сообщает о событиях прогресса _загрузки на
сервер_ (upload).

Чтобы наблюдать за потоком событий, установите опцию `observe` в значение `'events'`:

```ts
http.post('/api/upload', myData, {
  reportProgress: true,
  observe: 'events',
}).subscribe(event => {
  switch (event.type) {
    case HttpEventType.UploadProgress:
      console.log('Uploaded ' + event.loaded + ' out of ' + event.total + ' bytes');
      break;
    case HttpEventType.Response:
      console.log('Finished uploading!');
      break;
  }
});
```

<docs-callout important title="Литеральное значение для `observe`">
Поскольку значение `observe` влияет на тип, возвращаемый `HttpClient`, оно должно иметь литеральный тип, а не тип `string`.

Это происходит автоматически, если объект опций, переданный в метод запроса, является литеральным объектом. Однако, если
вы выносите опции запроса в переменную или вспомогательный метод, вам может потребоваться явно указать его как литерал,
например `observe: 'events' as const`.
</docs-callout>

Каждое событие `HttpEvent`, сообщаемое в потоке событий, имеет свойство `type`, которое определяет, что представляет
собой событие:

| **Значение `type`**              | **Значение события**                                                       |
| -------------------------------- | -------------------------------------------------------------------------- |
| `HttpEventType.Sent`             | Запрос был отправлен на сервер                                             |
| `HttpEventType.UploadProgress`   | `HttpUploadProgressEvent`, сообщающее о прогрессе загрузки тела запроса    |
| `HttpEventType.ResponseHeader`   | Получена головная часть ответа, включая статус и заголовки                 |
| `HttpEventType.DownloadProgress` | `HttpDownloadProgressEvent`, сообщающее о прогрессе скачивания тела ответа |
| `HttpEventType.Response`         | Получен полный ответ, включая тело ответа                                  |
| `HttpEventType.User`             | Пользовательское событие от Http Interceptor'а.                            |

## Обработка сбоев запроса

Существует три способа сбоя HTTP-запроса:

- Ошибка сети или соединения может помешать запросу достичь бэкенд-сервера.
- Запрос не получил ответа вовремя, если была установлена опция таймаута.
- Бэкенд может получить запрос, но не суметь его обработать и вернуть ответ с ошибкой.

`HttpClient` перехватывает все вышеперечисленные типы ошибок в `HttpErrorResponse`, который возвращается через канал
ошибок `Observable`. Ошибки сети и таймаута имеют код `status`, равный `0`, и свойство `error`, являющееся экземпляром [
`ProgressEvent`](https://developer.mozilla.org/docs/Web/API/ProgressEvent). Ошибки бэкенда имеют код `status`,
возвращенный бэкендом, и ответ с ошибкой в свойстве `error`. Изучите ответ, чтобы определить причину ошибки и
соответствующие действия для ее обработки.

Библиотека [RxJS](https://rxjs.dev/) предлагает несколько операторов, которые могут быть полезны для обработки ошибок.

Вы можете использовать оператор `catchError` для преобразования ответа с ошибкой в значение для UI. Это значение может
сообщить UI о необходимости отображения страницы ошибки или значения по умолчанию, а также перехватить причину ошибки
при необходимости.

Иногда временные ошибки, такие как прерывания сети, могут привести к неожиданному сбою запроса, и простой повтор запроса
позволит ему выполниться успешно. RxJS предоставляет несколько операторов _повтора_ (retry), которые автоматически
переподписываются на сбойный `Observable` при определенных условиях. Например, оператор `retry()` автоматически
попытается переподписаться указанное количество раз.

### Таймауты

Чтобы установить таймаут для запроса, вы можете задать опцию `timeout` (количество миллисекунд) наряду с другими опциями
запроса. Если запрос к бэкенду не завершится в течение указанного времени, запрос будет прерван, и будет выдана ошибка.

ПРИМЕЧАНИЕ: Таймаут применяется только к самому HTTP-запросу к бэкенду. Это не таймаут для всей цепочки обработки
запроса. Следовательно, эта опция не зависит от задержек, вносимых interceptor'ами.

```ts
http.get('/api/config', {
  timeout: 3000,
}).subscribe({
  next: config => {
    console.log('Config fetched successfully:', config);
  },
  error: err => {
    // If the request times out, an error will have been emitted.
  }
});
```

## Расширенные опции fetch

При использовании провайдера `withFetch()`, `HttpClient` в Angular предоставляет доступ к расширенным опциям fetch API,
которые могут улучшить производительность и пользовательский опыт. Эти опции доступны только при использовании бэкенда
на основе fetch.

### Опции fetch

Следующие опции обеспечивают детальный контроль над поведением запроса при использовании fetch-бэкенда.

#### Keep-alive соединения

Опция `keepalive` позволяет запросу пережить страницу, которая его инициировала. Это особенно полезно для запросов
аналитики или логирования, которые должны завершиться, даже если пользователь уходит со страницы.

```ts
http.post('/api/analytics', analyticsData, {
  keepalive: true
}).subscribe();
```

#### Управление HTTP-кэшированием

Опция `cache` управляет тем, как запрос взаимодействует с HTTP-кэшем браузера, что может значительно улучшить
производительность для повторяющихся запросов.

```ts
//  Использовать кэшированный ответ независимо от свежести
http.get('/api/config', {
  cache: 'force-cache'
}).subscribe(config => {
  // ...
});

// Всегда запрашивать из сети, игнорируя кэш
http.get('/api/live-data', {
  cache: 'no-cache'
}).subscribe(data => {
  // ...
});

// Использовать только кэшированный ответ, ошибка если нет в кэше
http.get('/api/static-data', {
  cache: 'only-if-cached'
}).subscribe(data => {
  // ...
});
```

#### Приоритет запроса для Core Web Vitals

Опция `priority` позволяет указать относительную важность запроса, помогая браузерам оптимизировать загрузку ресурсов
для улучшения показателей Core Web Vitals.

```ts
// Высокий приоритет для критически важных ресурсов
http.get('/api/user-profile', {
  priority: 'high'
}).subscribe(profile => {
  // ...
});

// Низкий приоритет для некритичных ресурсов
http.get('/api/recommendations', {
  priority: 'low'
}).subscribe(recommendations => {
  // ...
});

// Автоматический приоритет (по умолчанию), решение принимает браузер
http.get('/api/settings', {
  priority: 'auto'
}).subscribe(settings => {
  // ...
});
```

Доступные значения `priority`:

- `'high'`: Высокий приоритет, загружается рано (например, критические данные пользователя, контент "первого экрана").
- `'low'`: Низкий приоритет, загружается при наличии ресурсов (например, аналитика, предварительная выборка данных).
- `'auto'`: Браузер определяет приоритет на основе контекста запроса (по умолчанию).

СОВЕТ: Используйте `priority: 'high'` для запросов, влияющих на Largest Contentful Paint (LCP), и `priority: 'low'` для
запросов, не влияющих на начальный пользовательский опыт.

#### Режим запроса (Request mode)

Опция `mode` управляет тем, как запрос обрабатывает кросс-доменные запросы, и определяет тип ответа.

```ts
// Только запросы к тому же источнику (same-origin)
http.get('/api/local-data', {
  mode: 'same-origin'
}).subscribe(data => {
  // ...
});

// Кросс-доменные запросы с поддержкой CORS
http.get('https://api.external.com/data', {
  mode: 'cors'
}).subscribe(data => {
  // ...
});

// Режим No-CORS для простых кросс-доменных запросов
http.get('https://external-api.com/public-data', {
  mode: 'no-cors'
}).subscribe(data => {
  // ...
});
```

Доступные значения `mode`:

- `'same-origin'`: Разрешать только запросы к тому же источнику, ошибка для кросс-доменных запросов.
- `'cors'`: Разрешать кросс-доменные запросы с CORS (по умолчанию).
- `'no-cors'`: Разрешать простые кросс-доменные запросы без CORS, ответ является непрозрачным (opaque).

СОВЕТ: Используйте `mode: 'same-origin'` для чувствительных запросов, которые никогда не должны уходить на другой домен.

#### Обработка редиректов

Опция `redirect` указывает, как обрабатывать ответы с перенаправлением (redirect) от сервера.

```ts
// Автоматически переходить по редиректам (поведение по умолчанию)
http.get('/api/resource', {
  redirect: 'follow'
}).subscribe(data => {
  // ...
});

// Предотвратить автоматические переходы
http.get('/api/resource', {
  redirect: 'manual'
}).subscribe(response => {
  // Обработать редирект вручную
});

// Считать редиректы ошибками
http.get('/api/resource', {
  redirect: 'error'
}).subscribe({
  next: data => {
    // Успешный ответ
  },
  error: err => {
    // Ответы с редиректом вызовут этот обработчик ошибок
  }
});
```

Доступные значения `redirect`:

- `'follow'`: Автоматически переходить по редиректам (по умолчанию).
- `'error'`: Считать редиректы ошибками.
- `'manual'`: Не переходить по редиректам автоматически, возвращать ответ с редиректом.

СОВЕТ: Используйте `redirect: 'manual'`, когда вам нужно обработать редиректы с помощью пользовательской логики.

#### Обработка учетных данных (Credentials)

Опция `credentials` управляет тем, отправляются ли файлы cookie, заголовки авторизации и другие учетные данные при
кросс-доменных запросах. Это особенно важно для сценариев аутентификации.

```ts
// Включать учетные данные для кросс-доменных запросов
http.get('https://api.example.com/protected-data', {
  credentials: 'include'
}).subscribe(data => {
  // ...
});

// Никогда не отправлять учетные данные (по умолчанию для кросс-доменных)
http.get('https://api.example.com/public-data', {
  credentials: 'omit'
}).subscribe(data => {
  // ...
});

// Отправлять учетные данные только для запросов к тому же источнику
http.get('/api/user-data', {
  credentials: 'same-origin'
}).subscribe(data => {
  // ...
});

// withCredentials переопределяет настройку credentials
http.get('https://api.example.com/data', {
  credentials: 'omit',        // Это будет проигнорировано
  withCredentials: true       // Это принудительно устанавливает credentials: 'include'
}).subscribe(data => {
  // Запрос будет включать учетные данные, несмотря на credentials: 'omit'
});

// Устаревший подход (все еще поддерживается)
http.get('https://api.example.com/data', {
  withCredentials: true
}).subscribe(data => {
  // Эквивалентно credentials: 'include'
});
```

ВАЖНО: Опция `withCredentials` имеет приоритет над опцией `credentials`. Если указаны обе, `withCredentials: true`
всегда приведет к `credentials: 'include'`, независимо от явного значения `credentials`.

Доступные значения `credentials`:

- `'omit'`: Никогда не отправлять учетные данные.
- `'same-origin'`: Отправлять учетные данные только для запросов к тому же источнику (по умолчанию).
- `'include'`: Всегда отправлять учетные данные, даже для кросс-доменных запросов.

СОВЕТ: Используйте `credentials: 'include'`, когда вам нужно отправить аутентификационные cookie или заголовки на другой
домен, поддерживающий CORS. Избегайте смешивания опций `credentials` и `withCredentials`, чтобы предотвратить путаницу.

#### Referrer

Опция `referrer` позволяет контролировать, какая информация о реферере (источнике перехода) отправляется с запросом. Это
важно для конфиденциальности и безопасности.

```ts
// Отправить конкретный URL реферера
http.get('/api/data', {
  referrer: 'https://example.com/page'
}).subscribe(data => {
  // ...
});

// Использовать текущую страницу как реферер (поведение по умолчанию)
http.get('/api/analytics', {
  referrer: 'about:client'
}).subscribe(data => {
  // ...
});
```

Опция `referrer` принимает:

- Строку с валидным URL: Устанавливает конкретный URL реферера для отправки.
- Пустую строку `''`: Не отправляет информацию о реферере.
- `'about:client'`: Использует реферер по умолчанию (URL текущей страницы).

СОВЕТ: Используйте `referrer: ''` для чувствительных запросов, где вы не хотите раскрывать URL ссылающейся страницы.

#### Политика реферера (Referrer policy)

Опция `referrerPolicy` управляет тем, какой объем информации о реферере (URL страницы, выполняющей запрос) отправляется
вместе с HTTP-запросом. Эта настройка влияет как на конфиденциальность, так и на аналитику, позволяя балансировать между
видимостью данных и соображениями безопасности.

```ts
// Не отправлять информацию о реферере независимо от текущей страницы
http.get('/api/data', {
  referrerPolicy: 'no-referrer'
}).subscribe();

// Отправлять только origin (например, https://example.com)
http.get('/api/analytics', {
  referrerPolicy: 'origin'
}).subscribe();
```

Опция `referrerPolicy` принимает:

- `'no-referrer'`: Никогда не отправлять заголовок `Referer`.
- `'no-referrer-when-downgrade'`: Отправляет реферер для запросов к тому же источнику и безопасных (HTTPS→HTTPS)
  запросов, но опускает его при переходе от безопасного к менее безопасному источнику (HTTPS→HTTP).
- `'origin'`: Отправляет только origin (схема, хост, порт) реферера, опуская путь и информацию запроса.
- `'origin-when-cross-origin'`: Отправляет полный URL для запросов к тому же источнику, но только origin для
  кросс-доменных запросов.
- `'same-origin'`: Отправляет полный URL для запросов к тому же источнику и не отправляет реферер для кросс-доменных
  запросов.
- `'strict-origin'`: Отправляет только origin, и только если уровень безопасности протокола не понижается (например,
  HTTPS→HTTPS). Опускает реферер при понижении уровня безопасности.
- `'strict-origin-when-cross-origin'`: Поведение браузера по умолчанию. Отправляет полный URL для запросов к тому же
  источнику, origin для кросс-доменных запросов (если уровень безопасности не понижается) и опускает реферер при
  понижении уровня безопасности.
- `'unsafe-url'`: Всегда отправляет полный URL (включая путь и запрос). Это может раскрыть чувствительные данные и
  должно использоваться с осторожностью.

СОВЕТ: Отдавайте предпочтение консервативным значениям, таким как `'no-referrer'`, `'origin'` или
`'strict-origin-when-cross-origin'`, для запросов, чувствительных к конфиденциальности.

#### Целостность (Integrity)

Опция `integrity` позволяет проверить, что ответ не был подделан, предоставляя криптографический хэш ожидаемого
контента. Это особенно полезно для загрузки скриптов или других ресурсов из CDN.

```ts
// Проверить целостность ответа с помощью хэша SHA-256
http.get('/api/script.js', {
  integrity: 'sha256-ABC123...',
  responseType: 'text'
}).subscribe(script => {
  // Содержимое скрипта проверяется на соответствие хэшу
});
```

ВАЖНО: Опция `integrity` требует точного совпадения между содержимым ответа и предоставленным хэшем. Если содержимое не
совпадает, запрос завершится с сетевой ошибкой.

СОВЕТ: Используйте целостность подресурсов (subresource integrity) при загрузке критически важных ресурсов из внешних
источников, чтобы гарантировать, что они не были изменены. Генерируйте хэши с помощью инструментов, таких как `openssl`.

## Http `Observable`

Каждый метод запроса в `HttpClient` создает и возвращает `Observable` запрошенного типа ответа. Понимание того, как
работают эти `Observable`, важно при использовании `HttpClient`.

`HttpClient` создает то, что RxJS называет "холодными" `Observable`. Это означает, что фактический запрос не происходит
до тех пор, пока на `Observable` не подпишутся. Только тогда запрос фактически отправляется на сервер. Подписка на один
и тот же `Observable` несколько раз вызовет несколько запросов к бэкенду. Каждая подписка независима.

СОВЕТ: Вы можете думать об `Observable` из `HttpClient` как о _чертежах_ для фактических запросов к серверу.

После подписки, отписка прервет выполняющийся запрос. Это очень полезно, если подписка на `Observable` осуществляется
через pipe `async`, так как он автоматически отменит запрос, если пользователь уйдет с текущей страницы. Кроме того,
если вы используете `Observable` с комбинатором RxJS, таким как `switchMap`, эта отмена очистит все устаревшие запросы.

После возвращения ответа `Observable` от `HttpClient` обычно завершаются (complete) (хотя interceptor'ы могут повлиять
на это).

Из-за автоматического завершения обычно нет риска утечки памяти, если подписки `HttpClient` не очищаются. Однако, как и
в случае с любой асинхронной операцией, мы настоятельно рекомендуем очищать подписки при уничтожении компонента,
использующего их, так как иначе колбэк подписки может запуститься и столкнуться с ошибками при попытке взаимодействия с
уничтоженным компонентом.

СОВЕТ: Использование pipe `async` или операции `toSignal` для подписки на `Observable` гарантирует правильное удаление
подписок.

## Лучшие практики

Хотя `HttpClient` можно внедрять и использовать непосредственно в компонентах, обычно мы рекомендуем создавать повторно
используемые, внедряемые сервисы, которые изолируют и инкапсулируют логику доступа к данным. Например, этот
`UserService` инкапсулирует логику запроса данных пользователя по его id:

```ts
@Injectable({providedIn: 'root'})
export class UserService {
  private http = inject(HttpClient);

  getUser(id: string): Observable<User> {
    return this.http.get<User>(`/api/user/${id}`);
  }
}
```

Внутри компонента вы можете комбинировать `@if` с pipe `async`, чтобы отображать UI для данных только после завершения
их загрузки:

```angular-ts
import { AsyncPipe } from '@angular/common';

@Component({
  imports: [AsyncPipe],
  template: `
    @if (user$ | async; as user) {
      <p>Name: {{ user.name }}</p>
      <p>Biography: {{ user.biography }}</p>
    }
  `,
})
export class UserProfileComponent {
  userId = input.required<string>();
  user$!: Observable<User>;

  private userService = inject(UserService);

  constructor(): void {
    effect(() => {
      this.user$ = this.userService.getUser(this.userId());
    });
  }
}
```
