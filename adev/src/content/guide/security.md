# Безопасность

В этом разделе описываются встроенные средства защиты Angular от распространенных уязвимостей веб-приложений и атак,
таких как межсайтовый скриптинг (XSS).
Здесь не рассматривается безопасность на уровне приложения, такая как аутентификация и авторизация.

Для получения дополнительной информации об атаках и способах их предотвращения, описанных ниже,
см. [Руководство Open Web Application Security Project (OWASP)](https://www.owasp.org/index.php/Category:OWASP_Guide_Project).

<a id="report-issues"></a>

<docs-callout title="Сообщение об уязвимостях">

Angular является частью программы
Google [Open Source Software Vulnerability Reward Program](https://bughunters.google.com/about/rules/6521337925468160/google-open-source-software-vulnerability-reward-program-rules).
Чтобы сообщить об уязвимостях в Angular, отправьте отчет
на [https://bughunters.google.com](https://bughunters.google.com/report).

Для получения дополнительной информации о том, как Google обрабатывает проблемы безопасности,
см. [философию безопасности Google](https://www.google.com/about/appsecurity).

</docs-callout>

## Лучшие практики

Ниже приведены некоторые рекомендации, обеспечивающие безопасность вашего приложения Angular.

1. **Следите за актуальностью версий библиотек Angular** — Библиотеки Angular регулярно обновляются, и эти обновления
   могут содержать исправления дефектов безопасности, обнаруженных в предыдущих версиях.
   Проверяйте [журнал изменений](https://github.com/angular/angular/blob/main/CHANGELOG.md) Angular на наличие
   обновлений, связанных с безопасностью.
2. **Не изменяйте свою копию Angular** — Приватные, кастомизированные версии Angular, как правило, отстают от текущей
   версии и могут не включать важные исправления безопасности и улучшения. Вместо этого поделитесь своими улучшениями
   Angular с сообществом и создайте pull request.
3. **Избегайте API Angular, помеченных в документации как "_Security Risk_"** — Для получения дополнительной информации
   см. раздел [Доверие безопасным значениям](#trusting-safe-values) на этой странице.

## Предотвращение межсайтового скриптинга (XSS)

[Межсайтовый скриптинг (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) позволяет злоумышленникам внедрять
вредоносный код на веб-страницы.
Такой код может, например, украсть данные пользователя и данные для входа или выполнить действия от имени пользователя.
Это одна из самых распространенных атак в Интернете.

Чтобы заблокировать XSS-атаки, необходимо предотвратить попадание вредоносного кода в объектную модель документа (DOM).
Например, если злоумышленник сможет обманом заставить вас вставить тег `<script>` в DOM, он сможет запустить
произвольный код на вашем веб-сайте.
Атака не ограничивается тегами `<script>` — многие элементы и свойства в DOM позволяют выполнять код, например,
`<img alt="" onerror="...">` и `<a href="javascript:...">`.
Если контролируемые злоумышленником данные попадают в DOM, ожидайте появления уязвимостей безопасности.

### Модель безопасности Angular против межсайтового скриптинга

Чтобы систематически блокировать ошибки XSS, Angular по умолчанию рассматривает все значения как ненадежные.
Когда значение вставляется в DOM через привязку в шаблоне или интерполяцию, Angular выполняет санитизацию (очистку) и
экранирование ненадежных значений.
Если значение уже было очищено вне Angular и считается безопасным, сообщите об этом Angular,
пометив [значение как доверенное](#trusting-safe-values).

В отличие от значений, используемых для рендеринга, шаблоны Angular по умолчанию считаются доверенными и должны
рассматриваться как исполняемый код.
Никогда не создавайте шаблоны путем конкатенации пользовательского ввода и синтаксиса шаблона.
Это позволит злоумышленникам [внедрить произвольный код](https://en.wikipedia.org/wiki/Code_injection) в ваше
приложение.
Чтобы предотвратить эти уязвимости, всегда
используйте [AOT-компилятор шаблонов (Ahead-Of-Time)](#use-the-aot-template-compiler) по умолчанию в продакшн-сборках.

Дополнительный уровень защиты может быть обеспечен за счет использования Content Security Policy (CSP) и Trusted Types.
Эти функции веб-платформы работают на уровне DOM, что является наиболее эффективным местом для предотвращения проблем
XSS. Здесь их нельзя обойти с помощью других, более низкоуровневых API.
По этой причине настоятельно рекомендуется использовать эти функции. Для этого
настройте [Content Security Policy](#content-security-policy) для приложения и
включите [принудительное использование Trusted Types](#enforcing-trusted-types).

### Санитизация и контексты безопасности

_Санитизация_ — это проверка ненадежного значения и преобразование его в значение, безопасное для вставки в DOM.
Во многих случаях санитизация вообще не меняет значение.
Санитизация зависит от контекста.
Например, значение, безвредное в CSS, может быть потенциально опасным в URL.

Angular определяет следующие контексты безопасности:

| Контексты безопасности | Подробности                                                                             |
| :--------------------- | :-------------------------------------------------------------------------------------- |
| HTML                   | Используется при интерпретации значения как HTML, например, при привязке к `innerHtml`. |
| Style                  | Используется при привязке CSS к свойству `style`.                                       |
| URL                    | Используется для свойств URL, таких как `<a href>`.                                     |
| Resource URL           | URL, который загружается и выполняется как код, например, в `<script src>`.             |

Angular выполняет санитизацию ненадежных значений для HTML и URL. Санитизация Resource URL невозможна, так как они
содержат произвольный код.
В режиме разработки Angular выводит предупреждение в консоль, когда ему приходится изменять значение в процессе
санитизации.

### Пример санитизации

Следующий шаблон привязывает значение `htmlSnippet`. Один раз путем интерполяции его в содержимое элемента, и один раз
путем привязки к свойству `innerHTML` элемента:

<docs-code header="inner-html-binding.component.html" path="adev/src/content/examples/security/src/app/inner-html-binding.component.html"/>

Интерполированный контент всегда экранируется — HTML не интерпретируется, и браузер отображает угловые скобки в
текстовом содержимом элемента.

Чтобы HTML интерпретировался, привяжите его к HTML-свойству, такому как `innerHTML`.
Помните, что привязка значения, которое может контролировать злоумышленник, к `innerHTML` обычно приводит к
XSS-уязвимости.
Например, можно запустить JavaScript следующим образом:

<docs-code header="inner-html-binding.component.ts (class)" path="adev/src/content/examples/security/src/app/inner-html-binding.component.ts" visibleRegion="class"/>

Angular распознает значение как небезопасное и автоматически выполняет его санитизацию, удаляя элемент `script`, но
сохраняя безопасный контент, такой как элемент `<b>`.

<img alt="Скриншот, показывающий интерполированные и привязанные значения HTML" src="assets/images/guide/security/binding-inner-html.png#small">

### Прямое использование DOM API и явные вызовы санитизации

Если вы не используете принудительно Trusted Types, встроенные в браузер DOM API не защищают вас автоматически от
уязвимостей безопасности.
Например, `document`, узел, доступный через `ElementRef`, и многие сторонние API содержат небезопасные методы.
Аналогично, если вы взаимодействуете с другими библиотеками, которые манипулируют DOM, у вас, скорее всего, не будет
такой же автоматической санитизации, как при интерполяции в Angular.
Избегайте прямого взаимодействия с DOM и вместо этого используйте шаблоны Angular, где это возможно.

В случаях, когда это неизбежно, используйте встроенные функции санитизации Angular.
Выполняйте санитизацию ненадежных значений с помощью
метода [DomSanitizer.sanitize](api/platform-browser/DomSanitizer#sanitize) и соответствующего `SecurityContext`.
Эта функция также принимает значения, помеченные как доверенные с помощью функций `bypassSecurityTrust`, и не выполняет
их санитизацию, как [описано ниже](#trusting-safe-values).

### Доверие безопасным значениям

Иногда приложениям действительно необходимо включить исполняемый код, отобразить `<iframe>` с определенного URL или
создать потенциально опасные URL.
Чтобы предотвратить автоматическую санитизацию в этих ситуациях, сообщите Angular, что вы проверили значение, выяснили,
как оно было создано, и убедились в его безопасности.
Будьте _осторожны_.
Если вы доверитесь значению, которое может быть вредоносным, вы создадите уязвимость безопасности в своем приложении.
Если есть сомнения, обратитесь к профессиональному специалисту по безопасности.

Чтобы пометить значение как доверенное, внедрите `DomSanitizer` и вызовите один из следующих методов:

- `bypassSecurityTrustHtml`
- `bypassSecurityTrustScript`
- `bypassSecurityTrustStyle`
- `bypassSecurityTrustUrl`
- `bypassSecurityTrustResourceUrl`

Помните, что безопасность значения зависит от контекста, поэтому выбирайте правильный контекст для предполагаемого
использования значения.
Представьте, что следующему шаблону нужно привязать URL к вызову `javascript:alert(...)`:

<docs-code header="bypass-security.component.html (URL)" path="adev/src/content/examples/security/src/app/bypass-security.component.html" visibleRegion="URL"/>

Обычно Angular автоматически выполняет санитизацию URL, отключает опасный код и в режиме разработки регистрирует это
действие в консоли.
Чтобы предотвратить это, пометьте значение URL как доверенный URL с помощью вызова `bypassSecurityTrustUrl`:

<docs-code header="bypass-security.component.ts (trust-url)" path="adev/src/content/examples/security/src/app/bypass-security.component.ts" visibleRegion="trust-url"/>

<img alt="Скриншот, показывающий окно предупреждения, созданное из доверенного URL" src="assets/images/guide/security/bypass-security-component.png#medium">

Если вам нужно преобразовать пользовательский ввод в доверенное значение, используйте метод компонента.
Следующий шаблон позволяет пользователям вводить ID видео YouTube и загружать соответствующее видео в `<iframe>`.
Атрибут `<iframe src>` является контекстом безопасности Resource URL, поскольку ненадежный источник может, например,
скрытно загружать файлы, которые ничего не подозревающие пользователи могут запустить.
Чтобы предотвратить это, вызовите метод компонента для создания доверенного URL видео, что позволит Angular выполнить
привязку в `<iframe src>`:

<docs-code header="bypass-security.component.html (iframe)" path="adev/src/content/examples/security/src/app/bypass-security.component.html" visibleRegion="iframe"/>

<docs-code header="bypass-security.component.ts (trust-video-url)" path="adev/src/content/examples/security/src/app/bypass-security.component.ts" visibleRegion="trust-video-url"/>

### Content Security Policy

Content Security Policy (CSP) — это техника глубокой защиты для предотвращения XSS.
Чтобы включить CSP, настройте свой веб-сервер на возврат соответствующего HTTP-заголовка `Content-Security-Policy`.
Подробнее о Content Security Policy читайте
в [руководстве Web Fundamentals](https://developers.google.com/web/fundamentals/security/csp) на сайте Google
Developers.

Минимальная политика, необходимая для нового приложения Angular:

```txt
default-src 'self'; style-src 'self' 'nonce-randomNonceGoesHere'; script-src 'self' 'nonce-randomNonceGoesHere';
```

При обслуживании вашего приложения Angular сервер должен включать случайно сгенерированный nonce (одноразовый код) в
HTTP-заголовок для каждого запроса.
Вы должны предоставить этот nonce Angular, чтобы фреймворк мог рендерить элементы `<style>`.
Вы можете установить nonce для Angular одним из двух способов:

1. Установите опцию `autoCsp` в `true`
   в [конфигурации рабочего пространства](reference/configs/workspace-config#extra-build-and-test-options).
2. Установите атрибут `ngCspNonce` на корневом элементе приложения как `<app ngCspNonce="randomNonceGoesHere"></app>`.
   Используйте этот подход, если у вас есть доступ к серверной шаблонизации, которая может добавить nonce как в
   заголовок, так и в `index.html` при формировании ответа.
3. Предоставьте nonce с помощью токена внедрения `CSP_NONCE`. Используйте этот подход, если у вас есть доступ к nonce во
   время выполнения, и вы хотите иметь возможность кэшировать `index.html`.

```ts
import {bootstrapApplication, CSP_NONCE} from '@angular/core';
import {AppComponent} from './app/app.component';

bootstrapApplication(AppComponent, {
  providers: [{
    provide: CSP_NONCE,
    useValue: globalThis.myRandomNonceValue
  }]
});
```

<docs-callout title="Уникальные nonce">

Всегда следите за тем, чтобы предоставляемые вами nonce были <strong>уникальными для каждого запроса</strong>, и чтобы
их нельзя было предсказать или угадать.
Если злоумышленник сможет предсказать будущие nonce, он сможет обойти защиту, предлагаемую CSP.

</docs-callout>

ПРИМЕЧАНИЕ: Если вы хотите [встроить критический CSS](/tools/cli/build#critical-css-inlining) вашего приложения, вы не
можете использовать токен `CSP_NONCE`, и вам следует предпочесть опцию `autoCsp` или установить атрибут `ngCspNonce` на
корневом элементе приложения.

Если вы не можете генерировать nonce в своем проекте, вы можете разрешить встроенные стили, добавив `'unsafe-inline'` в
раздел `style-src` заголовка CSP.

| Разделы                                          | Подробности                                                                                                                                                                                                                               |
| :----------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `default-src 'self';`                            | Позволяет странице загружать все необходимые ресурсы из того же источника.                                                                                                                                                                |
| `style-src 'self' 'nonce-randomNonceGoesHere';`  | Позволяет странице загружать глобальные стили из того же источника (`'self'`) и стили, вставленные Angular с `nonce-randomNonceGoesHere`.                                                                                                 |
| `script-src 'self' 'nonce-randomNonceGoesHere';` | Позволяет странице загружать JavaScript из того же источника (`'self'`) и скрипты, вставленные Angular CLI с `nonce-randomNonceGoesHere`. Это требуется только в том случае, если вы используете встраивание (inlining) критического CSS. |

Самому Angular для корректной работы требуются только эти настройки.
По мере роста вашего проекта вам может потребоваться расширить настройки CSP для поддержки дополнительных функций,
специфичных для вашего приложения.

### Принудительное использование Trusted Types

Рекомендуется использовать [Trusted Types](https://w3c.github.io/trusted-types/dist/spec/) как способ защиты ваших
приложений от атак межсайтового скриптинга.
Trusted Types — это функция [веб-платформы](https://en.wikipedia.org/wiki/Web_platform), которая может помочь
предотвратить атаки межсайтового скриптинга путем принудительного использования более безопасных методов кодирования.
Trusted Types также могут помочь упростить аудит кода приложения.

<docs-callout title="Trusted Types">

Trusted Types могут быть еще недоступны во всех браузерах, на которые ориентировано ваше приложение.
В случае, если ваше приложение с включенными Trusted Types запускается в браузере, который не поддерживает Trusted
Types, функции приложения сохраняются. Ваше приложение защищено от XSS с помощью DomSanitizer Angular.
Текущую поддержку браузерами см. на [caniuse.com/trusted-types](https://caniuse.com/trusted-types).

</docs-callout>

Чтобы принудительно использовать Trusted Types для вашего приложения, вы должны настроить веб-сервер вашего приложения
на отправку HTTP-заголовков с одной из следующих политик Angular:

| Политики                 | Подробности                                                                                                                                                                                                                                                                                                                   |
| :----------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `angular`                | Эта политика используется в коде, прошедшем проверку безопасности и являющемся внутренним для Angular, и необходима для функционирования Angular при принудительном использовании Trusted Types. Любые значения встроенных шаблонов или контент, прошедший санитизацию Angular, считаются безопасными в рамках этой политики. |
| `angular#bundler`        | Эта политика используется сборщиком Angular CLI при создании файлов ленивых чанков (lazy chunks).                                                                                                                                                                                                                             |
| `angular#unsafe-bypass`  | Эта политика используется для приложений, использующих любые методы в [DomSanitizer](api/platform-browser/DomSanitizer) Angular, которые обходят безопасность, такие как `bypassSecurityTrustHtml`. Любое приложение, использующее эти методы, должно включить эту политику.                                                  |
| `angular#unsafe-jit`     | Эта политика используется [JIT-компилятором (Just-In-Time)](api/core/Compiler). Вы должны включить эту политику, если ваше приложение взаимодействует напрямую с JIT-компилятором или работает в режиме JIT, используя [platform browser dynamic](api/platform-browser-dynamic/platformBrowserDynamic).                       |
| `angular#unsafe-upgrade` | Эта политика используется пакетом [@angular/upgrade](api/upgrade/static/UpgradeModule). Вы должны включить эту политику, если ваше приложение является гибридным приложением AngularJS.                                                                                                                                       |

Вам следует настроить HTTP-заголовки для Trusted Types в следующих местах:

- Инфраструктура продакшн-сервера
- Angular CLI (`ng serve`), используя свойство `headers` в файле `angular.json`, для локальной разработки и сквозного (
  E2E) тестирования
- Karma (`ng test`), используя свойство `customHeaders` в файле `karma.config.js`, для модульного тестирования

Ниже приведен пример заголовка, специально настроенного для Trusted Types и Angular:

```html
Content-Security-Policy: trusted-types angular; require-trusted-types-for 'script';
```

Пример заголовка, специально настроенного для Trusted Types и приложений Angular, использующих любые методы Angular
в [DomSanitizer](api/platform-browser/DomSanitizer), которые обходят безопасность:

```html
Content-Security-Policy: trusted-types angular angular#unsafe-bypass; require-trusted-types-for 'script';
```

Ниже приведен пример заголовка, специально настроенного для Trusted Types и приложений Angular, использующих JIT:

```html
Content-Security-Policy: trusted-types angular angular#unsafe-jit; require-trusted-types-for 'script';
```

Ниже приведен пример заголовка, специально настроенного для Trusted Types и приложений Angular, использующих ленивую
загрузку модулей:

```html
Content-Security-Policy: trusted-types angular angular#bundler; require-trusted-types-for 'script';
```

<docs-callout title="Вклад сообщества">

Чтобы узнать больше об устранении неполадок конфигураций Trusted Type, может быть полезен следующий ресурс:

[Prevent DOM-based cross-site scripting vulnerabilities with Trusted Types](https://web.dev/trusted-types/#how-to-use-trusted-types)

</docs-callout>

### Используйте AOT-компилятор шаблонов

AOT-компилятор шаблонов предотвращает целый класс уязвимостей, называемых инъекцией шаблона, и значительно повышает
производительность приложения.
AOT-компилятор шаблонов является компилятором по умолчанию, используемым приложениями Angular CLI, и его следует
использовать во всех продакшн-сборках.

Альтернативой AOT-компилятору является JIT-компилятор, который компилирует шаблоны в исполняемый код шаблона в браузере
во время выполнения.
Angular доверяет коду шаблона, поэтому динамическая генерация шаблонов и их компиляция, в частности шаблонов, содержащих
пользовательские данные, обходит встроенные средства защиты Angular. Это антипаттерн безопасности.
Информацию о безопасном динамическом создании форм см. в руководстве [Динамические формы](guide/forms/dynamic-forms).

### Защита от XSS на стороне сервера

HTML, созданный на сервере, уязвим для атак инъекции.
Внедрение кода шаблона в приложение Angular равносильно внедрению исполняемого кода в приложение:
Это дает злоумышленнику полный контроль над приложением.
Чтобы предотвратить это, используйте язык шаблонов, который автоматически экранирует значения для предотвращения
XSS-уязвимостей на сервере.
Не создавайте шаблоны Angular на стороне сервера с использованием языка шаблонов. Это несет высокий риск возникновения
уязвимостей инъекции шаблона.

## Уязвимости уровня HTTP

Angular имеет встроенную поддержку для предотвращения двух распространенных HTTP-уязвимостей: межсайтовой подделки
запроса (CSRF или XSRF) и межсайтового включения скриптов (XSSI).
Обе эти уязвимости должны устраняться в первую очередь на стороне сервера, но Angular предоставляет вспомогательные
средства для упрощения интеграции на стороне клиента.

### Межсайтовая подделка запроса (CSRF)

При межсайтовой подделке запроса (CSRF или XSRF) злоумышленник обманом заставляет пользователя посетить другую
веб-страницу (например, `evil.com`) с вредоносным кодом. Эта веб-страница тайно отправляет вредоносный запрос на
веб-сервер приложения (например, `example-bank.com`).

Предположим, что пользователь вошел в приложение на `example-bank.com`.
Пользователь открывает электронное письмо и нажимает ссылку на `evil.com`, которая открывается в новой вкладке.

Страница `evil.com` немедленно отправляет вредоносный запрос на `example-bank.com`.
Возможно, это запрос на перевод денег со счета пользователя на счет злоумышленника.
Браузер автоматически отправляет файлы cookie `example-bank.com`, включая cookie аутентификации, с этим запросом.

Если сервер `example-bank.com` не имеет защиты от XSRF, он не сможет отличить легитимный запрос от приложения и
поддельный запрос от `evil.com`.

Чтобы предотвратить это, приложение должно гарантировать, что запрос пользователя исходит из реального приложения, а не
с другого сайта.
Сервер и клиент должны сотрудничать, чтобы предотвратить эту атаку.

В распространенной технике защиты от XSRF сервер приложения отправляет случайно созданный токен аутентификации в cookie.
Клиентский код считывает cookie и добавляет пользовательский заголовок запроса с токеном во все последующие запросы.
Сервер сравнивает полученное значение cookie со значением заголовка запроса и отклоняет запрос, если значения
отсутствуют или не совпадают.

Эта техника эффективна, потому что все браузеры реализуют _политику одинакового источника_ (same origin policy).
Только код с веб-сайта, на котором установлены файлы cookie, может читать файлы cookie с этого сайта и устанавливать
пользовательские заголовки для запросов к этому сайту.
Это означает, что только ваше приложение может прочитать этот токен из cookie и установить пользовательский заголовок.
Вредоносный код на `evil.com` этого сделать не может.

### Безопасность XSRF/CSRF в `HttpClient`

`HttpClient`
поддерживает [распространенный механизм](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token),
используемый для предотвращения атак XSRF. При выполнении HTTP-запросов Interceptor считывает токен из cookie (по
умолчанию `XSRF-TOKEN`) и устанавливает его в качестве HTTP-заголовка `X-XSRF-TOKEN`. Поскольку только код, работающий в
вашем домене, может прочитать cookie, бэкенд может быть уверен, что HTTP-запрос пришел из вашего клиентского приложения,
а не от злоумышленника.

По умолчанию Interceptor отправляет этот заголовок во всех изменяющих запросах (таких как `POST`) к относительным URL,
но не в запросах GET/HEAD или запросах с абсолютным URL.

<docs-callout helpful title="Почему не защищаются GET-запросы?">
Защита от CSRF необходима только для запросов, которые могут изменить состояние на бэкенде. По своей природе атаки CSRF пересекают границы доменов, и [политика одинакового источника](https://developer.mozilla.org/docs/Web/Security/Same-origin_policy) в вебе не позволит атакующей странице получить результаты аутентифицированных GET-запросов.
</docs-callout>

Чтобы воспользоваться этим, ваш сервер должен установить токен в читаемом JavaScript cookie сессии с именем `XSRF-TOKEN`
либо при загрузке страницы, либо при первом GET-запросе. При последующих запросах сервер может проверить, совпадает ли
cookie с HTTP-заголовком `X-XSRF-TOKEN`, и, следовательно, быть уверенным, что только код, работающий в вашем домене,
мог отправить запрос. Токен должен быть уникальным для каждого пользователя и должен проверяться сервером; это
предотвращает создание клиентом собственных токенов. Установите токен как дайджест аутентификационного cookie вашего
сайта с солью для дополнительной безопасности.

Чтобы предотвратить коллизии в средах, где несколько приложений Angular используют один и тот же домен или поддомен,
дайте каждому приложению уникальное имя cookie.

<docs-callout important title="HttpClient поддерживает только клиентскую часть схемы защиты от XSRF">
  Ваш бэкенд-сервис должен быть настроен на установку cookie для вашей страницы и проверку наличия заголовка во всех подходящих запросах. Невыполнение этого требования делает защиту Angular по умолчанию неэффективной.
</docs-callout>

### Настройка пользовательских имен cookie/заголовка

Если ваш бэкенд-сервис использует другие имена для cookie или заголовка токена XSRF, используйте `withXsrfConfiguration`
для переопределения значений по умолчанию.

Добавьте его в вызов `provideHttpClient` следующим образом:

```ts
export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withXsrfConfiguration({
        cookieName: 'CUSTOM_XSRF_TOKEN',
        headerName: 'X-Custom-Xsrf-Header',
      }),
    ),
  ]
};
```

### Отключение защиты от XSRF

Если встроенный механизм защиты от XSRF не подходит для вашего приложения, вы можете отключить его с помощью функции
`withNoXsrfProtection`:

```ts
export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withNoXsrfProtection(),
    ),
  ]
};
```

Информацию о CSRF в Open Web Application Security Project (OWASP) см. в
разделах [Cross-Site Request Forgery (CSRF)](https://owasp.org/www-community/attacks/csrf)
и [Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html).
Статья Стэнфордского
университета [Robust Defenses for Cross-Site Request Forgery](https://seclab.stanford.edu/websec/csrf/csrf.pdf) является
богатым источником подробностей.

См. также доклад Дэйва
Смита [об XSRF на AngularConnect 2016](https://www.youtube.com/watch?v=9inczw6qtpY 'Cross Site Request Funkery Securing Your Angular Apps From Evil Doers').

### Межсайтовое включение скриптов (XSSI)

Межсайтовое включение скриптов, также известное как уязвимость JSON, может позволить веб-сайту злоумышленника считывать
данные из JSON API.
Атака работает в старых браузерах путем переопределения встроенных конструкторов объектов JavaScript и последующего
включения URL API с использованием тега `<script>`.

Эта атака успешна только в том случае, если возвращаемый JSON исполняется как JavaScript.
Серверы могут предотвратить атаку, добавляя префикс ко всем ответам JSON, чтобы сделать их неисполняемыми, по соглашению
используя известную строку `")]}',\n"`.

Библиотека `HttpClient` Angular распознает это соглашение и автоматически удаляет строку `")]}',\n"` из всех ответов
перед дальнейшим парсингом.

Для получения дополнительной информации см. раздел XSSI в
этом [посте блога Google по веб-безопасности](https://security.googleblog.com/2011/05/website-security-for-webmasters.html).

## Аудит приложений Angular

Приложения Angular должны следовать тем же принципам безопасности, что и обычные веб-приложения, и должны проходить
аудит соответствующим образом.
Специфичные для Angular API, которые должны проверяться в ходе аудита безопасности, такие как методы [
_bypassSecurityTrust_](#trusting-safe-values), помечены в документации как чувствительные к безопасности.
