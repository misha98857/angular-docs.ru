<docs-decorative-header title="Сигналы Angular" imgSrc="adev/src/assets/images/signals.svg"> <!-- markdownlint-disable-line -->
Сигналы Angular — это система, которая детально отслеживает, как и где используется состояние вашего приложения, позволяя фреймворку оптимизировать обновления рендеринга.
</docs-decorative-header>

TIP: Ознакомьтесь с разделом [Основы](essentials/signals) перед изучением этого подробного руководства.

## Что такое сигналы?

**Сигнал (signal)** — это обертка вокруг значения, которая может уведомлять заинтересованных потребителей при изменении
этого значения. Сигналы могут содержать любые значения: от примитивов до сложных структур данных.

Вы читаете значение сигнала, вызывая его функцию-геттер, что позволяет Angular отслеживать места использования сигнала.

Сигналы могут быть _записываемыми (writable)_ или _только для чтения (read-only)_.

### Записываемые сигналы (Writable signals)

Записываемые сигналы предоставляют API для непосредственного обновления их значений. Вы создаете записываемые сигналы,
вызывая функцию `signal` с начальным значением:

```ts
const count = signal(0);

// Signals are getter functions - calling them reads their value.
console.log('The count is: ' + count());
```

Чтобы изменить значение записываемого сигнала, либо установите его напрямую через `.set()`:

```ts
count.set(3);
```

либо используйте операцию `.update()` для вычисления нового значения на основе предыдущего:

```ts
// Increment the count by 1.
count.update(value => value + 1);
```

Записываемые сигналы имеют тип `WritableSignal`.

### Вычисляемые сигналы (Computed signals)

**Вычисляемые сигналы (Computed signals)** — это сигналы только для чтения, которые получают свое значение из других
сигналов. Вы определяете вычисляемые сигналы, используя функцию `computed` и указывая функцию вывода (derivation
function):

```typescript
const count: WritableSignal<number> = signal(0);
const doubleCount: Signal<number> = computed(() => count() * 2);
```

Сигнал `doubleCount` зависит от сигнала `count`. Всякий раз, когда обновляется `count`, Angular знает, что `doubleCount`
также необходимо обновить.

#### Вычисляемые сигналы вычисляются лениво и мемоизируются

Функция вывода `doubleCount` не запускается для вычисления значения до тех пор, пока вы не прочитаете `doubleCount` в
первый раз. Вычисленное значение затем кэшируется, и при повторном чтении `doubleCount` вернется кэшированное значение
без пересчета.

Если вы затем измените `count`, Angular узнает, что кэшированное значение `doubleCount` больше не действительно, и при
следующем чтении `doubleCount` его новое значение будет вычислено.

В результате вы можете безопасно выполнять в вычисляемых сигналах ресурсоемкие операции, такие как фильтрация массивов.

#### Вычисляемые сигналы не являются записываемыми

Вы не можете напрямую присваивать значения вычисляемому сигналу. То есть:

```ts
doubleCount.set(3);
```

вызовет ошибку компиляции, так как `doubleCount` не является `WritableSignal`.

#### Зависимости вычисляемых сигналов динамичны

Отслеживаются только те сигналы, которые фактически были прочитаны во время выполнения функции вывода. Например, в этом
`computed` сигнал `count` читается только в том случае, если сигнал `showCount` истинен:

```ts
const showCount = signal(false);
const count = signal(0);
const conditionalCount = computed(() => {
  if (showCount()) {
    return `The count is ${count()}.`;
  } else {
    return 'Nothing to see here!';
  }
});
```

Когда вы читаете `conditionalCount`, если `showCount` равен `false`, возвращается сообщение "Nothing to see here!" _без_
чтения сигнала `count`. Это означает, что если вы позже обновите `count`, это _не_ приведет к пересчету
`conditionalCount`.

Если вы установите `showCount` в `true`, а затем снова прочитаете `conditionalCount`, функция вывода выполнится заново и
пойдет по ветке, где `showCount` равен `true`, возвращая сообщение со значением `count`. Изменение `count` после этого
сделает недействительным кэшированное значение `conditionalCount`.

Обратите внимание, что зависимости могут как добавляться, так и удаляться в процессе вычисления. Если вы позже
установите `showCount` обратно в `false`, то `count` больше не будет считаться зависимостью `conditionalCount`.

## Чтение сигналов в компонентах `OnPush`

Когда вы читаете сигнал внутри шаблона компонента с `OnPush`, Angular отслеживает этот сигнал как зависимость
компонента. Когда значение этого сигнала изменяется, Angular
автоматически [помечает](api/core/ChangeDetectorRef#markforcheck) компонент, чтобы гарантировать его обновление при
следующем запуске обнаружения изменений. Обратитесь к
руководству [Пропуск поддеревьев компонентов](best-practices/skipping-subtrees) для получения дополнительной информации
о компонентах `OnPush`.

## Эффекты (Effects)

Сигналы полезны тем, что уведомляют заинтересованных потребителей об изменениях. **Эффект (effect)** — это операция,
которая выполняется всякий раз, когда изменяется одно или несколько значений сигналов. Вы можете создать эффект с
помощью функции `effect`:

```ts
effect(() => {
  console.log(`The current count is: ${count()}`);
});
```

Эффекты всегда выполняются **хотя бы один раз.** Когда эффект выполняется, он отслеживает любые чтения значений
сигналов. Всякий раз, когда любое из этих значений сигналов изменяется, эффект выполняется снова. Подобно вычисляемым
сигналам, эффекты отслеживают свои зависимости динамически и учитывают только те сигналы, которые были прочитаны при
последнем выполнении.

Эффекты всегда выполняются **асинхронно**, во время процесса обнаружения изменений.

### Случаи использования эффектов

Эффекты редко нужны в большинстве кодовых баз приложений, но могут быть полезны в конкретных обстоятельствах. Вот
несколько примеров ситуаций, когда `effect` может быть хорошим решением:

- Логирование отображаемых данных и их изменений (для аналитики или отладки).
- Синхронизация данных с `window.localStorage`.
- Добавление пользовательского поведения DOM, которое нельзя выразить с помощью синтаксиса шаблона.
- Выполнение пользовательского рендеринга в `<canvas>`, библиотеку диаграмм или другую стороннюю библиотеку UI.

<docs-callout critical title="Когда не следует использовать эффекты">
Избегайте использования эффектов для распространения изменений состояния. Это может привести к ошибкам `ExpressionChangedAfterItHasBeenChecked`, бесконечным циклическим обновлениям или ненужным циклам обнаружения изменений.

Вместо этого используйте `computed` сигналы для моделирования состояния, которое зависит от другого состояния.
</docs-callout>

### Контекст внедрения (Injection context)

По умолчанию вы можете создать `effect()` только внутри [контекста внедрения](guide/di/dependency-injection-context) (
где у вас есть доступ к функции `inject`). Самый простой способ выполнить это требование — вызвать `effect` внутри
`constructor` компонента, директивы или сервиса:

```ts
@Component({...})
export class EffectiveCounterComponent {
  readonly count = signal(0);
  constructor() {
    // Register a new effect.
    effect(() => {
      console.log(`The count is: ${this.count()}`);
    });
  }
}
```

В качестве альтернативы вы можете присвоить эффект полю (что также дает ему описательное имя).

```ts
@Component({...})
export class EffectiveCounterComponent {
  readonly count = signal(0);

  private loggingEffect = effect(() => {
    console.log(`The count is: ${this.count()}`);
  });
}
```

Чтобы создать эффект вне конструктора, вы можете передать `Injector` в `effect` через его опции:

```ts
@Component({...})
export class EffectiveCounterComponent {
  readonly count = signal(0);
  private injector = inject(Injector);

  initializeLogging(): void {
    effect(() => {
      console.log(`The count is: ${this.count()}`);
    }, {injector: this.injector});
  }
}
```

### Уничтожение эффектов

Когда вы создаете эффект, он автоматически уничтожается при уничтожении его содержащего контекста. Это означает, что
эффекты, созданные внутри компонентов, уничтожаются при уничтожении компонента. То же самое касается эффектов внутри
директив, сервисов и т.д.

Эффекты возвращают `EffectRef`, который вы можете использовать для их ручного уничтожения, вызвав метод `.destroy()`. Вы
можете комбинировать это с опцией `manualCleanup`, чтобы создать эффект, который существует до тех пор, пока не будет
уничтожен вручную. Будьте осторожны и не забывайте очищать такие эффекты, когда они больше не нужны.

## Продвинутые темы

### Функции равенства сигналов

При создании сигнала вы можете опционально предоставить функцию равенства, которая будет использоваться для проверки
того, действительно ли новое значение отличается от предыдущего.

```ts
import _ from 'lodash';

const data = signal(['test'], {equal: _.isEqual});

// Even though this is a different array instance, the deep equality
// function will consider the values to be equal, and the signal won't
// trigger any updates.
data.set(['test']);
```

Функции равенства могут быть предоставлены как для записываемых, так и для вычисляемых сигналов.

HELPFUL: По умолчанию сигналы используют ссылочное равенство (сравнение [
`Object.is()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/is)).

### Проверка типов сигналов

Вы можете использовать `isSignal`, чтобы проверить, является ли значение `Signal`:

```ts
const count = signal(0);
const doubled = computed(() => count() * 2);

isSignal(count); // true
isSignal(doubled); // true
isSignal(42); // false
```

Чтобы конкретно проверить, является ли сигнал записываемым, используйте `isWritableSignal`:

```ts
const count = signal(0);
const doubled = computed(() => count() * 2);

isWritableSignal(count); // true
isWritableSignal(doubled); // false
```

### Чтение без отслеживания зависимостей

В редких случаях вам может понадобиться выполнить код, который читает сигналы внутри реактивной функции (например,
`computed` или `effect`) _без_ создания зависимости.

Например, предположим, что при изменении `currentUser` должно логироваться значение `counter`. Вы можете создать
`effect`, который читает оба сигнала:

```ts
effect(() => {
  console.log(`User set to ${currentUser()} and the counter is ${counter()}`);
});
```

Этот пример будет логировать сообщение, когда изменяется _либо_ `currentUser`, _либо_ `counter`. Однако, если эффект
должен запускаться только при изменении `currentUser`, то чтение `counter` является лишь попутным, и изменения `counter`
не должны вызывать логирование нового сообщения.

Вы можете предотвратить отслеживание чтения сигнала, вызвав его геттер с помощью `untracked`:

```ts
effect(() => {
  console.log(`User set to ${currentUser()} and the counter is ${untracked(counter)}`);
});
```

`untracked` также полезен, когда эффекту необходимо вызвать некоторый внешний код, который не должен рассматриваться как
зависимость:

```ts
effect(() => {
  const user = currentUser();
  untracked(() => {
    // If the `loggingService` reads signals, they won't be counted as
    // dependencies of this effect.
    this.loggingService.log(`User set to ${user}`);
  });
});
```

### Функции очистки эффектов

Эффекты могут запускать длительные операции, которые следует отменить, если эффект будет уничтожен или запустится снова
до завершения первой операции. Когда вы создаете эффект, ваша функция может опционально принимать функцию `onCleanup` в
качестве первого параметра. Эта функция `onCleanup` позволяет зарегистрировать колбэк, который вызывается перед началом
следующего запуска эффекта или при уничтожении эффекта.

```ts
effect((onCleanup) => {
  const user = currentUser();

  const timer = setTimeout(() => {
    console.log(`1 second ago, the user became ${user}`);
  }, 1000);

  onCleanup(() => {
    clearTimeout(timer);
  });
});
```

## Использование сигналов с RxJS

Смотрите [Взаимодействие RxJS с сигналами Angular](ecosystem/rxjs-interop) для подробностей о совместимости между
сигналами и RxJS.
