# Отложенная загрузка с помощью `@defer`

Откладываемые представления (deferrable views), также известные как блоки `@defer`, уменьшают начальный размер бандла
вашего приложения за счет откладывания загрузки кода, который не является строго необходимым для первоначального
рендеринга страницы. Это часто приводит к более быстрой начальной загрузке и улучшению показателей Core Web Vitals (
CWV), в первую очередь Largest Contentful Paint (LCP) и Time to First Byte (TTFB).

Чтобы использовать эту функцию, вы можете декларативно обернуть часть шаблона в блок `@defer`:

```angular-html
@defer {
  <large-component />
}
```

Код любых компонентов, директив и пайпов внутри блока `@defer` выделяется в отдельный JavaScript-файл и загружается
только при необходимости, после того как остальная часть шаблона будет отрисована.

Откладываемые представления поддерживают различные триггеры, опции предварительной выборки (prefetching) и подблоки для
управления состоянием плейсхолдера, загрузки и ошибки.

## Какие зависимости откладываются?

Компоненты, директивы, пайпы и любые CSS-стили компонентов могут быть отложены при загрузке приложения.

Чтобы зависимости внутри блока `@defer` были отложены, они должны соответствовать двум условиям:

1. **Они должны быть standalone-компонентами.** Не standalone-зависимости не могут быть отложены и будут загружены
   сразу (eagerly loaded), даже если они находятся внутри блоков `@defer`.
2. **На них не должно быть ссылок вне блоков `@defer` в том же файле.** Если на них есть ссылки вне блока `@defer` или
   внутри запросов ViewChild, зависимости будут загружены сразу.

_Транзитивные_ зависимости компонентов, директив и пайпов, используемых в блоке `@defer`, не обязательно должны быть
standalone; транзитивные зависимости все равно могут быть объявлены в `NgModule` и участвовать в отложенной загрузке.

Компилятор Angular создает
инструкцию [динамического импорта](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import)
для каждого компонента, директивы и пайпа, используемого в блоке `@defer`. Основное содержимое блока рендерится после
разрешения всех импортов. Angular не гарантирует определенного порядка для этих импортов.

## Управление различными этапами отложенной загрузки

Блоки `@defer` имеют несколько подблоков, позволяющих корректно обрабатывать различные этапы процесса отложенной
загрузки.

### `@defer`

Это основной блок, определяющий секцию контента, которая загружается лениво. Изначально он не рендерится — отложенный
контент загружается и рендерится, когда срабатывает указанный [триггер](/guide/templates/defer#triggers) или выполняется
условие `when`.

По умолчанию блок `@defer` срабатывает, когда состояние браузера становится [idle](/guide/templates/defer#idle) (
простаивающим).

```angular-html
@defer {
  <large-component />
}
```

### Отображение плейсхолдера с помощью `@placeholder`

По умолчанию блоки defer не рендерят никакого контента до срабатывания триггера.

`@placeholder` — это необязательный блок, который объявляет, какой контент показывать до срабатывания блока `@defer`.

```angular-html
@defer {
  <large-component />
} @placeholder {
  <p>Placeholder content</p>
}
```

Хотя он необязателен, некоторые триггеры могут требовать наличия либо `@placeholder`,
либо [ссылочной переменной шаблона](/guide/templates/variables#template-reference-variables) для работы. См.
раздел [Триггеры](/guide/templates/defer#triggers) для подробностей.

Angular заменяет контент плейсхолдера основным контентом после завершения загрузки. Вы можете использовать любой контент
в секции плейсхолдера, включая обычный HTML, компоненты, директивы и пайпы. Помните, что _зависимости блока placeholder
загружаются сразу (eagerly loaded)_.

Блок `@placeholder` принимает необязательный параметр для указания `minimum` (минимального) времени, в течение которого
этот плейсхолдер должен отображаться после первоначального рендеринга.

```angular-html
@defer {
  <large-component />
} @placeholder (minimum 500ms) {
  <p>Placeholder content</p>
}
```

Параметр `minimum` указывается в миллисекундах (ms) или секундах (s). Вы можете использовать этот параметр для
предотвращения быстрого мерцания контента плейсхолдера в случае, если отложенные зависимости загружаются быстро.

### Отображение контента загрузки с помощью `@loading`

Блок `@loading` — это необязательный блок, позволяющий объявить контент, который показывается во время загрузки
отложенных зависимостей. Он заменяет блок `@placeholder`, как только срабатывает загрузка.

```angular-html
@defer {
  <large-component />
} @loading {
  <img alt="loading..." src="loading.gif" />
} @placeholder {
  <p>Placeholder content</p>
}
```

Его зависимости загружаются сразу (аналогично `@placeholder`).

Блок `@loading` принимает два необязательных параметра, помогающих предотвратить быстрое мерцание контента, которое
может возникнуть при быстрой загрузке отложенных зависимостей:

- `minimum` — минимальное время, в течение которого должен показываться этот шаблон.
- `after` — время ожидания после начала загрузки перед показом шаблона загрузки.

```angular-html
@defer {
  <large-component />
} @loading (after 100ms; minimum 1s) {
  <img alt="loading..." src="loading.gif" />
}
```

Оба параметра указываются в миллисекундах (ms) или секундах (s). Кроме того, таймеры для обоих параметров запускаются
сразу после срабатывания загрузки.

### Отображение состояния ошибки при сбое загрузки с помощью `@error`

Блок `@error` — это необязательный блок, который отображается, если отложенная загрузка завершилась неудачей. Как и в
случае с `@placeholder` и `@loading`, зависимости блока `@error` загружаются сразу.

```angular-html
@defer {
  <large-component />
} @error {
  <p>Failed to load large component.</p>
}
```

## Управление загрузкой отложенного контента с помощью триггеров

Вы можете указать **триггеры**, которые управляют тем, когда Angular загружает и отображает отложенный контент.

Когда срабатывает блок `@defer`, он заменяет контент плейсхолдера лениво загруженным контентом.

Можно определить несколько триггеров событий, разделив их точкой с запятой `;`; они будут оцениваться как условия ИЛИ.

Существует два типа триггеров: `on` и `when`.

### `on`

`on` задает условие срабатывания блока `@defer`.

Доступны следующие триггеры:

| Триггер                       | Описание                                                               |
| ----------------------------- | ---------------------------------------------------------------------- |
| [`idle`](#idle)               | Срабатывает, когда браузер простаивает.                                |
| [`viewport`](#viewport)       | Срабатывает, когда указанный контент попадает в область видимости.     |
| [`interaction`](#interaction) | Срабатывает, когда пользователь взаимодействует с указанным элементом. |
| [`hover`](#hover)             | Срабатывает, когда мышь наводится на указанную область.                |
| [`immediate`](#immediate)     | Срабатывает сразу после завершения рендеринга неотложенного контента.  |
| [`timer`](#timer)             | Срабатывает через определенный промежуток времени.                     |

#### `idle`

Триггер `idle` загружает отложенный контент, как только браузер переходит в состояние простоя, основываясь на
requestIdleCallback. Это поведение по умолчанию для блока defer.

```angular-html
<!-- @defer (on idle) -->
@defer {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

#### `viewport`

Триггер `viewport` загружает отложенный контент, когда указанный контент попадает в область видимости (viewport),
используя [Intersection Observer API](https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API). Наблюдаемым
контентом может быть контент `@placeholder` или явная ссылка на элемент.

По умолчанию `@defer` следит за появлением плейсхолдера в области видимости. Плейсхолдеры, используемые таким образом,
должны иметь один корневой элемент.

```angular-html
@defer (on viewport) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

Альтернативно, вы можете указать [ссылочную переменную шаблона](/guide/templates/variables) в том же шаблоне, где
находится блок `@defer`, в качестве элемента, за появлением которого нужно следить. Эта переменная передается как
параметр триггера viewport.

```angular-html
<div #greeting>Hello!</div>
@defer (on viewport(greeting)) {
  <greetings-cmp />
}
```

Если вы хотите настроить параметры `IntersectionObserver`, триггер `viewport` поддерживает передачу объектного литерала.
Литерал поддерживает все свойства второго параметра `IntersectionObserver`, за исключением `root`. При использовании
нотации объектного литерала необходимо передать триггер через свойство `trigger`.

```angular-html
<div #greeting>Hello!</div>

<!-- With options and a trigger -->
@defer (on viewport({trigger: greeting, rootMargin: '100px', threshold: 0.5})) {
  <greetings-cmp />
}

<!-- With options and an implied trigger -->
@defer (on viewport({rootMargin: '100px', threshold: 0.5})) {
  <greetings-cmp />
} @placeholder {
  <div>Implied trigger</div>
}
```

#### `interaction`

Триггер `interaction` загружает отложенный контент, когда пользователь взаимодействует с указанным элементом посредством
событий `click` или `keydown`.

По умолчанию плейсхолдер выступает в роли элемента взаимодействия. Плейсхолдеры, используемые таким образом, должны
иметь один корневой элемент.

```angular-html
@defer (on interaction) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

Альтернативно, вы можете указать [ссылочную переменную шаблона](/guide/templates/variables) в том же шаблоне, где
находится блок `@defer`, в качестве элемента, за взаимодействием с которым нужно следить. Эта переменная передается как
параметр триггера viewport.

```angular-html
<div #greeting>Hello!</div>
@defer (on interaction(greeting)) {
  <greetings-cmp />
}
```

#### `hover`

Триггер `hover` загружает отложенный контент, когда мышь наводится на триггерную область (события `mouseover` и
`focusin`).

По умолчанию плейсхолдер выступает в роли элемента взаимодействия. Плейсхолдеры, используемые таким образом, должны
иметь один корневой элемент.

```angular-html
@defer (on hover) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

Альтернативно, вы можете указать [ссылочную переменную шаблона](/guide/templates/variables) в том же шаблоне, где
находится блок `@defer`, в качестве элемента, за появлением которого нужно следить. Эта переменная передается как
параметр триггера viewport.

```angular-html
<div #greeting>Hello!</div>
@defer (on hover(greeting)) {
  <greetings-cmp />
}
```

#### `immediate`

Триггер `immediate` загружает отложенный контент немедленно. Это означает, что отложенный блок загружается, как только
весь остальной неотложенный контент завершит рендеринг.

```angular-html
@defer (on immediate) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

#### `timer`

Триггер `timer` загружает отложенный контент через указанный промежуток времени.

```angular-html
@defer (on timer(500ms)) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

Параметр длительности должен быть указан в миллисекундах (`ms`) или секундах (`s`).

### `when`

Триггер `when` принимает пользовательское условное выражение и загружает отложенный контент, когда условие становится
истинным (truthy).

```angular-html
@defer (when condition) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

Это одноразовая операция — блок `@defer` не возвращается к плейсхолдеру, если условие меняется на ложное после того, как
стало истинным.

## Предварительная выборка данных с помощью `prefetch`

В дополнение к указанию условия, определяющего, когда будет показан отложенный контент, вы можете опционально указать \*
\*триггер предварительной выборки (prefetch trigger)\*\*. Этот триггер позволяет загрузить JavaScript, связанный с блоком
`@defer`, до того, как отложенный контент будет показан.

Предварительная выборка обеспечивает более продвинутое поведение, например, позволяя начать загрузку ресурсов до того,
как пользователь фактически увидит или провзаимодействует с блоком defer, но, возможно, сделает это в ближайшее время,
что ускоряет доступность ресурсов.

Вы можете указать триггер prefetch аналогично основному триггеру блока, но с префиксом `prefetch`. Основной триггер
блока и триггер prefetch разделяются точкой с запятой (`;`).

В примере ниже предварительная выборка начинается, когда браузер переходит в состояние простоя, а содержимое блока
рендерится только после того, как пользователь взаимодействует с плейсхолдером.

```angular-html
@defer (on interaction; prefetch on idle) {
  <large-cmp />
} @placeholder {
  <div>Large component placeholder</div>
}
```

## Тестирование блоков `@defer`

Angular предоставляет API TestBed для упрощения процесса тестирования блоков `@defer` и переключения различных состояний
во время тестов. По умолчанию блоки `@defer` в тестах ведут себя так же, как в реальном приложении. Если вы хотите
вручную переключать состояния, вы можете переключить поведение блока defer на `Manual` в конфигурации TestBed.

```angular-ts
it('should render a defer block in different states', async () => {
  // configures the defer block behavior to start in "paused" state for manual control.
  TestBed.configureTestingModule({deferBlockBehavior: DeferBlockBehavior.Manual});
  @Component({
    // ...
    template: `
      @defer {
        <large-component />
      } @placeholder {
        Placeholder
      } @loading {
        Loading...
      }
    `
  })
  class ComponentA {}
  // Create component fixture.
  const componentFixture = TestBed.createComponent(ComponentA);
  // Retrieve the list of all defer block fixtures and get the first block.
  const deferBlockFixture = (await componentFixture.getDeferBlocks())[0];
  // Renders placeholder state by default.
  expect(componentFixture.nativeElement.innerHTML).toContain('Placeholder');
  // Render loading state and verify rendered output.
  await deferBlockFixture.render(DeferBlockState.Loading);
  expect(componentFixture.nativeElement.innerHTML).toContain('Loading');
  // Render final state and verify the output.
  await deferBlockFixture.render(DeferBlockState.Complete);
  expect(componentFixture.nativeElement.innerHTML).toContain('large works!');
});
```

## Работает ли `@defer` с `NgModule`?

Блоки `@defer` совместимы как со standalone-компонентами, так и с компонентами, директивами и пайпами на основе
NgModule. Однако **только standalone-компоненты, директивы и пайпы могут быть отложены**. Зависимости на основе NgModule
не откладываются и включаются в бандл, загружаемый сразу.

## Совместимость блоков `@defer` и Hot Module Reload (HMR)

Когда активен Hot Module Replacement (HMR), все чанки блоков `@defer` загружаются сразу (eagerly), игнорируя любые
настроенные триггеры. Чтобы восстановить стандартное поведение триггеров, необходимо отключить HMR, запустив приложение
с флагом `--no-hmr`.

## Как `@defer` работает с рендерингом на стороне сервера (SSR) и генерацией статических сайтов (SSG)?

По умолчанию при рендеринге приложения на сервере (с использованием SSR или SSG) блоки defer всегда рендерят свой
`@placeholder` (или ничего, если плейсхолдер не указан), и триггеры не вызываются. На клиенте контент `@placeholder`
гидратируется, и триггеры активируются.

Чтобы отрендерить основное содержимое блоков `@defer` на сервере (как SSR, так и SSG), вы можете
включить [функцию инкрементальной гидратации](/guide/incremental-hydration) и настроить триггеры `hydrate` для
необходимых блоков.

## Лучшие практики для откладывания представлений

### Избегайте каскадных загрузок с вложенными блоками `@defer`

Если у вас есть вложенные блоки `@defer`, они должны иметь разные триггеры, чтобы избежать одновременной загрузки,
которая вызывает каскадные запросы и может негативно повлиять на производительность загрузки страницы.

### Избегайте сдвигов макета (layout shifts)

Избегайте откладывания компонентов, которые видны в области просмотра пользователя при начальной загрузке. Это может
негативно повлиять на Core Web Vitals, вызывая увеличение совокупного сдвига макета (CLS).

В случае, если это необходимо, избегайте триггеров `immediate`, `timer`, `viewport` и пользовательских `when`, которые
вызывают загрузку контента во время начального рендеринга страницы.

### Помните о доступности

При использовании блоков `@defer` учитывайте влияние на пользователей вспомогательных технологий, таких как скринридеры.
Скринридеры, сфокусированные на отложенной секции, сначала прочитают плейсхолдер или контент загрузки, но могут не
объявить об изменениях, когда отложенный контент загрузится.

Чтобы гарантировать, что изменения отложенного контента будут объявлены скринридерам, вы можете обернуть блок `@defer` в
элемент с live region:

```angular-html
<div aria-live="polite" aria-atomic="true">
  @defer (on timer(2000)) {
    <user-profile [user]="currentUser" />
  } @placeholder {
    Loading user profile...
  } @loading {
    Please wait...
  } @error {
    Failed to load profile
  }
</div>
```

Это гарантирует, что изменения будут объявлены пользователю при возникновении переходов (плейсхолдер &rarr; загрузка
&rarr; контент/ошибка).
