# Управление потоком

Шаблоны Angular поддерживают блоки управления потоком, которые позволяют условно показывать, скрывать и повторять
элементы.

## Условное отображение контента с помощью `@if`, `@else-if` и `@else`

Блок `@if` отображает свой контент, если выражение условия истинно:

```angular-html
@if (a > b) {
  <p>{{a}} is greater than {{b}}</p>
}
```

Если вы хотите отобразить альтернативный контент, вы можете сделать это, добавив любое количество блоков `@else if` и
один блок `@else`.

```angular-html
@if (a > b) {
  {{a}} is greater than {{b}}
} @else if (b > a) {
  {{a}} is less than {{b}}
} @else {
  {{a}} is equal to {{b}}
}
```

### Ссылка на результат условного выражения

Условие `@if` поддерживает сохранение результата условного выражения в переменную для повторного использования внутри
блока.

```angular-html
@if (user.profile.settings.startDate; as startDate) {
  {{ startDate }}
}
```

Это может быть полезно для обращения к длинным выражениям, чтобы упростить чтение и поддержку шаблона.

## Повторение контента с помощью блока `@for`

Блок `@for` перебирает коллекцию и многократно рендерит контент блока. Коллекцией может быть любой
JavaScript [iterable](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Iteration_protocols), но Angular имеет
дополнительные оптимизации производительности для значений `Array`.

Типичный цикл `@for` выглядит так:

```angular-html
@for (item of items; track item.id) {
  {{ item.name }}
}
```

Блок `@for` в Angular не поддерживает инструкции изменения потока, такие как `continue` или `break` в JavaScript.

### Почему `track` в блоках `@for` важен?

Выражение `track` позволяет Angular поддерживать связь между вашими данными и DOM-узлами на странице. Это позволяет
Angular оптимизировать производительность, выполняя минимум необходимых DOM-операций при изменении данных.

Эффективное использование `track` может значительно улучшить производительность рендеринга вашего приложения при
переборе коллекций данных.

Выберите свойство, которое уникально идентифицирует каждый элемент в выражении `track`. Если ваша модель данных включает
уникально идентифицирующее свойство, обычно `id` или `uuid`, используйте это значение. Если ваши данные не содержат
такого поля, настоятельно рекомендуется добавить его.

Для статических коллекций, которые никогда не меняются, вы можете использовать `$index`, чтобы указать Angular
отслеживать каждый элемент по его индексу в коллекции.

Если нет других вариантов, вы можете указать `identity`. Это говорит Angular отслеживать элемент по его ссылочной
идентичности, используя оператор строгого равенства (`===`). Избегайте этой опции по возможности, так как это может
привести к значительно более медленным обновлениям рендеринга, поскольку у Angular нет способа сопоставить, какой
элемент данных соответствует каким DOM-узлам.

### Контекстные переменные в блоках `@for`

Внутри блоков `@for` всегда доступно несколько неявных переменных:

| Переменная | Значение                                      |
| ---------- | --------------------------------------------- |
| `$count`   | Количество элементов в перебираемой коллекции |
| `$index`   | Индекс текущей строки                         |
| `$first`   | Является ли текущая строка первой             |
| `$last`    | Является ли текущая строка последней          |
| `$even`    | Является ли индекс текущей строки четным      |
| `$odd`     | Является ли индекс текущей строки нечетным    |

Эти переменные всегда доступны под этими именами, но им можно присвоить псевдонимы с помощью сегмента `let`:

```angular-html
@for (item of items; track item.id; let idx = $index, e = $even) {
  <p>Item #{{ idx }}: {{ item.name }}</p>
}
```

Псевдонимы полезны при вложенности блоков `@for`, позволяя читать переменные внешнего блока `@for` из внутреннего блока
`@for`.

### Предоставление запасного варианта для блоков `@for` с помощью блока `@empty`

Вы можете опционально включить секцию `@empty` сразу после контента блока `@for`. Контент блока `@empty` отображается,
когда элементов нет:

```angular-html
@for (item of items; track item.name) {
  <li> {{ item.name }}</li>
} @empty {
  <li> There are no items. </li>
}
```

## Условное отображение контента с помощью блока `@switch`

Хотя блок `@if` отлично подходит для большинства сценариев, блок `@switch` предоставляет альтернативный синтаксис для
условного рендеринга данных. Его синтаксис очень напоминает инструкцию `switch` в JavaScript.

```angular-html
@switch (userPermissions) {
  @case ('admin') {
    <app-admin-dashboard />
  }
  @case ('reviewer') {
    <app-reviewer-dashboard />
  }
  @case ('editor') {
    <app-editor-dashboard />
  }
  @default {
    <app-viewer-dashboard />
  }
}
```

Значение условного выражения сравнивается с выражением case с использованием оператора строгого равенства (`===`).

**`@switch` не имеет сквозного выполнения (fallthrough)**, поэтому вам не нужен эквивалент инструкции `break` или
`return` в блоке.

Вы можете опционально включить блок `@default`. Контент блока `@default` отображается, если ни одно из предшествующих
выражений case не совпадает со значением switch.

Если ни один `@case` не соответствует выражению и блок `@default` отсутствует, ничего не будет показано.
