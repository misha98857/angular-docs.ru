# Создание формы на основе шаблона

В этом руководстве показано, как создать форму на основе шаблона (template-driven form). Элементы управления в форме
привязаны к свойствам данных, имеющим валидацию ввода. Валидация ввода помогает поддерживать целостность данных и
стилизацию для улучшения пользовательского опыта.

Формы на основе шаблона используют [двустороннюю привязку данных](guide/templates/two-way-binding) для обновления модели
данных в компоненте при внесении изменений в шаблоне и наоборот.

<docs-callout helpful title="Template vs Reactive forms">
Angular поддерживает два подхода к проектированию интерактивных форм. Формы на основе шаблона позволяют использовать специфичные для форм директивы в шаблоне Angular. Реактивные формы предоставляют подход на основе модели (model-driven) для построения форм.

Формы на основе шаблона — отличный выбор для небольших или простых форм, тогда как реактивные формы более масштабируемы
и подходят для сложных форм. Сравнение двух подходов см. в разделе [Выбор подхода](guide/forms#choosing-an-approach).
</docs-callout>

С помощью шаблона Angular можно создать практически любую форму — формы входа, контактные формы и почти любые
бизнес-формы.
Вы можете творчески располагать элементы управления и привязывать их к данным в вашей объектной модели.
Вы можете задавать правила валидации и отображать ошибки валидации, условно разрешать ввод для определенных элементов
управления, запускать встроенную визуальную обратную связь и многое другое.

## Цели

В этом руководстве вы научитесь следующему:

- Создавать форму Angular с компонентом и шаблоном
- Использовать `ngModel` для создания двусторонней привязки данных для чтения и записи значений элементов управления
  ввода
- Предоставлять визуальную обратную связь с использованием специальных CSS-классов, отслеживающих состояние элементов
  управления
- Отображать ошибки валидации пользователям и условно разрешать ввод элементов управления формы на основе статуса формы
- Обмениваться информацией между HTML-элементами с
  помощью [переменных ссылки на шаблон](guide/templates/variables#template-reference-variables)

## Создание формы на основе шаблона

Формы на основе шаблона полагаются на директивы, определенные в `FormsModule`.

| Директивы      | Подробности                                                                                                                                                                                                                                                                                                             |
| :------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `NgModel`      | Согласует изменения значений в присоединенном элементе формы с изменениями в модели данных, позволяя реагировать на ввод пользователя с помощью валидации и обработки ошибок.                                                                                                                                           |
| `NgForm`       | Создает экземпляр `FormGroup` верхнего уровня и привязывает его к элементу `<form>` для отслеживания агрегированного значения формы и статуса валидации. Как только вы импортируете `FormsModule`, эта директива становится активной по умолчанию для всех тегов `<form>`. Вам не нужно добавлять специальный селектор. |
| `NgModelGroup` | Создает и привязывает экземпляр `FormGroup` к DOM-элементу.                                                                                                                                                                                                                                                             |

### Обзор шагов

В ходе этого руководства вы привяжете пример формы к данным и обработаете ввод пользователя, выполнив следующие шаги.

1. Создание базовой формы.

- Определение модели данных примера
- Включение необходимой инфраструктуры, такой как `FormsModule`

1. Привязка элементов управления формы к свойствам данных с использованием директивы `ngModel` и синтаксиса двусторонней
   привязки.

- Изучение того, как `ngModel` сообщает о состояниях элементов управления с помощью CSS-классов
- Именование элементов управления, чтобы сделать их доступными для `ngModel`

1. Отслеживание валидности ввода и статуса элемента управления с помощью `ngModel`.

- Добавление пользовательского CSS для обеспечения визуальной обратной связи о статусе
- Отображение и скрытие сообщений об ошибках валидации

1. Реагирование на нативное событие клика HTML-кнопки путем добавления данных в модель.
1. Обработка отправки формы с использованием выходного свойства [`ngSubmit`](api/forms/NgForm#properties) формы.

- Отключение кнопки **Submit** до тех пор, пока форма не станет валидной
- После отправки замена готовой формы на другой контент на странице

## Создание формы

<!-- TODO: link to preview -->
<!-- <docs-code live/> -->

1. Предоставленное приложение-пример создает класс `Actor`, который определяет модель данных, отраженную в форме.

   <docs-code header="actor.ts" language="typescript" path="adev/src/content/examples/forms/src/app/actor.ts"/>

1. Макет формы и детали определены в классе `ActorFormComponent`.

   <docs-code header="actor-form.component.ts (v1)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts" visibleRegion="v1"/>

   Значение `selector` компонента «app-actor-form» означает, что вы можете поместить эту форму в родительский шаблон,
   используя тег `<app-actor-form>`.

1. Следующий код создает новый экземпляр актера, чтобы начальная форма могла показать пример актера.

   <docs-code language="typescript" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts" language="typescript" visibleRegion="Marilyn"/>

   В этой демонстрации используются фиктивные данные для `model` и `skills`.
   В реальном приложении вы бы внедрили сервис данных для получения и сохранения реальных данных или предоставили бы эти
   свойства как входные (inputs) и выходные (outputs) данные.

1. Компонент включает функциональность форм, импортируя модуль `FormsModule`.

   <docs-code language="typescript" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts" language="typescript" visibleRegion="imports"/>

1. Форма отображается в макете приложения, определенном шаблоном корневого компонента.

   <docs-code header="app.component.html" language="html" path="adev/src/content/examples/forms/src/app/app.component.html"/>

   Начальный шаблон определяет макет для формы с двумя группами полей и кнопкой отправки.
   Группы полей соответствуют двум свойствам модели данных Actor: name и studio.
   Каждая группа имеет метку и поле для ввода пользователем.

- Элемент управления `<input>` **Name** имеет атрибут HTML5 `required`
- Элемент управления `<input>` **Studio** — нет, так как `studio` является необязательным

Кнопка **Submit** имеет несколько классов для стилизации.
На данном этапе макет формы представляет собой обычный HTML5 без привязок или директив.

1. Пример формы использует некоторые классы стилей из [Twitter Bootstrap](https://getbootstrap.com/css): `container`,
   `form-group`, `form-control` и `btn`.
   Чтобы использовать эти стили, таблица стилей приложения импортирует библиотеку.

   <docs-code header="styles.css" path="adev/src/content/examples/forms/src/styles.1.css"/>

1. Форма требует, чтобы навык актера был выбран из предопределенного списка `skills`, поддерживаемого внутри
   `ActorFormComponent`.
   Цикл Angular `@for` перебирает значения данных для заполнения элемента `<select>`.

   <docs-code header="actor-form.component.html (skills)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="skills"/>

Если вы запустите приложение прямо сейчас, вы увидите список навыков в элементе выбора.
Элементы ввода еще не привязаны к значениям данных или событиям, поэтому они пока пусты и не имеют поведения.

## Привязка элементов управления ввода к свойствам данных

Следующий шаг — привязать элементы управления ввода к соответствующим свойствам `Actor` с помощью двусторонней привязки
данных, чтобы они реагировали на ввод пользователя обновлением модели данных, а также реагировали на программные
изменения данных обновлением отображения.

Директива `ngModel`, объявленная в `FormsModule`, позволяет привязывать элементы управления в форме на основе шаблона к
свойствам в вашей модели данных.
Когда вы включаете директиву, используя синтаксис двусторонней привязки данных `[(ngModel)]`, Angular может отслеживать
значение и взаимодействие пользователя с элементом управления и поддерживать синхронизацию представления с моделью.

1. Отредактируйте файл шаблона `actor-form.component.html`.
1. Найдите тег `<input>` рядом с меткой **Name**.
1. Добавьте директиву `ngModel`, используя синтаксис двусторонней привязки данных `[(ngModel)]="..."`.

<docs-code header="actor-form.component.html (excerpt)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="ngModelName-1"/>

ПОЛЕЗНО: В этом примере есть временная диагностическая интерполяция после каждого тега input, `{{model.name}}`, чтобы
показать текущее значение данных соответствующего свойства. Комментарий напоминает удалить диагностические строки, когда
вы закончите наблюдать за работой двусторонней привязки данных.

### Доступ к общему статусу формы

Когда вы импортировали `FormsModule` в свой компонент, Angular автоматически создал и присоединил
директиву [NgForm](api/forms/NgForm) к тегу `<form>` в шаблоне (поскольку `NgForm` имеет селектор `form`, который
соответствует элементам `<form>`).

Чтобы получить доступ к `NgForm` и общему статусу формы,
объявите [переменную ссылки на шаблон](guide/templates/variables#template-reference-variables).

1. Отредактируйте файл шаблона `actor-form.component.html`.
1. Обновите тег `<form>` с переменной ссылки на шаблон `#actorForm` и установите ее значение следующим образом.

   <docs-code header="actor-form.component.html (excerpt)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="template-variable"/>

   Переменная шаблона `actorForm` теперь является ссылкой на экземпляр директивы `NgForm`, которая управляет формой в
   целом.

1. Запустите приложение.
1. Начните печатать в поле ввода **Name**.

   По мере добавления и удаления символов вы можете видеть, как они появляются и исчезают из модели данных.

Диагностическая строка, показывающая интерполированные значения, демонстрирует, что значения действительно передаются из
поля ввода в модель и обратно.

### Именование элементов управления

При использовании `[(ngModel)]` на элементе необходимо определить атрибут `name` для этого элемента.
Angular использует назначенное имя для регистрации элемента в директиве `NgForm`, присоединенной к родительскому
элементу `<form>`.

В примере добавлен атрибут `name` к элементу `<input>` и установлено значение «name», что логично для имени актера.
Подойдет любое уникальное значение, но использование описательного имени полезно.

1. Добавьте аналогичные привязки `[(ngModel)]` и атрибуты `name` к **Studio** и **Skill**.
1. Теперь вы можете удалить диагностические сообщения, показывающие интерполированные значения.
1. Чтобы подтвердить, что двусторонняя привязка данных работает для всей модели актера, добавьте новую текстовую
   привязку с pipe [`json`](api/common/JsonPipe) в верхней части шаблона компонента, которая сериализует данные в
   строку.

После этих изменений шаблон формы должен выглядеть следующим образом:

<docs-code header="actor-form.component.html (excerpt)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="ngModel-2"/>

Вы заметите, что:

- Каждый элемент `<input>` имеет свойство `id`.
  Оно используется атрибутом `for` элемента `<label>` для сопоставления метки с ее элементом управления.
  Это [стандартная функция HTML](https://developer.mozilla.org/docs/Web/HTML/Element/label).

- Каждый элемент `<input>` также имеет обязательное свойство `name`, которое Angular использует для регистрации элемента
  управления в форме.

После наблюдения за эффектами вы можете удалить текстовую привязку `{{ model | json }}`.

## Отслеживание состояний формы

Angular применяет класс `ng-submitted` к элементам `form` после отправки формы. Этот класс можно использовать для
изменения стиля формы после ее отправки.

## Отслеживание состояний элементов управления

Добавление директивы `NgModel` к элементу управления добавляет имена классов к этому элементу, описывающие его
состояние.
Эти классы можно использовать для изменения стиля элемента управления в зависимости от его состояния.

В следующей таблице описаны имена классов, которые Angular применяет в зависимости от состояния элемента управления.

| Состояния                                       | Класс, если true | Класс, если false |
| :---------------------------------------------- | :--------------- | :---------------- |
| Элемент управления был посещен.                 | `ng-touched`     | `ng-untouched`    |
| Значение элемента управления изменилось.        | `ng-dirty`       | `ng-pristine`     |
| Значение элемента управления является валидным. | `ng-valid`       | `ng-invalid`      |

Angular также применяет класс `ng-submitted` к элементам `form` при отправке,
но не к элементам управления внутри элемента `form`.

Вы используете эти CSS-классы для определения стилей вашего элемента управления на основе его статуса.

### Наблюдение за состояниями элементов управления

Чтобы увидеть, как классы добавляются и удаляются фреймворком, откройте инструменты разработчика браузера и проверьте
элемент `<input>`, представляющий имя актера.

1. Используя инструменты разработчика браузера, найдите элемент `<input>`, соответствующий полю ввода **Name**.
   Вы можете видеть, что элемент имеет несколько CSS-классов в дополнение к «form-control».

1. Когда вы впервые открываете его, классы указывают, что он имеет валидное значение, что значение не изменялось с
   момента инициализации или сброса, и что элемент управления не был посещен с момента инициализации или сброса.

   ```html

   <input class="form-control ng-untouched ng-pristine ng-valid">;
   ```

1. Выполните следующие действия с полем `<input>` **Name** и посмотрите, какие классы появляются.

- Посмотрите, но не трогайте.
  Классы указывают, что он нетронутый (untouched), первозданный (pristine) и валидный (valid).

- Кликните внутри поля имени, затем кликните снаружи.
  Теперь элемент управления был посещен, и у элемента есть класс `ng-touched` вместо `ng-untouched`.

- Добавьте косую черту в конец имени.
  Теперь он touched и dirty (измененный).

- Сотрите имя.
  Это делает значение невалидным, поэтому класс `ng-invalid` заменяет класс `ng-valid`.

### Создание визуальной обратной связи для состояний

Пара `ng-valid`/`ng-invalid` особенно интересна, так как вы хотите отправить
сильный визуальный сигнал, когда значения невалидны.
Вы также хотите отметить обязательные поля.

Вы можете отметить обязательные поля и невалидные данные одновременно цветной полосой
слева от поля ввода.

Чтобы изменить внешний вид таким образом, выполните следующие шаги.

1. Добавьте определения для CSS-классов `ng-*`.
1. Добавьте эти определения классов в новый файл `forms.css`.
1. Добавьте новый файл в проект как соседний с `index.html`:

   <docs-code header="forms.css" language="css" path="adev/src/content/examples/forms/src/assets/forms.css"/>

1. В файле `index.html` обновите тег `<head>`, чтобы включить новую таблицу стилей.

   <docs-code header="index.html (styles)" path="adev/src/content/examples/forms/src/index.html" visibleRegion="styles"/>

### Отображение и скрытие сообщений об ошибках валидации

Поле ввода **Name** является обязательным, и его очистка окрашивает полосу в красный цвет.
Это указывает на то, что что-то не так, но пользователь не знает, что именно и что с этим делать.
Вы можете предоставить полезное сообщение, проверяя и реагируя на состояние элемента управления.

Поле выбора **Skill** также является обязательным, но оно не нуждается в такой обработке ошибок, так как поле выбора уже
ограничивает выбор валидными значениями.

Чтобы определить и показать сообщение об ошибке, когда это уместно, выполните следующие шаги.

<docs-workflow>
<docs-step title="Добавьте локальную ссылку на input">
Расширьте тег `input` переменной ссылки на шаблон, которую можно использовать для доступа к элементу управления Angular поля ввода из шаблона. В примере переменная — `#name="ngModel"`.

Переменная ссылки на шаблон (`#name`) установлена в `"ngModel"`, так как это значение свойства [
`NgModel.exportAs`](api/core/Directive#exportAs). Это свойство сообщает Angular, как связать переменную ссылки с
директивой.
</docs-step>

<docs-step title="Добавьте сообщение об ошибке">
Добавьте `<div>`, содержащий подходящее сообщение об ошибке.
</docs-step>

<docs-step title="Сделайте сообщение об ошибке условным">
Показывайте или скрывайте сообщение об ошибке, привязывая свойства элемента управления `name` к свойству `hidden` элемента `<div>` сообщения.
</docs-step>

<docs-code header="actor-form.component.html (hidden-error-msg)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="hidden-error-msg"/>

<docs-step title="Добавьте условное сообщение об ошибке к имени">
Добавьте условное сообщение об ошибке к полю ввода `name`, как в следующем примере.

<docs-code header="actor-form.component.html (excerpt)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="name-with-error-msg"/>
</docs-step>
</docs-workflow>

<docs-callout title='Иллюстрация состояния "pristine"'>

В этом примере вы скрываете сообщение, когда элемент управления либо валиден, либо находится в состоянии _pristine_ (
нетронутый).
Pristine означает, что пользователь не изменял значение с момента его отображения в этой форме.
Если вы проигнорируете состояние `pristine`, вы будете скрывать сообщение только тогда, когда значение валидно.
Если вы зайдете в этот компонент с новым пустым актером или невалидным актером, вы увидите сообщение об ошибке сразу же,
еще до того, как что-либо сделаете.

Возможно, вы захотите, чтобы сообщение отображалось только тогда, когда пользователь вносит невалидное изменение.
Скрытие сообщения, пока элемент управления находится в состоянии `pristine`, достигает этой цели.
Вы увидите важность этого выбора, когда добавите нового актера в форму на следующем шаге.

</docs-callout>

## Добавление нового актера

Это упражнение показывает, как можно реагировать на нативное событие клика HTML-кнопки, добавляя данные в модель.
Чтобы позволить пользователям формы добавлять нового актера, вы добавите кнопку **New Actor**, которая реагирует на
событие клика.

1. В шаблоне поместите элемент `<button>` «New Actor» внизу формы.
1. В файле компонента добавьте метод создания актера в модель данных актера.

   <docs-code header="actor-form.component.ts (New Actor method)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts" visibleRegion="new-actor"/>

1. Привяжите событие клика кнопки к методу создания актера `newActor()`.

   <docs-code header="actor-form.component.html (New Actor button)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="new-actor-button-no-reset"/>

1. Запустите приложение снова и нажмите кнопку **New Actor**.

   Форма очищается, и полосы _required_ слева от полей ввода становятся красными, указывая на невалидные свойства `name`
   и `skill`.
   Обратите внимание, что сообщения об ошибках скрыты.
   Это потому, что форма находится в состоянии pristine; вы еще ничего не изменили.

1. Введите имя и снова нажмите **New Actor**.

   Теперь приложение отображает сообщение об ошибке `Name is required`, так как поле ввода больше не является pristine.
   Форма помнит, что вы ввели имя перед нажатием **New Actor**.

1. Чтобы восстановить состояние pristine элементов управления формы, очистите все флаги императивно, вызвав метод формы
   `reset()` после вызова метода `newActor()`.

   <docs-code header="actor-form.component.html (Reset the form)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="new-actor-button-form-reset"/>

   Теперь нажатие **New Actor** сбрасывает как форму, так и флаги ее элементов управления.

## Отправка формы с помощью `ngSubmit`

Пользователь должен иметь возможность отправить эту форму после ее заполнения.
Кнопка **Submit** внизу формы сама по себе ничего не делает, но она запускает событие отправки формы из-за своего типа (
`type="submit"`).

Чтобы отреагировать на это событие, выполните следующие шаги.

<docs-workflow>

<docs-step title="Прослушивание ngOnSubmit">
Привяжите свойство события [`ngSubmit`](api/forms/NgForm#properties) формы к методу `onSubmit()` компонента actor-form.

<docs-code header="actor-form.component.html (ngSubmit)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="ngSubmit"/>
</docs-step>

<docs-step title="Привязка свойства disabled">
Используйте переменную ссылки на шаблон `#actorForm`, чтобы получить доступ к форме, содержащей кнопку **Submit**, и создать привязку события.

Вы привяжете свойство формы, указывающее на ее общую валидность, к свойству `disabled` кнопки **Submit**.

<docs-code header="actor-form.component.html (submit-button)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="submit-button"/>
</docs-step>

<docs-step title="Запуск приложения">
Обратите внимание, что кнопка активна — хотя она пока не делает ничего полезного.
</docs-step>

<docs-step title="Удалите значение Name">
Это нарушает правило «required», поэтому отображается сообщение об ошибке — и обратите внимание, что это также отключает кнопку **Submit**.

Вам не нужно было явно связывать состояние активности кнопки с валидностью формы.
`FormsModule` сделал это автоматически, когда вы определили переменную ссылки на шаблон на расширенном элементе формы, а
затем сослались на эту переменную в элементе управления кнопки.
</docs-step>
</docs-workflow>

### Реагирование на отправку формы

Чтобы показать реакцию на отправку формы, вы можете скрыть область ввода данных и отобразить что-то другое на ее месте.

<docs-workflow>
<docs-step title="Оберните форму">
Оберните всю форму в `<div>` и привяжите его свойство `hidden` к свойству `ActorFormComponent.submitted`.

<docs-code header="actor-form.component.html (excerpt)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="edit-div"/>

Основная форма видна с самого начала, так как свойство `submitted` ложно до тех пор, пока вы не отправите форму, как
показывает этот фрагмент из `ActorFormComponent`:

<docs-code header="actor-form.component.ts (submitted)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts" visibleRegion="submitted"/>

Когда вы нажимаете кнопку **Submit**, флаг `submitted` становится истинным, и форма исчезает.
</docs-step>

<docs-step title="Добавьте состояние отправки">
Чтобы показать что-то другое, пока форма находится в состоянии отправки, добавьте следующий HTML под новой оберткой `<div>`.

<docs-code header="actor-form.component.html (excerpt)" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="submitted"/>

Этот `<div>`, показывающий актера только для чтения с привязками интерполяции, появляется только тогда, когда компонент
находится в состоянии отправки.

Альтернативное отображение включает кнопку _Edit_, событие клика которой привязано к выражению, очищающему флаг
`submitted`.
</docs-step>

<docs-step title="Протестируйте кнопку Edit">
Нажмите кнопку *Edit*, чтобы переключить отображение обратно на редактируемую форму.
</docs-step>
</docs-workflow>

## Резюме

Форма Angular, рассмотренная на этой странице, использует следующие возможности фреймворка для обеспечения поддержки
модификации данных, валидации и многого другого.

- HTML-шаблон формы Angular
- Класс компонента формы с декоратором `@Component`
- Обработка отправки формы путем привязки к свойству события `NgForm.ngSubmit`
- Переменные ссылки на шаблон, такие как `#actorForm` и `#name`
- Синтаксис `[(ngModel)]` для двусторонней привязки данных
- Использование атрибутов `name` для валидации и отслеживания изменений элементов формы
- Свойство `valid` переменной ссылки на элементах управления вводом указывает, является ли элемент управления валидным
  или должен показывать сообщения об ошибках
- Управление состоянием активности кнопки **Submit** путем привязки к валидности `NgForm`
- Пользовательские CSS-классы, обеспечивающие визуальную обратную связь пользователям о невалидных элементах управления

Вот код финальной версии приложения:

<docs-code-multifile>
    <docs-code header="actor-form.component.ts" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts" visibleRegion="final"/>
    <docs-code header="actor-form.component.html" path="adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html" visibleRegion="final"/>
    <docs-code header="actor.ts" path="adev/src/content/examples/forms/src/app/actor.ts"/>
    <docs-code header="app.component.html" path="adev/src/content/examples/forms/src/app/app.component.html"/>
    <docs-code header="app.component.ts" path="adev/src/content/examples/forms/src/app/app.component.ts"/>
    <docs-code header="main.ts" path="adev/src/content/examples/forms/src/main.ts"/>
    <docs-code header="forms.css" path="adev/src/content/examples/forms/src/assets/forms.css"/>
</docs-code-multifile>
