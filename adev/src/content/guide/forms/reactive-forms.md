# Реактивные формы

Реактивные формы (Reactive forms) предоставляют подход к обработке ввода форм, основанный на моделях (model-driven),
значения которых изменяются со временем.
В этом руководстве показано, как создать и обновить простой элемент управления формы (form control), затем перейти к
использованию нескольких элементов управления в группе, валидации значений формы и созданию динамических форм, где вы
можете добавлять или удалять элементы управления во время выполнения.

## Обзор реактивных форм

Реактивные формы используют явный и неизменяемый подход к управлению состоянием формы в определенный момент времени.
Каждое изменение состояния формы возвращает новое состояние, что поддерживает целостность модели между изменениями.
Реактивные формы построены на основе Observable-потоков, где входные данные формы и значения предоставляются в виде
потоков входных значений, к которым можно получить синхронный доступ.

Реактивные формы также обеспечивают простой путь к тестированию, поскольку вы уверены, что ваши данные согласованы и
предсказуемы при запросе.
Любые потребители потоков имеют доступ к безопасному манипулированию этими данными.

Реактивные формы отличаются от [template-driven форм](guide/forms/template-driven-forms) определенными особенностями.
Реактивные формы предоставляют синхронный доступ к модели данных, неизменяемость с помощью операторов Observable и
отслеживание изменений через Observable-потоки.

Template-driven формы позволяют изменять данные прямо в шаблоне, но они менее явные, чем реактивные формы, поскольку
полагаются на директивы, встроенные в шаблон, и на изменяемые данные для асинхронного отслеживания изменений.
Смотрите [Обзор форм](guide/forms) для детального сравнения этих двух парадигм.

## Добавление простого элемента управления формы

Использование элементов управления формы (form controls) состоит из трех шагов.

1. Создайте новый компонент и зарегистрируйте модуль реактивных форм. Этот модуль объявляет директивы реактивных форм,
   необходимые для их использования.
2. Создайте экземпляр нового `FormControl`.
3. Зарегистрируйте `FormControl` в шаблоне.

Затем вы можете отобразить форму, добавив компонент в шаблон.

Следующие примеры показывают, как добавить одиночный элемент управления формы.
В примере пользователь вводит свое имя в поле ввода, приложение захватывает это значение и отображает текущее значение
элемента управления формы.

<docs-workflow>

<docs-step title="Создайте новый компонент и импортируйте ReactiveFormsModule">
Используйте команду CLI `ng generate component`, чтобы создать компонент в вашем проекте, импортируйте `ReactiveFormsModule` из пакета `@angular/forms` и добавьте его в массив `imports` вашего компонента.

<docs-code header="name-editor.component.ts (excerpt)" path="adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.ts" visibleRegion="imports" />
</docs-step>

<docs-step title="Объявите экземпляр FormControl">
Используйте конструктор `FormControl`, чтобы установить его начальное значение, которое в данном случае является пустой строкой. Создавая эти элементы управления в классе компонента, вы получаете немедленный доступ к прослушиванию, обновлению и валидации состояния ввода формы.

<docs-code header="name-editor.component.ts" path="adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.ts" visibleRegion="create-control"/>
</docs-step>

<docs-step title="Зарегистрируйте элемент управления в шаблоне">
После создания элемента управления в классе компонента, вы должны связать его с элементом управления формы в шаблоне. Обновите шаблон, используя привязку `formControl`, предоставляемую директивой `FormControlDirective`, которая также включена в `ReactiveFormsModule`.

<docs-code header="name-editor.component.html" path="adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.html" visibleRegion="control-binding" />

Используя синтаксис привязки шаблона, элемент управления формы теперь зарегистрирован на элементе ввода `name` в
шаблоне. Элемент управления формы и DOM-элемент взаимодействуют друг с другом: представление отражает изменения в
модели, а модель отражает изменения в представлении.
</docs-step>

<docs-step title="Отобразите компонент">
`FormControl`, назначенный свойству `name`, отображается, когда компонент `<app-name-editor>` добавляется в шаблон.

<docs-code header="app.component.html (name editor)" path="adev/src/content/examples/reactive-forms/src/app/app.component.1.html" visibleRegion="app-name-editor"/>
</docs-step>
</docs-workflow>

### Отображение значения элемента управления формы

Вы можете отобразить значение следующими способами:

- Через Observable `valueChanges`, где вы можете прослушивать изменения значения формы в шаблоне с помощью `AsyncPipe`
  или в классе компонента с помощью метода `subscribe()`.
- С помощью свойства `value`, которое дает вам снимок (snapshot) текущего значения.

Следующий пример показывает, как отобразить текущее значение с помощью интерполяции в шаблоне.

<docs-code header="name-editor.component.html (control value)" path="adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.html" visibleRegion="display-value"/>

Отображаемое значение изменяется по мере того, как вы обновляете элемент управления формы.

Реактивные формы предоставляют доступ к информации о данном элементе управления через свойства и методы, доступные в
каждом экземпляре.
Эти свойства и методы базового класса [AbstractControl](api/forms/AbstractControl 'API reference') используются для
управления состоянием формы и определения момента отображения сообщений при
обработке [валидации ввода](#validating-form-input 'Узнайте больше о валидации ввода формы').

Узнайте о других свойствах и методах `FormControl`
в [Справочнике API](api/forms/FormControl 'Подробный справочник синтаксиса').

### Замена значения элемента управления формы

У реактивных форм есть методы для программного изменения значения элемента управления, что дает вам гибкость обновлять
значение без взаимодействия с пользователем.
Экземпляр элемента управления формы предоставляет метод `setValue()`, который обновляет значение элемента управления и
проверяет структуру предоставленного значения на соответствие структуре элемента управления.
Например, при получении данных формы из бэкенд-API или сервиса, используйте метод `setValue()`, чтобы обновить элемент
управления новым значением, полностью заменяя старое.

Следующий пример добавляет метод в класс компонента для обновления значения элемента управления на _Nancy_ с
использованием метода `setValue()`.

<docs-code header="name-editor.component.ts (update value)" path="adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.ts" visibleRegion="update-value"/>

Обновите шаблон, добавив кнопку для имитации обновления имени.
Когда вы нажимаете кнопку **Update Name**, значение, введенное в элемент управления формы, отражается как его текущее
значение.

<docs-code header="name-editor.component.html (update value)" path="adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.html" visibleRegion="update-value"/>

Модель формы является источником истины для элемента управления, поэтому при нажатии кнопки значение ввода изменяется
внутри класса компонента, переопределяя его текущее значение.

ПОЛЕЗНО: В этом примере вы используете одиночный элемент управления.
При использовании метода `setValue()` с экземпляром [группы форм](#grouping-form-controls)
или [массива форм](#creating-dynamic-forms), значение должно соответствовать структуре группы или массива.

## Группировка элементов управления формы {#grouping-form-controls}

Формы обычно содержат несколько связанных элементов управления.
Реактивные формы предоставляют два способа группировки нескольких связанных элементов управления в единую форму ввода.

| Группы форм | Детали                                                                                                                                                                                                                                                                                         |
| :---------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Form group  | Определяет форму с фиксированным набором элементов управления, которыми вы можете управлять вместе. Основы групп форм обсуждаются в этом разделе. Вы также можете [вкладывать группы форм](#creating-nested-form-groups 'Узнайте больше о вложенных группах') для создания более сложных форм. |
| Form array  | Определяет динамическую форму, где вы можете добавлять и удалять элементы управления во время выполнения. Вы также можете вкладывать массивы форм для создания более сложных форм. Подробнее об этой опции см. в разделе [Создание динамических форм](#creating-dynamic-forms).                |

Точно так же, как экземпляр элемента управления формы дает вам контроль над одним полем ввода, экземпляр группы форм
отслеживает состояние формы для группы экземпляров элементов управления (например, формы).
Каждый элемент управления в экземпляре группы форм отслеживается по имени при создании группы.
Следующий пример показывает, как управлять несколькими экземплярами элементов управления формы в одной группе.

Создайте компонент `ProfileEditor` и импортируйте классы `FormGroup` и `FormControl` из пакета `@angular/forms`.

```shell
ng generate component ProfileEditor
```

<docs-code header="profile-editor.component.ts (imports)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.ts" visibleRegion="imports"/>

Чтобы добавить группу форм в этот компонент, выполните следующие шаги.

1. Создайте экземпляр `FormGroup`.
2. Свяжите модель `FormGroup` и представление.
3. Сохраните данные формы.

<docs-workflow>

<docs-step title="Создайте экземпляр FormGroup">
Создайте свойство в классе компонента с именем `profileForm` и присвойте ему новый экземпляр группы форм. Чтобы инициализировать группу форм, передайте в конструктор объект с именованными ключами, сопоставленными с их элементами управления.

Для формы профиля добавьте два экземпляра элементов управления с именами `firstName` и `lastName`.

<docs-code header="profile-editor.component.ts (form group)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.ts" visibleRegion="formgroup"/>

Отдельные элементы управления формой теперь собраны в группу. Экземпляр `FormGroup` предоставляет значение своей модели
как объект, сформированный из значений каждого элемента управления в группе. Экземпляр группы форм имеет те же
свойства (например, `value` и `untouched`) и методы (например, `setValue()`), что и экземпляр элемента управления формы.
</docs-step>

<docs-step title="Свяжите модель FormGroup и представление">
Группа форм отслеживает статус и изменения для каждого из своих элементов управления, поэтому, если один из элементов управления изменяется, родительский элемент управления также генерирует новый статус или изменение значения. Модель для группы поддерживается ее членами. После определения модели вы должны обновить шаблон, чтобы отразить модель в представлении.

<docs-code header="profile-editor.component.html (template form group)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.html" visibleRegion="formgroup"/>

Так же, как группа форм содержит группу элементов управления, `FormGroup` _profileForm_ привязывается к элементу `form`
с помощью директивы `FormGroup`, создавая слой коммуникации между моделью и формой, содержащей поля ввода. Входное
свойство `formControlName`, предоставляемое директивой `FormControlName`, связывает каждое отдельное поле ввода с
элементом управления формы, определенным в `FormGroup`. Элементы управления формы взаимодействуют со своими
соответствующими элементами. Они также сообщают об изменениях экземпляру группы форм, который является источником истины
для значения модели.
</docs-step>

<docs-step title="Сохраните данные формы">
Компонент `ProfileEditor` принимает ввод от пользователя, но в реальном сценарии вы хотите захватить значение формы и сделать его доступным для дальнейшей обработки вне компонента. Директива `FormGroup` прослушивает событие `submit`, генерируемое элементом `form`, и генерирует событие `ngSubmit`, которое вы можете связать с функцией обратного вызова. Добавьте слушатель события `ngSubmit` к тегу `form` с методом обратного вызова `onSubmit()`.

<docs-code header="profile-editor.component.html (submit event)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.html" visibleRegion="ng-submit"/>

Метод `onSubmit()` в компоненте `ProfileEditor` захватывает текущее значение `profileForm`. Используйте `EventEmitter`,
чтобы сохранить форму инкапсулированной и предоставить значение формы вне компонента. Следующий пример использует
`console.warn` для вывода сообщения в консоль браузера.

<docs-code header="profile-editor.component.ts (submit method)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts" visibleRegion="on-submit"/>

Событие `submit` генерируется тегом `form` с использованием встроенного DOM-события. Вы запускаете событие, нажимая
кнопку с типом `submit`. Это позволяет пользователю нажать клавишу **Enter**, чтобы отправить заполненную форму.

Используйте элемент `button`, чтобы добавить кнопку внизу формы для запуска отправки формы.

<docs-code header="profile-editor.component.html (submit button)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.html" visibleRegion="submit-button"/>

Кнопка в предыдущем фрагменте также имеет привязку `disabled`, чтобы отключать кнопку, когда `profileForm` невалидна. Вы
еще не выполняете никакой валидации, поэтому кнопка всегда активна. Базовая валидация формы рассматривается в
разделе [Валидация ввода формы](#validating-form-input).
</docs-step>

<docs-step title="Отобразите компонент">
Чтобы отобразить компонент `ProfileEditor`, содержащий форму, добавьте его в шаблон компонента.

<docs-code header="app.component.html (profile editor)" path="adev/src/content/examples/reactive-forms/src/app/app.component.1.html" visibleRegion="app-profile-editor"/>

`ProfileEditor` позволяет вам управлять экземплярами элементов управления формы для `firstName` и `lastName` внутри
экземпляра группы форм.

### Создание вложенных групп форм {#creating-nested-form-groups}

Группы форм могут принимать как отдельные экземпляры элементов управления формы, так и другие экземпляры групп форм в
качестве дочерних элементов.
Это упрощает поддержку и логическую группировку сложных моделей форм.

При создании сложных форм управление различными областями информации проще осуществлять небольшими секциями.
Использование вложенного экземпляра группы форм позволяет разбивать большие группы форм на более мелкие и управляемые.

Чтобы создать более сложные формы, выполните следующие шаги.

1. Создайте вложенную группу.
2. Сгруппируйте вложенную форму в шаблоне.

Некоторые типы информации естественным образом попадают в одну группу.
Имя и адрес являются типичными примерами таких вложенных групп и используются в следующих примерах.

<docs-workflow>
<docs-step title="Создайте вложенную группу">
Чтобы создать вложенную группу в `profileForm`, добавьте вложенный элемент `address` в экземпляр группы форм.

<docs-code header="profile-editor.component.ts (nested form group)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.ts" visibleRegion="nested-formgroup"/>

В этом примере группа `address` объединяет текущие элементы управления `firstName` и `lastName` с новыми элементами
управления `street`, `city`, `state` и `zip`. Несмотря на то, что элемент `address` в группе форм является дочерним по
отношению к общему элементу `profileForm`, применяются те же правила изменения значения и статуса. Изменения статуса и
значения из вложенной группы форм распространяются на родительскую группу форм, поддерживая согласованность с общей
моделью.
</docs-step>

<docs-step title="Сгруппируйте вложенную форму в шаблоне">
После обновления модели в классе компонента обновите шаблон, чтобы соединить экземпляр группы форм и его элементы ввода. Добавьте группу форм `address`, содержащую поля `street`, `city`, `state` и `zip`, в шаблон `ProfileEditor`.

<docs-code header="profile-editor.component.html (template nested form group)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.html" visibleRegion="formgroupname"/>

Форма `ProfileEditor` отображается как одна группа, но модель разбита дальше, чтобы представить логические области
группировки.

Отобразите значение для экземпляра группы форм в шаблоне компонента, используя свойство `value` и `JsonPipe`.
</docs-step>
</docs-workflow>

### Обновление частей модели данных

При обновлении значения для экземпляра группы форм, содержащего несколько элементов управления, вы можете захотеть
обновить только части модели.
Этот раздел описывает, как обновлять конкретные части модели данных элемента управления формы.

Существует два способа обновления значения модели:

| Методы         | Детали                                                                                                                                                                               |
| :------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `setValue()`   | Устанавливает новое значение для отдельного элемента управления. Метод `setValue()` строго придерживается структуры группы форм и заменяет все значение элемента управления целиком. |
| `patchValue()` | Заменяет любые свойства, определенные в объекте, которые изменились в модели формы.                                                                                                  |

Строгие проверки метода `setValue()` помогают отлавливать ошибки вложенности в сложных формах, в то время как
`patchValue()` молчаливо игнорирует эти ошибки.

В `ProfileEditorComponent` используйте метод `updateProfile` со следующим примером, чтобы обновить имя и адрес улицы для
пользователя.

<docs-code header="profile-editor.component.ts (patch value)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.ts" visibleRegion="patch-value"/>

Имитируйте обновление, добавив кнопку в шаблон для обновления профиля пользователя по требованию.

<docs-code header="profile-editor.component.html (update value)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.html" visibleRegion="patch-value"/>

Когда пользователь нажимает кнопку, модель `profileForm` обновляется новыми значениями для `firstName` и `street`.
Обратите внимание, что `street` предоставляется в объекте внутри свойства `address`.
Это необходимо, потому что метод `patchValue()` применяет обновление к структуре модели.
`PatchValue()` обновляет только те свойства, которые определяет модель формы.

## Использование сервиса FormBuilder для генерации элементов управления

Создание экземпляров элементов управления формы вручную может стать повторяющимся процессом при работе с несколькими
формами.
Сервис `FormBuilder` предоставляет удобные методы для генерации элементов управления.

Выполните следующие шаги, чтобы воспользоваться этим сервисом.

1. Импортируйте класс `FormBuilder`.
2. Внедрите сервис `FormBuilder`.
3. Сгенерируйте содержимое формы.

Следующие примеры показывают, как рефакторить компонент `ProfileEditor` для использования сервиса FormBuilder при
создании экземпляров элементов управления и групп форм.

<docs-workflow>
<docs-step title="Импортируйте класс FormBuilder">
Импортируйте класс `FormBuilder` из пакета `@angular/forms`.

<docs-code header="profile-editor.component.ts (import)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.2.ts" visibleRegion="form-builder-imports"/>

</docs-step>

<docs-step title="Внедрите сервис FormBuilder">
Сервис `FormBuilder` является внедряемым провайдером из модуля реактивных форм. Используйте функцию `inject()`, чтобы внедрить эту зависимость в ваш компонент.

<docs-code header="profile-editor.component.ts (property init)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.2.ts" visibleRegion="inject-form-builder"/>

</docs-step>
<docs-step title="Сгенерируйте элементы управления формы">
У сервиса `FormBuilder` есть три метода: `control()`, `group()` и `array()`. Это фабричные методы для генерации экземпляров в классах ваших компонентов, включая элементы управления формы, группы форм и массивы форм. Используйте метод `group`, чтобы создать элементы управления `profileForm`.

<docs-code header="profile-editor.component.ts (form builder)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.2.ts" visibleRegion="form-builder"/>

В предыдущем примере вы используете метод `group()` с тем же объектом для определения свойств в модели. Значение для
каждого имени элемента управления — это массив, содержащий начальное значение в качестве первого элемента.

СОВЕТ: Вы можете определить элемент управления только с начальным значением, но если вашим элементам управления нужна
синхронная или асинхронная валидация, добавьте синхронные и асинхронные валидаторы в качестве второго и третьего
элементов массива. Сравните использование FormBuilder с созданием экземпляров вручную.

  <docs-code-multifile>
    <docs-code header="profile-editor.component.ts (instances)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.ts" visibleRegion="formgroup-compare"/>
    <docs-code header="profile-editor.component.ts (form builder)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.2.ts" visibleRegion="formgroup-compare"/>
  </docs-code-multifile>
</docs-step>

</docs-workflow>

## Валидация ввода формы {#validating-form-input}

_Валидация формы_ используется для обеспечения полноты и корректности ввода пользователя.
Этот раздел описывает добавление одного валидатора к элементу управления формы и отображение общего статуса формы.
Валидация формы более подробно рассматривается в руководстве [Валидация формы](guide/forms/form-validation).

Выполните следующие шаги для добавления валидации формы.

1. Импортируйте функцию-валидатор в ваш компонент формы.
2. Добавьте валидатор к полю в форме.
3. Добавьте логику для обработки статуса валидации.

Наиболее распространенная валидация — сделать поле обязательным.
Следующий пример показывает, как добавить валидацию обязательного поля к элементу управления `firstName` и отобразить
результат валидации.

<docs-workflow>
<docs-step title="Импортируйте функцию-валидатор">
Реактивные формы включают набор функций-валидаторов для распространенных случаев использования. Эти функции получают элемент управления для проверки и возвращают объект ошибки или значение null в зависимости от проверки валидации.

Импортируйте класс `Validators` из пакета `@angular/forms`.

<docs-code header="profile-editor.component.ts (import)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts" visibleRegion="validator-imports"/>
</docs-step>

<docs-step title="Сделайте поле обязательным">
В компоненте `ProfileEditor` добавьте статический метод `Validators.required` в качестве второго элемента в массиве для элемента управления `firstName`.

<docs-code header="profile-editor.component.ts (required validator)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts" visibleRegion="required-validator"/>
</docs-step>

<docs-step title="Отобразите статус формы">
Когда вы добавляете обязательное поле к элементу управления формы, его начальный статус — invalid (невалидный). Этот статус invalid распространяется на родительский элемент группы форм, делая его статус также invalid. Получите доступ к текущему статусу экземпляра группы форм через его свойство `status`.

Отобразите текущий статус `profileForm`, используя интерполяцию.

<docs-code header="profile-editor.component.html (display status)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.html" visibleRegion="display-status"/>

Кнопка **Submit** отключена, потому что `profileForm` невалидна из-за обязательного элемента управления `firstName`.
После того как вы заполните поле `firstName`, форма станет валидной, и кнопка **Submit** станет активной.

Подробнее о валидации форм читайте в руководстве [Валидация формы](guide/forms/form-validation).
</docs-step>
</docs-workflow>

## Создание динамических форм {#creating-dynamic-forms}

`FormArray` — это альтернатива `FormGroup` для управления любым количеством безымянных элементов управления.
Как и в случае с экземплярами групп форм, вы можете динамически вставлять и удалять элементы управления из экземпляров
массивов форм, а значение и статус валидации экземпляра массива форм вычисляются на основе его дочерних элементов
управления.
Однако вам не нужно определять ключ для каждого элемента управления по имени, поэтому это отличный вариант, если вы
заранее не знаете количество дочерних значений.

Чтобы определить динамическую форму, выполните следующие шаги.

1. Импортируйте класс `FormArray`.
2. Определите элемент управления `FormArray`.
3. Получите доступ к элементу управления `FormArray` с помощью метода-геттера.
4. Отобразите массив форм в шаблоне.

Следующий пример показывает, как управлять массивом _псевдонимов (aliases)_ в `ProfileEditor`.

<docs-workflow>
<docs-step title="Импортируйте класс `FormArray`">
Импортируйте класс `FormArray` из `@angular/forms` для использования информации о типе. Сервис `FormBuilder` готов к созданию экземпляра `FormArray`.

<docs-code header="profile-editor.component.ts (import)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.2.ts" visibleRegion="form-array-imports"/>
</docs-step>

<docs-step title="Определите элемент управления `FormArray`">
Вы можете инициализировать массив форм с любым количеством элементов управления, от нуля до множества, определив их в массиве. Добавьте свойство `aliases` в экземпляр группы форм для `profileForm`, чтобы определить массив форм.

Используйте метод `FormBuilder.array()` для определения массива и метод `FormBuilder.control()` для заполнения массива
начальным элементом управления.

<docs-code header="profile-editor.component.ts (aliases form array)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts" visibleRegion="aliases"/>

Элемент управления aliases в экземпляре группы форм теперь заполнен одним элементом управления, пока динамически не
будут добавлены другие.
</docs-step>

<docs-step title="Получите доступ к элементу управления `FormArray`">
Геттер обеспечивает доступ к псевдонимам в экземпляре массива форм по сравнению с повторением метода `profileForm.get()` для получения каждого экземпляра. Экземпляр массива форм представляет неопределенное количество элементов управления в массиве. Удобно получать доступ к элементу управления через геттер, и этот подход легко повторить для дополнительных элементов управления. <br />

Используйте синтаксис геттера для создания свойства класса `aliases`, чтобы получить элемент управления массива форм
aliases из родительской группы форм.

<docs-code header="profile-editor.component.ts (aliases getter)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts" visibleRegion="aliases-getter"/>

Поскольку возвращаемый элемент управления имеет тип `AbstractControl`, вам нужно предоставить явный тип для доступа к
синтаксису методов экземпляра массива форм. Определите метод для динамической вставки элемента управления alias в массив
форм aliases. Метод `FormArray.push()` вставляет элемент управления как новый элемент в массив; вы также можете передать
массив элементов управления в FormArray.push(), чтобы зарегистрировать несколько элементов управления сразу.

<docs-code header="profile-editor.component.ts (add alias)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts" visibleRegion="add-alias"/>

В шаблоне каждый элемент управления отображается как отдельное поле ввода.

</docs-step>

<docs-step title="Отобразите массив форм в шаблоне">

Чтобы прикрепить псевдонимы из вашей модели формы, вы должны добавить их в шаблон. Подобно входному свойству
`formGroupName`, предоставляемому `FormGroupNameDirective`, `formArrayName` связывает коммуникацию от экземпляра массива
форм к шаблону с помощью `FormArrayNameDirective`.

Добавьте следующий HTML шаблона после закрывающего тега `<div>` элемента `formGroupName`.

<docs-code header="profile-editor.component.html (aliases form array template)" path="adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.html" visibleRegion="formarrayname"/>

Блок `@for` перебирает каждый экземпляр элемента управления формы, предоставляемый экземпляром массива форм aliases.
Поскольку элементы массива форм безымянны, вы присваиваете индекс переменной `i` и передаете его каждому элементу
управления для привязки к входному свойству `formControlName`.

Каждый раз, когда добавляется новый экземпляр alias, новому экземпляру массива форм предоставляется его элемент
управления на основе индекса. Это позволяет отслеживать каждый отдельный элемент управления при вычислении статуса и
значения корневого элемента управления.

</docs-step>

<docs-step title="Добавьте псевдоним">

Изначально форма содержит одно поле `Alias`. Чтобы добавить еще одно поле, нажмите кнопку **Add Alias**. Вы также можете
проверить массив псевдонимов, сообщаемый моделью формы, отображаемый в `Form Value` внизу шаблона. Вместо экземпляра
элемента управления формы для каждого псевдонима вы можете составить еще один экземпляр группы форм с дополнительными
полями. Процесс определения элемента управления для каждого элемента такой же.
</docs-step>

</docs-workflow>

## Унифицированные события изменения состояния элемента управления

Все элементы управления формы предоставляют единый унифицированный поток **событий изменения состояния элемента
управления** через Observable `events` в `AbstractControl` (`FormControl`, `FormGroup`, `FormArray` и `FormRecord`).
Этот унифицированный поток позволяет реагировать на изменения состояний **value** (значение), **status** (статус), \*
\*pristine**, **touched** и **reset**, а также на **действия уровня формы**, такие как **submit\*\* (отправка), позволяя
обрабатывать все обновления с помощью одной подписки вместо связывания нескольких Observable.

### Типы событий

Каждый элемент, генерируемый `events`, является экземпляром определенного класса события:

- **`ValueChangeEvent`** — когда изменяется **значение** элемента управления.
- **`StatusChangeEvent`** — когда **статус валидации** элемента управления обновляется до одного из значений
  `FormControlStatus` (`VALID`, `INVALID`, `PENDING` или `DISABLED`).
- **`PristineChangeEvent`** — когда изменяется состояние **pristine/dirty** элемента управления.
- **`TouchedChangeEvent`** — когда изменяется состояние **touched/untouched** элемента управления.
- **`FormResetEvent`** — когда элемент управления или форма сбрасываются, либо через API `reset()`, либо через нативное
  действие.
- **`FormSubmittedEvent`** — когда форма отправляется.

Все классы событий расширяют `ControlEvent` и включают ссылку `source` на `AbstractControl`, который инициировал
изменение, что полезно в больших формах.

```ts
import { Component } from '@angular/core';
import {
  FormControl,
  ValueChangeEvent,
  StatusChangeEvent,
  PristineChangeEvent,
  TouchedChangeEvent,
  FormResetEvent,
  FormSubmittedEvent,
  ReactiveFormsModule,
  FormGroup,
} from '@angular/forms';

@Component({/* ... */ })
export class UnifiedEventsBasicComponent {
  form = new FormGroup({
    username: new FormControl(''),
  });

  constructor() {
    this.form.events.subscribe((e) => {
      if (e instanceof ValueChangeEvent) {
        console.log('Value changed to: ', e.value);
      }

      if (e instanceof StatusChangeEvent) {
        console.log('Status changed to: ', e.status);
      }

      if (e instanceof PristineChangeEvent) {
        console.log('Pristine status changed to: ', e.pristine);
      }

      if (e instanceof TouchedChangeEvent) {
        console.log('Touched status changed to: ', e.touched);
      }

      if (e instanceof FormResetEvent) {
        console.log('Form was reset');
      }

      if (e instanceof FormSubmittedEvent) {
        console.log('Form was submitted');
      }
    });
  }
}
```

### Фильтрация конкретных событий

Предпочитайте операторы RxJS, когда вам нужно только подмножество типов событий.

```ts
import { filter } from 'rxjs/operators';
import { StatusChangeEvent } from '@angular/forms';

control.events
  .pipe(filter((e) => e instanceof StatusChangeEvent))
  .subscribe((e) => console.log('Status:', e.status));
```

### Объединение нескольких подписок

**До**

```ts
import { combineLatest } from 'rxjs/operators';

combineLatest([control.valueChanges, control.statusChanges])
  .subscribe(([value, status]) => { /* ... */ });
```

**После**

```ts
control.events.subscribe((e) => {
  // Handle ValueChangeEvent, StatusChangeEvent, etc.
});
```

ПРИМЕЧАНИЕ: При изменении значения событие генерируется сразу после обновления значения этого элемента управления.
Значение родительского элемента управления (например, если этот FormControl является частью FormGroup) обновляется
позже, поэтому доступ к значению родительского элемента управления (используя свойство `value`) из колбэка этого события
может привести к получению значения, которое еще не было обновлено. Подписывайтесь на `events` родительского элемента
управления вместо этого.

## Утилитарные функции для сужения типов элементов управления формы

Angular предоставляет четыре утилитарные функции, которые помогают определить конкретный тип `AbstractControl`. Эти
функции действуют как **защитники типа (type guards)** и сужают тип элемента управления, когда возвращают `true`, что
позволяет безопасно обращаться к свойствам, специфичным для подтипа, внутри того же блока.

| Утилитарная функция | Детали                                                              |
| :------------------ | :------------------------------------------------------------------ |
| `isFormControl`     | Возвращает `true`, когда элемент управления является `FormControl`. |
| `isFormGroup`       | Возвращает `true`, когда элемент управления является `FormGroup`.   |
| `isFormRecord`      | Возвращает `true`, когда элемент управления является `FormRecord`.  |
| `isFormArray`       | Возвращает `true`, когда элемент управления является `FormArray`.   |

Эти помощники особенно полезны в **кастомных валидаторах**, где сигнатура функции получает `AbstractControl`, но логика
предназначена для конкретного вида элемента управления.

```ts
import { AbstractControl, isFormArray } from '@angular/forms';

export function positiveValues(control: AbstractControl) {
    if (!isFormArray(control)) {
        return null; // Not a FormArray: validator is not applicable.
    }

    // Safe to access FormArray-specific API after narrowing.
    const hasNegative = control.controls.some(c => c.value < 0);
    return hasNegative ? { positiveValues: true } : null;
}
```

## Сводка API реактивных форм

В следующей таблице перечислены базовые классы и сервисы, используемые для создания и управления реактивными элементами
управления формы.
Для получения полной информации о синтаксисе см. справочную документацию API
для [пакета Forms](api#forms 'API reference').

### Классы

| Класс             | Детали                                                                                                                                                                                                |
| :---------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `AbstractControl` | Абстрактный базовый класс для конкретных классов элементов управления формы `FormControl`, `FormGroup` и `FormArray`. Он предоставляет их общее поведение и свойства.                                 |
| `FormControl`     | Управляет значением и статусом валидности отдельного элемента управления формы. Он соответствует HTML-элементу управления формы, такому как `<input>` или `<select>`.                                 |
| `FormGroup`       | Управляет значением и статусом валидности группы экземпляров `AbstractControl`. Свойства группы включают ее дочерние элементы управления. Форма верхнего уровня в вашем компоненте — это `FormGroup`. |
| `FormArray`       | Управляет значением и статусом валидности числового индексированного массива экземпляров `AbstractControl`.                                                                                           |
| `FormBuilder`     | Внедряемый сервис, который предоставляет фабричные методы для создания экземпляров элементов управления.                                                                                              |
| `FormRecord`      | Отслеживает значение и статус валидности коллекции экземпляров `FormControl`, каждый из которых имеет одинаковый тип значения.                                                                        |

### Директивы

| Директива              | Детали                                                                                                    |
| :--------------------- | :-------------------------------------------------------------------------------------------------------- |
| `FormControlDirective` | Синхронизирует автономный (standalone) экземпляр `FormControl` с элементом управления формы.              |
| `FormControlName`      | Синхронизирует `FormControl` в существующем экземпляре `FormGroup` с элементом управления формы по имени. |
| `FormGroupDirective`   | Синхронизирует существующий экземпляр `FormGroup` с DOM-элементом.                                        |
| `FormGroupName`        | Синхронизирует вложенный экземпляр `FormGroup` с DOM-элементом.                                           |
| `FormArrayName`        | Синхронизирует вложенный экземпляр `FormArray` с DOM-элементом.                                           |
