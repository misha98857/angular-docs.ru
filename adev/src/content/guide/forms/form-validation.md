# Валидация ввода в формах

Вы можете улучшить общее качество данных, проверяя ввод пользователя на точность и полноту.
Эта страница показывает, как валидировать ввод пользователя из UI и отображать полезные сообщения о валидации как в
реактивных формах, так и в формах на основе шаблонов.

## Валидация ввода в формах на основе шаблонов

Чтобы добавить валидацию в форму на основе шаблона, добавьте те же атрибуты валидации, что и
при [нативной валидации форм HTML](https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation).
Angular использует директивы для сопоставления этих атрибутов с функциями-валидаторами во фреймворке.

Каждый раз, когда значение элемента управления формы изменяется, Angular запускает валидацию и генерирует либо список
ошибок валидации (что приводит к статусу `INVALID`), либо null (что приводит к статусу VALID).

Затем вы можете проверить состояние элемента управления, экспортировав `ngModel` в локальную переменную шаблона.
Следующий пример экспортирует `NgModel` в переменную с именем `name`:

<docs-code header="actor-form-template.component.html (name)" path="adev/src/content/examples/form-validation/src/app/template/actor-form-template.component.html" region="name-with-error-msg"/>

Обратите внимание на следующие особенности, проиллюстрированные в примере:

- Элемент `<input>` содержит атрибуты валидации HTML: `required` и `minlength`.
  Он также содержит директиву пользовательского валидатора `forbiddenName`.
  Для получения дополнительной информации см. раздел [Пользовательские валидаторы](#defining-custom-validators).

- `#name="ngModel"` экспортирует `NgModel` в локальную переменную с именем `name`.
  `NgModel` отражает многие свойства своего базового экземпляра `FormControl`, поэтому вы можете использовать это в
  шаблоне для проверки состояний элемента управления, таких как `valid` и `dirty`.
  Полный список свойств элемента управления см. в справочнике API [AbstractControl](api/forms/AbstractControl).
  - Внешний `@if` показывает набор вложенных сообщений, но только если `name` невалидно и элемент управления либо
    `dirty` (изменен), либо `touched` (тронут).

  - Каждый вложенный `@if` может представлять пользовательское сообщение для одной из возможных ошибок валидации.
    Здесь есть сообщения для `required`, `minlength` и `forbiddenName`.

ПОЛЕЗНО: Чтобы предотвратить отображение ошибок валидатором до того, как у пользователя появится возможность
отредактировать форму, следует проверять состояния `dirty` или `touched` в элементе управления.

- Когда пользователь изменяет значение в отслеживаемом поле, элемент управления помечается как "dirty" (измененный).
- Когда пользователь убирает фокус с элемента управления формы (blur), элемент управления помечается как "touched" (
  тронутый).

## Валидация ввода в реактивных формах

В реактивной форме источником истины является класс компонента.
Вместо добавления валидаторов через атрибуты в шаблоне, вы добавляете функции-валидаторы непосредственно в модель
элемента управления формы в классе компонента.
Angular вызывает эти функции всякий раз, когда значение элемента управления изменяется.

### Функции-валидаторы

Функции-валидаторы могут быть синхронными или асинхронными.

| Тип валидатора         | Подробности                                                                                                                                                                                                                                |
| :--------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Синхронные валидаторы  | Синхронные функции, которые принимают экземпляр элемента управления и немедленно возвращают либо набор ошибок валидации, либо `null`. Передавайте их вторым аргументом при создании экземпляра `FormControl`.                              |
| Асинхронные валидаторы | Асинхронные функции, которые принимают экземпляр элемента управления и возвращают Promise или Observable, который позже эмитит набор ошибок валидации или `null`. Передавайте их третьим аргументом при создании экземпляра `FormControl`. |

В целях производительности Angular запускает асинхронные валидаторы только в том случае, если все синхронные валидаторы
прошли успешно.
Каждый из них должен завершиться до того, как будут установлены ошибки.

### Встроенные функции-валидаторы

Вы можете [написать свои собственные функции-валидаторы](#defining-custom-validators) или использовать встроенные
валидаторы Angular.

Те же встроенные валидаторы, которые доступны как атрибуты в формах на основе шаблонов (например, `required` и
`minlength`), доступны для использования как функции из класса `Validators`.
Полный список встроенных валидаторов см. в справочнике API [Validators](api/forms/Validators).

Чтобы обновить форму актера до реактивной формы, используйте некоторые из тех же встроенных валидаторов — на этот раз в
виде функций, как в следующем примере.

<docs-code header="actor-form-reactive.component.ts (validator functions)" path="adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.1.ts" region="form-group"/>

В этом примере элемент управления `name` устанавливает два встроенных валидатора — `Validators.required` и
`Validators.minLength(4)` — и один пользовательский валидатор `forbiddenNameValidator`.

Все эти валидаторы являются синхронными, поэтому они передаются вторым аргументом.
Обратите внимание, что вы можете поддерживать несколько валидаторов, передавая функции в виде массива.

Этот пример также добавляет несколько getter-методов.
В реактивной форме вы всегда можете получить доступ к любому элементу управления через метод `get` его родительской
группы, но иногда полезно определить геттеры как сокращения для шаблона.

Если вы снова посмотрите на шаблон для ввода `name`, он довольно похож на пример с формой на основе шаблона.

<docs-code header="actor-form-reactive.component.html (name with error msg)" path="adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.html" region="name-with-error-msg"/>

Эта форма отличается от версии на основе шаблонов тем, что она больше не экспортирует никаких директив. Вместо этого она
использует геттер `name`, определенный в классе компонента.

Обратите внимание, что атрибут `required` все еще присутствует в шаблоне. Хотя он не нужен для валидации, его следует
сохранить для целей доступности.

## Определение пользовательских валидаторов {#defining-custom-validators}

Встроенные валидаторы не всегда соответствуют конкретному сценарию использования вашего приложения, поэтому иногда вам
нужно создать пользовательский валидатор.

Рассмотрим функцию `forbiddenNameValidator` из предыдущего примера.
Вот как выглядит определение этой функции.

<docs-code header="forbidden-name.directive.ts (forbiddenNameValidator)" path="adev/src/content/examples/form-validation/src/app/shared/forbidden-name.directive.ts" region="custom-validator"/>

Функция представляет собой фабрику, которая принимает регулярное выражение для обнаружения _конкретного_ запрещенного
имени и возвращает функцию-валидатор.

В этом примере запрещенным именем является "bob", поэтому валидатор отклоняет любое имя актера, содержащее "bob".
В другом месте он мог бы отклонять "alice" или любое имя, соответствующее настроенному регулярному выражению.

Фабрика `forbiddenNameValidator` возвращает настроенную функцию-валидатор.
Эта функция принимает объект элемента управления Angular и возвращает _либо_ null, если значение элемента управления
валидно, _либо_ объект ошибки валидации.
Объект ошибки валидации обычно имеет свойство, имя которого является ключом валидации (`'forbiddenName'`), а значение —
произвольным словарем значений, которые вы могли бы вставить в сообщение об ошибке (`{name}`).

Пользовательские асинхронные валидаторы похожи на синхронные, но они должны возвращать Promise или Observable, который
позже эмитит null или объект ошибки валидации.
В случае Observable, он должен завершиться (complete), после чего форма использует последнее переданное значение для
валидации.

### Добавление пользовательских валидаторов в реактивные формы

В реактивных формах добавьте пользовательский валидатор, передав функцию непосредственно в `FormControl`.

<docs-code header="actor-form-reactive.component.ts (validator functions)" path="adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.1.ts" region="custom-validator"/>

### Добавление пользовательских валидаторов в формы на основе шаблонов

В формах на основе шаблонов добавьте директиву в шаблон, где директива оборачивает функцию-валидатор.
Например, соответствующая `ForbiddenValidatorDirective` служит оберткой вокруг `forbiddenNameValidator`.

Angular распознает роль директивы в процессе валидации, потому что директива регистрирует себя с помощью провайдера
`NG_VALIDATORS`, как показано в следующем примере.
`NG_VALIDATORS` — это предопределенный провайдер с расширяемой коллекцией валидаторов.

<docs-code header="forbidden-name.directive.ts (providers)" path="adev/src/content/examples/form-validation/src/app/shared/forbidden-name.directive.ts" region="directive-providers"/>

Затем класс директивы реализует интерфейс `Validator`, чтобы легко интегрироваться с формами Angular.
Вот остальная часть директивы, чтобы помочь вам понять, как все это работает вместе.

<docs-code header="forbidden-name.directive.ts (directive)" path="adev/src/content/examples/form-validation/src/app/shared/forbidden-name.directive.ts" region="directive"/>

Как только `ForbiddenValidatorDirective` готова, вы можете добавить ее селектор `appForbiddenName` к любому элементу
input, чтобы активировать ее.
Например:

<docs-code header="actor-form-template.component.html (forbidden-name-input)" path="adev/src/content/examples/form-validation/src/app/template/actor-form-template.component.html" region="name-input"/>

ПОЛЕЗНО: Обратите внимание, что директива пользовательской валидации создается с использованием `useExisting`, а не
`useClass`.
Зарегистрированный валидатор должен быть _именно этим экземпляром_ `ForbiddenValidatorDirective` — экземпляром в форме,
у которого свойство `forbiddenName` привязано к "bob".

Если бы вы заменили `useExisting` на `useClass`, вы бы зарегистрировали новый экземпляр класса, у которого нет
`forbiddenName`.

## CSS-классы статуса элемента управления {#control-status-css-classes}

Angular автоматически отражает многие свойства элемента управления в элементе формы в виде CSS-классов.
Используйте эти классы для стилизации элементов управления формы в соответствии с состоянием формы.
В настоящее время поддерживаются следующие классы:

- `.ng-valid`
- `.ng-invalid`
- `.ng-pending`
- `.ng-pristine`
- `.ng-dirty`
- `.ng-untouched`
- `.ng-touched`
- `.ng-submitted` \(только для элемента form\)

В следующем примере форма актера использует классы `.ng-valid` и `.ng-invalid` для установки цвета границы каждого
элемента управления формы.

<docs-code header="forms.css (status classes)" path="adev/src/content/examples/form-validation/src/assets/forms.css"/>

## Кросс-полевая валидация

Кросс-полевой валидатор —
это [пользовательский валидатор](#defining-custom-validators 'Читать о пользовательских валидаторах'), который
сравнивает значения различных полей в форме и принимает или отклоняет их в комбинации.
Например, у вас может быть форма, предлагающая взаимно несовместимые опции, так что пользователь может выбрать A или B,
но не оба сразу.
Значения некоторых полей также могут зависеть от других; пользователю может быть разрешено выбрать B только в том
случае, если также выбрано A.

Следующие примеры кросс-валидации показывают, как сделать следующее:

- Валидировать ввод в реактивной или шаблонной форме на основе значений двух соседних элементов управления.
- Показать описательное сообщение об ошибке после того, как пользователь взаимодействовал с формой и валидация не
  прошла.

Примеры используют кросс-валидацию, чтобы гарантировать, что актеры не используют одно и то же имя в своей роли при
заполнении формы актера.
Валидаторы делают это, проверяя, что имена и роли актеров не совпадают.

### Добавление кросс-валидации в реактивные формы

Форма имеет следующую структуру:

```ts
const actorForm = new FormGroup({
  'name': new FormControl(),
  'role': new FormControl(),
  'skill': new FormControl(),
});
```

Обратите внимание, что `name` и `role` являются соседними элементами управления.
Чтобы оценить оба элемента управления в одном пользовательском валидаторе, вы должны выполнить валидацию в общем предке:
`FormGroup`.
Вы запрашиваете у `FormGroup` его дочерние элементы управления, чтобы сравнить их значения.

Чтобы добавить валидатор в `FormGroup`, передайте новый валидатор вторым аргументом при создании.

```ts
const actorForm = new FormGroup(
  {
    'name': new FormControl(),
    'role': new FormControl(),
    'skill': new FormControl(),
  },
  {validators: unambiguousRoleValidator},
);
```

Код валидатора выглядит следующим образом:

<docs-code header="unambiguous-role.directive.ts" path="adev/src/content/examples/form-validation/src/app/shared/unambiguous-role.directive.ts" region="cross-validation-validator"/>

Валидатор `unambiguousRoleValidator` реализует интерфейс `ValidatorFn`.
Он принимает объект элемента управления Angular в качестве аргумента и возвращает либо null, если форма валидна, либо
`ValidationErrors` в противном случае.

Валидатор получает дочерние элементы управления, вызывая метод [get](api/forms/AbstractControl#get) у `FormGroup`, а
затем сравнивает значения элементов управления `name` и `role`.

Если значения не совпадают, роль однозначна, оба значения валидны, и валидатор возвращает null.
Если они совпадают, роль актера неоднозначна, и валидатор должен пометить форму как невалидную, вернув объект ошибки.

Для улучшения пользовательского опыта шаблон показывает соответствующее сообщение об ошибке, когда форма невалидна.

<docs-code header="actor-form-template.component.html" path="adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.html" region="cross-validation-error-message"/>

Этот `@if` отображает ошибку, если `FormGroup` имеет ошибку кросс-валидации, возвращенную валидатором
`unambiguousRoleValidator`, но только если пользователь закончил [взаимодействие с формой](#control-status-css-classes).

### Добавление кросс-валидации в формы на основе шаблонов

Для формы на основе шаблона вы должны создать директиву, которая оборачивает функцию-валидатор.
Вы предоставляете эту директиву в качестве валидатора, используя токен [`NG_VALIDATORS`](/api/forms/NG_VALIDATORS), как
показано в следующем примере.

<docs-code header="unambiguous-role.directive.ts" path="adev/src/content/examples/form-validation/src/app/shared/unambiguous-role.directive.ts" region="cross-validation-directive"/>

Вы должны добавить новую директиву в HTML-шаблон.
Поскольку валидатор должен быть зарегистрирован на самом высоком уровне формы, следующий шаблон помещает директиву на
тег `form`.

<docs-code header="actor-form-template.component.html" path="adev/src/content/examples/form-validation/src/app/template/actor-form-template.component.html" region="cross-validation-register-validator"/>

Для улучшения пользовательского опыта соответствующее сообщение об ошибке появляется, когда форма невалидна.

<docs-code header="actor-form-template.component.html" path="adev/src/content/examples/form-validation/src/app/template/actor-form-template.component.html" region="cross-validation-error-message"/>

Это одинаково как для шаблонных, так и для реактивных форм.

## Создание асинхронных валидаторов

Асинхронные валидаторы реализуют интерфейсы `AsyncValidatorFn` и `AsyncValidator`.
Они очень похожи на свои синхронные аналоги, со следующими отличиями:

- Функции `validate()` должны возвращать Promise или Observable.
- Возвращаемый Observable должен быть конечным, то есть он должен завершиться (complete) в какой-то момент.
  Чтобы преобразовать бесконечный Observable в конечный, пропустите Observable через фильтрующий оператор, такой как
  `first`, `last`, `take` или `takeUntil`.

Асинхронная валидация происходит после синхронной валидации и выполняется только в том случае, если синхронная валидация
прошла успешно.
Эта проверка позволяет формам избегать потенциально дорогостоящих процессов асинхронной валидации (таких как
HTTP-запрос), если более простые методы валидации уже обнаружили неверный ввод.

После начала асинхронной валидации элемент управления формы переходит в состояние `pending` (ожидание).
Проверьте свойство `pending` элемента управления и используйте его для визуальной обратной связи о текущей операции
валидации.

Распространенный UI-паттерн — показывать спиннер во время выполнения асинхронной валидации.
Следующий пример показывает, как добиться этого в форме на основе шаблона.

```angular-html
<input [(ngModel)]="name" #model="ngModel" appSomeAsyncValidator>

@if(model.pending) {
  <app-spinner />
}
```

### Реализация пользовательского асинхронного валидатора

В следующем примере асинхронный валидатор гарантирует, что актеры выбираются на роль, которая еще не занята.
Новые актеры постоянно проходят прослушивания, а старые уходят на пенсию, поэтому список доступных ролей невозможно
получить заранее.
Чтобы проверить потенциальную запись роли, валидатор должен инициировать асинхронную операцию для обращения к
центральной базе данных всех текущих актеров.

Следующий код создает класс валидатора `UniqueRoleValidator`, который реализует интерфейс `AsyncValidator`.

<docs-code header="role.directive.ts" path="adev/src/content/examples/form-validation/src/app/shared/role.directive.ts" region="async-validator"/>

Свойство `actorsService` инициализируется экземпляром токена `ActorsService`, который определяет следующий интерфейс.

```ts
interface ActorsService {
  isRoleTaken: (role: string) => Observable<boolean>;
}
```

В реальном приложении `ActorsService` отвечал бы за выполнение HTTP-запроса к базе данных актеров, чтобы проверить,
доступна ли роль.
С точки зрения валидатора, фактическая реализация сервиса не важна, поэтому пример может просто программировать против
интерфейса `ActorsService`.

Когда начинается валидация, `UnambiguousRoleValidator` делегирует выполнение методу `isRoleTaken()` сервиса
`ActorsService` с текущим значением элемента управления.
В этот момент элемент управления помечается как `pending` и остается в этом состоянии до тех пор, пока цепочка
Observable, возвращенная из метода `validate()`, не завершится.

Метод `isRoleTaken()` отправляет HTTP-запрос, который проверяет доступность роли, и возвращает `Observable<boolean>` в
качестве результата.
Метод `validate()` пропускает ответ через оператор `map` и преобразует его в результат валидации.

Затем метод, как и любой валидатор, возвращает `null`, если форма валидна, и `ValidationErrors`, если нет.
Этот валидатор обрабатывает любые потенциальные ошибки с помощью оператора `catchError`.
В данном случае валидатор рассматривает ошибку `isRoleTaken()` как успешную валидацию, потому что невозможность
выполнить запрос валидации не обязательно означает, что роль невалидна.
Вы могли бы обработать ошибку по-другому и вернуть объект `ValidationError`.

Через некоторое время цепочка Observable завершается, и асинхронная валидация заканчивается.
Флаг `pending` устанавливается в `false`, и валидность формы обновляется.

### Добавление асинхронных валидаторов в реактивные формы

Чтобы использовать асинхронный валидатор в реактивных формах, начните с внедрения валидатора в свойство класса
компонента.

<docs-code header="actor-form-reactive.component.2.ts" path="adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.2.ts" region="async-validator-inject"/>

Затем передайте функцию-валидатор непосредственно в `FormControl`, чтобы применить ее.

В следующем примере функция `validate` из `UnambiguousRoleValidator` применяется к `roleControl` путем передачи ее в
опцию `asyncValidators` элемента управления и привязки к экземпляру `UnambiguousRoleValidator`, который был внедрен в
`ActorFormReactiveComponent`.
Значением `asyncValidators` может быть либо одна функция асинхронного валидатора, либо массив функций.
Чтобы узнать больше об опциях `FormControl`, см. справочник
API [AbstractControlOptions](api/forms/AbstractControlOptions).

<docs-code header="actor-form-reactive.component.2.ts" path="adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.2.ts" region="async-validator-usage"/>

### Добавление асинхронных валидаторов в формы на основе шаблонов

Чтобы использовать асинхронный валидатор в формах на основе шаблонов, создайте новую директиву и зарегистрируйте на ней
провайдер `NG_ASYNC_VALIDATORS`.

В примере ниже директива внедряет класс `UniqueRoleValidator`, который содержит фактическую логику валидации, и вызывает
его в функции `validate`, запускаемой Angular, когда должна произойти валидация.

<docs-code header="role.directive.ts" path="adev/src/content/examples/form-validation/src/app/shared/role.directive.ts" region="async-validator-directive"/>

Затем, как и в случае с синхронными валидаторами, добавьте селектор директивы к input, чтобы активировать ее.

<docs-code header="actor-form-template.component.html (unique-unambiguous-role-input)" path="adev/src/content/examples/form-validation/src/app/template/actor-form-template.component.html" region="role-input"/>

### Оптимизация производительности асинхронных валидаторов

По умолчанию все валидаторы запускаются после каждого изменения значения формы.
С синхронными валидаторами это обычно не оказывает заметного влияния на производительность приложения.
Однако асинхронные валидаторы обычно выполняют какой-либо HTTP-запрос для валидации элемента управления.
Отправка HTTP-запроса после каждого нажатия клавиши может создать нагрузку на backend API, и этого следует избегать,
если это возможно.

Вы можете отложить обновление валидности формы, изменив свойство `updateOn` с `change` (по умолчанию) на `submit` или
`blur`.

В формах на основе шаблонов установите это свойство в шаблоне.

```angular-html
<input [(ngModel)]="name" [ngModelOptions]="{updateOn: 'blur'}">
```

В реактивных формах установите это свойство в экземпляре `FormControl`.

```ts
new FormControl('', {updateOn: 'blur'});
```

## Взаимодействие с нативной валидацией форм HTML

По умолчанию Angular
отключает [нативную валидацию форм HTML](https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation),
добавляя атрибут `novalidate` на охватывающий тег `<form>`, и использует директивы для сопоставления этих атрибутов с
функциями-валидаторами во фреймворке.
Если вы хотите использовать нативную валидацию **в сочетании** с валидацией на основе Angular, вы можете снова включить
ее с помощью директивы `ngNativeValidate`.
Подробности см. в [документации API](api/forms/NgForm#native-dom-validation-ui).
