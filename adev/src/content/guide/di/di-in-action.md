# DI в действии

В этом руководстве рассматриваются дополнительные возможности внедрения зависимостей (DI) в Angular.

ПРИМЕЧАНИЕ: Для полного ознакомления с InjectionToken и пользовательскими провайдерами см. руководство
по [определению провайдеров зависимостей](guide/di/defining-dependency-providers#injection-tokens).

## Внедрение DOM-элемента компонента

Хотя разработчики стараются избегать этого, некоторые визуальные эффекты и сторонние инструменты требуют прямого доступа
к DOM.
В результате вам может потребоваться доступ к DOM-элементу компонента.

Angular предоставляет доступ к базовому элементу `@Component` или `@Directive` через внедрение с использованием токена
`ElementRef`:

```ts {highlight:[7]}
import {Directive, ElementRef, inject} from '@angular/core';

@Directive({
  selector: '[appHighlight]',
})
export class HighlightDirective {
  private element = inject(ElementRef);

  update() {
    this.element.nativeElement.style.color = 'red';
  }
}

```

## Разрешение циклических зависимостей с помощью forwardRef

Порядок объявления классов имеет значение в TypeScript.
Вы не можете ссылаться на класс напрямую, пока он не будет определен.

Обычно это не является проблемой, особенно если вы придерживаетесь рекомендуемого правила _один класс на файл_.
Но иногда циклические ссылки неизбежны.
Например, когда класс 'A' ссылается на класс 'B', а 'B' ссылается на 'A', один из них должен быть определен первым.

Функция Angular `forwardRef()` создает _косвенную_ ссылку, которую Angular может разрешить позже.

Вы сталкиваетесь с аналогичной проблемой, когда класс делает _ссылку на самого себя_.
Например, в своем массиве `providers`.
Массив `providers` является свойством функции-декоратора `@Component()`, которая должна находиться перед определением
класса.
Вы можете разорвать такие циклические ссылки, используя `forwardRef`.

```typescript {header: 'app.component.ts', highlight: [4]}
providers: [
  {
    provide: PARENT_MENU_ITEM,
    useExisting: forwardRef(() => MenuItem),
  },
],
```
