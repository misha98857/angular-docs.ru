# Оптимизация размера клиентского приложения с помощью легковесных токенов внедрения

Эта страница предоставляет концептуальный обзор техники внедрения зависимостей (DI), которая рекомендуется для
разработчиков библиотек.
Проектирование вашей библиотеки с использованием _легковесных токенов внедрения_ помогает оптимизировать размер бандла
клиентских приложений, использующих вашу библиотеку.

Вы можете управлять структурой зависимостей между вашими компонентами и внедряемыми сервисами для оптимизации размера
бандла, используя провайдеры, поддерживающие tree shaking.
Обычно это гарантирует, что если предоставляемый компонент или сервис фактически не используется приложением, компилятор
может удалить его код из бандла.

Из-за того, как Angular хранит токены внедрения, возможно, что такой неиспользуемый компонент или сервис все равно
попадет в бандл.
Эта страница описывает паттерн проектирования внедрения зависимостей, который поддерживает правильный tree shaking за
счет использования легковесных токенов внедрения.

Паттерн легковесных токенов внедрения особенно важен для разработчиков библиотек.
Он гарантирует, что когда приложение использует только некоторые возможности вашей библиотеки, неиспользуемый код может
быть исключен из бандла клиентского приложения.

Когда приложение использует вашу библиотеку, в ней могут быть сервисы, которые клиентское приложение не использует.
В этом случае разработчик приложения должен ожидать, что этот сервис будет удален посредством tree shaking и не увеличит
размер скомпилированного приложения.
Поскольку разработчик приложения не может знать о проблеме tree shaking в библиотеке или исправить ее, это является
ответственностью разработчика библиотеки.
Чтобы предотвратить удержание неиспользуемых компонентов, ваша библиотека должна использовать паттерн легковесных
токенов внедрения.

## Когда токены удерживаются

Чтобы лучше объяснить условия, при которых происходит удержание токена, рассмотрим библиотеку, предоставляющую компонент
карточки (`library-card`).
Этот компонент содержит тело и может содержать необязательный заголовок:

```angular-html

<lib-card>;
<lib-header>…</lib-header>;
</lib-card>;
```

В вероятной реализации компонент `<lib-card>` использует `@ContentChild()` или `@ContentChildren()` для получения
`<lib-header>` и `<lib-body>`, как показано ниже:

```ts {highlight: [14]}
import {Component, ContentChild} from '@angular/core';

@Component({
  selector: 'lib-header',
  …,
})
class LibHeaderComponent {}

@Component({
  selector: 'lib-card',
  …,
})
class LibCardComponent {
  @ContentChild(LibHeaderComponent) header: LibHeaderComponent | null = null;
}
```

Поскольку `<lib-header>` является необязательным, элемент может появиться в шаблоне в минимальной форме:
`<lib-card></lib-card>`.
В этом случае `<lib-header>` не используется, и вы ожидаете, что он будет удален (tree-shaken), но этого не происходит.
Это связано с тем, что `LibCardComponent` фактически содержит две ссылки на `LibHeaderComponent`:

```ts
@ContentChild(LibHeaderComponent) header: LibHeaderComponent;
```

- Одна из этих ссылок находится в _позиции типа_ — то есть она указывает `LibHeaderComponent` как тип:
  `header: LibHeaderComponent;`.
- Другая ссылка находится в _позиции значения_ — то есть `LibHeaderComponent` является значением декоратора параметра
  `@ContentChild()`: `@ContentChild(LibHeaderComponent)`.

Компилятор обрабатывает ссылки на токены в этих позициях по-разному:

- Компилятор стирает ссылки в _позиции типа_ после преобразования из TypeScript, поэтому они не влияют на tree shaking.
- Компилятор должен сохранять ссылки в _позиции значения_ во время выполнения, что **предотвращает** удаление компонента
  посредством tree shaking.

В примере компилятор сохраняет токен `LibHeaderComponent`, который находится в позиции значения.
Это предотвращает удаление ссылаемого компонента, даже если приложение фактически нигде не использует `<lib-header>`.
Если код, шаблон и стили `LibHeaderComponent` в совокупности становятся слишком большими, их ненужное включение может
значительно увеличить размер клиентского приложения.

## Когда использовать паттерн легковесных токенов внедрения

Проблема с tree shaking возникает, когда компонент используется в качестве токена внедрения.
Есть два случая, когда это может произойти:

- Токен используется в позиции значения [запроса контента (content query)](guide/components/queries#content-queries).
- Токен используется как спецификатор типа для внедрения в конструктор.

В следующем примере оба использования токена `OtherComponent` вызывают удержание `OtherComponent`, предотвращая его
удаление (tree shaking), когда он не используется:

```ts {highlight: [[2],[4]]}
class MyComponent {
  constructor(@Optional() other: OtherComponent) {}

  @ContentChild(OtherComponent) other: OtherComponent | null;
}
```

Хотя токены, используемые только как спецификаторы типов, удаляются при конвертации в JavaScript, все токены,
используемые для внедрения зависимостей, необходимы во время выполнения.
Это фактически меняет `constructor(@Optional() other: OtherComponent)` на
`constructor(@Optional() @Inject(OtherComponent) other)`.
Токен теперь находится в позиции значения, что заставляет механизм tree shaking сохранять ссылку.

HELPFUL: Библиотекам следует
использовать [провайдеры, поддерживающие tree shaking](guide/di/dependency-injection#providing-dependency) для всех
сервисов, предоставляя зависимости на корневом уровне, а не в компонентах или модулях.

## Использование легковесных токенов внедрения

Паттерн проектирования с легковесными токенами внедрения заключается в использовании небольшого абстрактного класса в
качестве токена внедрения и предоставлении фактической реализации на более позднем этапе.
Абстрактный класс сохраняется (не удаляется tree shaking), но он мал и не оказывает существенного влияния на размер
приложения.

Следующий пример показывает, как это работает для `LibHeaderComponent`:

```ts {highlight: [[1],[5], [15]]}
abstract class LibHeaderToken {}

@Component({
  selector: 'lib-header',
  providers: [{provide: LibHeaderToken, useExisting: LibHeaderComponent}],
  …,
})
class LibHeaderComponent extends LibHeaderToken {}

@Component({
  selector: 'lib-card',
  …,
})
class LibCardComponent {
  @ContentChild(LibHeaderToken) header: LibHeaderToken | null = null;
}
```

В этом примере реализация `LibCardComponent` больше не ссылается на `LibHeaderComponent` ни в позиции типа, ни в позиции
значения.
Это позволяет выполнить полный tree shaking для `LibHeaderComponent`.
`LibHeaderToken` сохраняется, но это всего лишь объявление класса без конкретной реализации.
Он мал и не оказывает существенного влияния на размер приложения при сохранении после компиляции.

Вместо этого сам `LibHeaderComponent` реализует абстрактный класс `LibHeaderToken`.
Вы можете безопасно использовать этот токен в качестве провайдера в определении компонента, позволяя Angular корректно
внедрять конкретный тип.

Подводя итог, паттерн легковесных токенов внедрения состоит из следующего:

1. Легковесный токен внедрения, представленный как абстрактный класс.
2. Определение компонента, которое реализует этот абстрактный класс.
3. Внедрение легковесного паттерна с использованием `@ContentChild()` или `@ContentChildren()`.
4. Провайдер в реализации легковесного токена внедрения, который связывает легковесный токен с реализацией.

### Использование легковесного токена внедрения для определения API

Компоненту, который внедряет легковесный токен, может потребоваться вызвать метод во внедренном классе.
Токен теперь является абстрактным классом. Поскольку внедряемый компонент реализует этот класс, вы также должны объявить
абстрактный метод в абстрактном классе легковесного токена.
Реализация метода со всем накладным расходом кода находится во внедряемом компоненте, который может быть удален
посредством tree shaking.
Это позволяет родителю взаимодействовать с потомком, если он присутствует, типобезопасным способом.

Например, `LibCardComponent` теперь запрашивает `LibHeaderToken`, а не `LibHeaderComponent`.
Следующий пример показывает, как этот паттерн позволяет `LibCardComponent` взаимодействовать с `LibHeaderComponent`,
фактически не ссылаясь на `LibHeaderComponent`:

```ts {highlight: [[2],[9],[11],[19]]}
abstract class LibHeaderToken {
  abstract doSomething(): void;
}

@Component({
  selector: 'lib-header',
  providers: [{provide: LibHeaderToken, useExisting: LibHeaderComponent}],
})
class LibHeaderComponent extends LibHeaderToken {
  doSomething(): void {
    // Concrete implementation of `doSomething`
  }
}

@Component({
  selector: 'lib-card',
})
class LibCardComponent implements AfterContentInit {
  @ContentChild(LibHeaderToken) header: LibHeaderToken | null = null;

  ngAfterContentInit(): void {
    if (this.header !== null) {
      this.header?.doSomething();
    }
  }
}
```

В этом примере родитель запрашивает токен для получения дочернего компонента и сохраняет полученную ссылку на компонент,
если он присутствует.
Перед вызовом метода у потомка родительский компонент проверяет, присутствует ли дочерний компонент.
Если дочерний компонент был удален (tree-shaken), ссылка на него во время выполнения отсутствует, и вызов его метода не
происходит.

### Именование вашего легковесного токена внедрения

Легковесные токены внедрения полезны только с компонентами.
Стиль кода Angular (Style Guide) предлагает именовать компоненты, используя суффикс "Component".
Пример "LibHeaderComponent" следует этому соглашению.

Вам следует поддерживать связь между компонентом и его токеном, но при этом различать их.
Рекомендуемый стиль — использовать базовое имя компонента с суффиксом "`Token`" для именования ваших легковесных токенов
внедрения: "`LibHeaderToken`".
