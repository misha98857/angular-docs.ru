# Начало работы с NgOptimizedImage

Директива `NgOptimizedImage` позволяет легко применять лучшие практики производительности для загрузки изображений.

Директива гарантирует приоритетную загрузку [LCP-изображения (Largest Contentful Paint)](http://web.dev/lcp) путем:

- Автоматической установки атрибута `fetchpriority` для тега `<img>`
- Ленивой загрузки (lazy loading) остальных изображений по умолчанию
- Автоматической генерации тега preconnect link в заголовке документа
- Автоматической генерации атрибута `srcset`
- Генерации [подсказки предзагрузки (preload hint)](https://developer.mozilla.org/docs/Web/HTML/Link_types/preload),
  если приложение использует SSR

В дополнение к оптимизации загрузки LCP-изображения, `NgOptimizedImage` обеспечивает соблюдение ряда лучших практик для
изображений, таких как:

- Использование [URL-адресов CDN изображений для применения оптимизаций](https://web.dev/image-cdns/#how-image-cdns-use-urls-to-indicate-optimization-options)
- Предотвращение сдвига макета (layout shift) за счет требования `width` и `height`
- Предупреждение, если `width` или `height` заданы некорректно
- Предупреждение, если изображение будет визуально искажено при рендеринге

Если вы используете фоновое изображение в CSS, [начните отсюда](#how-to-migrate-your-background-image).

**ПРИМЕЧАНИЕ: Хотя директива `NgOptimizedImage` стала стабильной функцией в Angular версии 15, она была портирована
обратно и доступна как стабильная функция в версиях 13.4.0 и 14.3.0.**

## Начало работы

<docs-workflow>
<docs-step title="Импортируйте директиву `NgOptimizedImage`">
Импортируйте директиву `NgOptimizedImage` из `@angular/common`:

```ts

import { NgOptimizedImage } from '@angular/common'

```

и включите её в массив `imports` standalone-компонента или NgModule:

```ts
imports: [
  NgOptimizedImage,
  // ...
],
```

</docs-code>
</docs-step>
### (Необязательно) Настройте загрузчик {#optional-set-up-a-loader}
<docs-step title="(Необязательно) Настройте загрузчик">
Загрузчик изображений не является **обязательным** для использования NgOptimizedImage, но его использование с CDN изображений включает мощные функции производительности, в том числе автоматические `srcset` для ваших изображений.

Краткое руководство по настройке загрузчика можно найти в
разделе [Настройка загрузчика изображений для NgOptimizedImage](#configuring-an-image-loader-for-ngoptimizedimage) в
конце этой страницы.
</docs-step>
<docs-step title="Активируйте директиву">
Чтобы активировать директиву `NgOptimizedImage`, замените атрибут `src` вашего изображения на `ngSrc`.

```html

<img ngSrc="cat.jpg">

```

Если вы используете [встроенный сторонний загрузчик](#built-in-loaders), убедитесь, что исключили базовый путь URL из
`src`, так как он будет добавлен загрузчиком автоматически.
</docs-step>
<docs-step title="Пометьте изображения как `priority`">
Всегда помечайте [LCP-изображение](https://web.dev/lcp/#what-elements-are-considered) на вашей странице как `priority`,
чтобы приоритизировать его загрузку.

```html

<img ngSrc="cat.jpg" width="400" height="200" priority>

```

Пометка изображения как `priority` применяет следующие оптимизации:

- Устанавливает `fetchpriority=high` (подробнее о подсказках приоритета читайте [здесь](https://web.dev/priority-hints))
- Устанавливает `loading=eager` (подробнее о нативной ленивой загрузке
  читайте [здесь](https://web.dev/browser-level-image-lazy-loading))
- Автоматически генерирует [элемент ссылки preload](https://developer.mozilla.org/docs/Web/HTML/Link_types/preload),
  если [рендеринг происходит на сервере](guide/ssr).

Angular отображает предупреждение во время разработки, если элемент LCP является изображением, у которого нет атрибута
`priority`. Элемент LCP страницы может варьироваться в зависимости от ряда факторов, таких как размеры экрана
пользователя, поэтому на странице может быть несколько изображений, которые следует пометить как `priority`.
См. [CSS for Web Vitals](https://web.dev/css-web-vitals/#images-and-largest-contentful-paint-lcp) для получения
дополнительных сведений.
</docs-step>
<docs-step title="Укажите ширину и высоту">
Чтобы
предотвратить [сдвиги макета, связанные с изображениями](https://web.dev/css-web-vitals/#images-and-layout-shifts),
NgOptimizedImage требует, чтобы вы указали высоту и ширину для вашего изображения следующим образом:

```html

<img ngSrc="cat.jpg" width="400" height="200">

```

Для **адаптивных изображений** (изображений, которые вы стилизовали для увеличения и уменьшения относительно области
просмотра), атрибуты `width` и `height` должны соответствовать естественному размеру файла изображения. Для адаптивных
изображений также важно [установить значение для `sizes`.](#responsive-images)

Для **изображений фиксированного размера** атрибуты `width` и `height` должны отражать желаемый размер изображения при
рендеринге. Соотношение сторон этих атрибутов всегда должно совпадать с естественным соотношением сторон изображения.

ПРИМЕЧАНИЕ: Если вы не знаете размер ваших изображений, рассмотрите возможность использования режима "fill" для
наследования размера родительского контейнера, как описано ниже.
</docs-step>
</docs-workflow>

## Использование режима `fill` {#using-fill-mode}

В случаях, когда вы хотите, чтобы изображение заполняло содержащий его элемент, вы можете использовать атрибут `fill`.
Это часто полезно, когда вы хотите добиться поведения "фонового изображения". Это также может быть полезно, когда вы не
знаете точную ширину и высоту вашего изображения, но у вас есть родительский контейнер с известным размером, в который
вы хотели бы вписать изображение (см. "object-fit" ниже).

Когда вы добавляете атрибут `fill` к вашему изображению, вам не нужно и не следует указывать `width` и `height`, как в
этом примере:

```html

<img ngSrc="cat.jpg" fill>

```

Вы можете использовать CSS-свойство [object-fit](https://developer.mozilla.org/docs/Web/CSS/object-fit), чтобы изменить
то, как изображение будет заполнять свой контейнер. Если вы стилизуете изображение с помощью `object-fit: "contain"`,
изображение сохранит свое соотношение сторон и будет иметь поля ("letterboxed"), чтобы вписаться в элемент. Если вы
установите `object-fit: "cover"`, элемент сохранит свое соотношение сторон, полностью заполнит элемент, и часть контента
может быть "обрезана".

Визуальные примеры вышеизложенного смотрите
в [документации MDN по object-fit.](https://developer.mozilla.org/docs/Web/CSS/object-fit)

Вы также можете стилизовать изображение с
помощью [свойства object-position](https://developer.mozilla.org/docs/Web/CSS/object-position), чтобы настроить его
положение внутри содержащего элемента.

ВАЖНО: Для правильного рендеринга изображения с `fill`, его родительский элемент **должен** быть стилизован с
`position: "relative"`, `position: "fixed"` или `position: "absolute"`.

## Как перенести фоновое изображение {#how-to-migrate-your-background-image}

Вот простой пошаговый процесс миграции с `background-image` на `NgOptimizedImage`. Для этих шагов мы будем называть
элемент, имеющий фоновое изображение, "содержащим элементом":

1. Удалите стиль `background-image` из содержащего элемента.
2. Убедитесь, что содержащий элемент имеет `position: "relative"`, `position: "fixed"` или `position: "absolute"`.
3. Создайте новый элемент изображения как дочерний элемент содержащего элемента, используя `ngSrc` для включения
   директивы `NgOptimizedImage`.
4. Добавьте этому элементу атрибут `fill`. Не указывайте `height` и `width`.
5. Если вы считаете, что это изображение может быть вашим [элементом LCP](https://web.dev/lcp/), добавьте атрибут
   `priority` к элементу изображения.

Вы можете настроить то, как фоновое изображение заполняет контейнер, как описано в
разделе [Использование режима fill](#using-fill-mode).

## Использование заполнителей (placeholders)

### Автоматические заполнители

NgOptimizedImage может отображать автоматический заполнитель низкого разрешения для вашего изображения, если вы
используете CDN или хостинг изображений, который обеспечивает автоматическое изменение размера изображений.
Воспользуйтесь этой функцией, добавив атрибут `placeholder` к вашему изображению:

```html

<img ngSrc="cat.jpg" width="400" height="200" placeholder>

```

Добавление этого атрибута автоматически запрашивает вторую, уменьшенную версию изображения с использованием указанного
вами загрузчика изображений. Это маленькое изображение будет применено как стиль `background-image` с CSS-размытием во
время загрузки вашего изображения. Если загрузчик изображений не предоставлен, изображение-заполнитель не может быть
сгенерировано, и будет выдана ошибка.

Размер по умолчанию для генерируемых заполнителей составляет 30px в ширину. Вы можете изменить этот размер, указав
значение в пикселях в провайдере `IMAGE_CONFIG`, как показано ниже:

```ts
providers: [
  {
    provide: IMAGE_CONFIG,
    useValue: {
      placeholderResolution: 40
    }
  },
],
```

Если вы хотите четкие края вокруг размытого заполнителя, вы можете обернуть ваше изображение в содержащий `<div>` со
стилем `overflow: hidden`. Пока `<div>` имеет тот же размер, что и изображение (например, при использовании стиля
`width: fit-content`), "размытые края" заполнителя будут скрыты.

### Заполнители Data URL

Вы также можете указать заполнитель, используя
base64 [Data URL](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URLs) без загрузчика изображений.
Формат data url: `data:image/[imagetype];[data]`, где `[imagetype]` — это формат изображения, например `png`, а
`[data]` — это кодировка изображения в base64. Эту кодировку можно выполнить с помощью командной строки или в
JavaScript. Конкретные команды см.
в [документации MDN](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URLs#encoding_data_into_base64_format).
Пример заполнителя Data URL с усеченными данными показан ниже:

```html

<img
  ngSrc="cat.jpg"
  width="400"
  height="200"
  placeholder="data:image/png;base64,iVBORw0K..."
/>

```

Однако большие Data URL увеличивают размер ваших бандлов Angular и замедляют загрузку страницы. Если вы не можете
использовать загрузчик изображений, команда Angular рекомендует сохранять изображения-заполнители в base64 размером
менее 4 КБ и использовать их исключительно для критически важных изображений. В дополнение к уменьшению размеров
заполнителя, рассмотрите возможность изменения форматов изображений или параметров, используемых при сохранении
изображений. При очень низких разрешениях эти параметры могут оказать большое влияние на размер файла.

### Заполнители без размытия

По умолчанию NgOptimizedImage применяет эффект CSS-размытия к заполнителям изображений. Чтобы отобразить заполнитель без
размытия, предоставьте аргумент `placeholderConfig` с объектом, который включает свойство `blur`, установленное в false.
Например:

```html
<img
ngSrc="cat.jpg"
width="400"
height="200"
placeholder
[placeholderConfig]="{blur: false}"
/>
```

## Настройка стилизации изображений

В зависимости от стилизации изображения, добавление атрибутов `width` и `height` может привести к тому, что изображение
будет отображаться по-другому. `NgOptimizedImage` предупреждает вас, если ваша стилизация изображения приводит к
искажению соотношения сторон.

Обычно это можно исправить, добавив `height: auto` или `width: auto` к стилям вашего изображения. Для получения
дополнительной информации см. [статью на web.dev о теге
`<img>`](https://web.dev/patterns/web-vitals-patterns/images/img-tag).

Если атрибуты `width` и `height` изображения мешают вам задать размер изображения так, как вы хотите с помощью CSS,
рассмотрите возможность использования режима `fill` и стилизации родительского элемента изображения.

## Функции производительности

NgOptimizedImage включает ряд функций, предназначенных для улучшения производительности загрузки в вашем приложении. Эти
функции описаны в этом разделе.

### Добавление подсказок ресурсов (Resource Hints) {#add-resource-hints}

[Подсказка ресурса `preconnect`](https://web.dev/preconnect-and-dns-prefetch) для источника вашего изображения
гарантирует, что LCP-изображение загрузится как можно быстрее.

Ссылки preconnect автоматически генерируются для доменов, предоставленных в качестве
аргумента [загрузчику](#optional-set-up-a-loader). Если источник изображения не может быть автоматически
идентифицирован, и для LCP-изображения не обнаружена ссылка preconnect, `NgOptimizedImage` выдаст предупреждение во
время разработки. В этом случае вам следует вручную добавить подсказку ресурса в `index.html`. Внутри `<head>` документа
добавьте тег `link` с `rel="preconnect"`, как показано ниже:

```html

<link rel="preconnect" href="https://my.cdn.origin" />

```

Чтобы отключить предупреждения preconnect, внедрите токен `PRECONNECT_CHECK_BLOCKLIST`:

```ts

providers: [
{provide: PRECONNECT_CHECK_BLOCKLIST, useValue: 'https://your-domain.com'}
],

```

Дополнительную информацию об автоматической генерации preconnect
смотрите [здесь](#why-is-a-preconnect-element-not-being-generated-for-my-image-domain).

### Запрос изображений правильного размера с автоматическим `srcset`

Определение [атрибута `srcset`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/srcset) гарантирует, что
браузер запросит изображение правильного размера для области просмотра вашего пользователя, чтобы не тратить время на
загрузку слишком большого изображения. `NgOptimizedImage` генерирует подходящий `srcset` для изображения на основе
наличия и значения [атрибута `sizes`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/sizes) в теге
изображения.

#### Изображения фиксированного размера

Если ваше изображение должно быть "фиксированным" по размеру (т.е. одинакового размера на всех устройствах, за
исключением [плотности пикселей](https://web.dev/codelab-density-descriptors/)), нет необходимости устанавливать атрибут
`sizes`. `Srcset` может быть сгенерирован автоматически из атрибутов ширины и высоты изображения без дополнительных
входных данных.

Пример сгенерированного srcset:

```html
<img ... srcset="image-400w.jpg 1x, image-800w.jpg 2x">
```

#### Адаптивные изображения {#responsive-images}

Если ваше изображение должно быть адаптивным (т.е. увеличиваться и уменьшаться в зависимости от размера области
просмотра), вам нужно будет определить [атрибут
`sizes`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/sizes) для генерации `srcset`.

Если вы раньше не использовали `sizes`, хорошее начало — установить его на основе ширины области просмотра. Например,
если ваш CSS заставляет изображение занимать 100% ширины области просмотра, установите `sizes` в `100vw`, и браузер
выберет изображение из `srcset`, которое ближе всего к ширине области просмотра (с учетом плотности пикселей). Если ваше
изображение, скорее всего, займет только половину экрана (например, в боковой панели), установите `sizes` в `50vw`,
чтобы браузер выбрал изображение меньшего размера. И так далее.

Если вы обнаружите, что вышеизложенное не покрывает желаемое поведение изображения, см. документацию
по [продвинутым значениям sizes](#advanced-sizes-values).

Обратите внимание, что `NgOptimizedImage` автоматически добавляет `"auto"` перед предоставленным значением `sizes`. Это
оптимизация, которая повышает точность выбора srcset в браузерах, поддерживающих `sizes="auto"`, и игнорируется
браузерами, которые этого не поддерживают.

По умолчанию адаптивные точки останова (breakpoints):

`[16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840]`

Если вы хотите настроить эти точки останова, вы можете сделать это с помощью провайдера `IMAGE_CONFIG`:

```ts
providers: [
  {
    provide: IMAGE_CONFIG,
    useValue: {
      breakpoints: [16, 48, 96, 128, 384, 640, 750, 828, 1080, 1200, 1920]
    }
  },
],
```

Если вы хотите вручную определить атрибут `srcset`, вы можете предоставить свой собственный, используя атрибут
`ngSrcset`:

```html

<img ngSrc="hero.jpg" ngSrcset="100w, 200w, 300w">

```

Если атрибут `ngSrcset` присутствует, `NgOptimizedImage` генерирует и устанавливает `srcset` на основе включенных
размеров. Не включайте имена файлов изображений в `ngSrcset` — директива выводит эту информацию из `ngSrc`. Директива
поддерживает как дескрипторы ширины (например, `100w`), так и дескрипторы плотности (например, `1x`).

```html

<img ngSrc="hero.jpg" ngSrcset="100w, 200w, 300w" sizes="50vw">

```

### Отключение автоматической генерации srcset

Чтобы отключить генерацию srcset для одного изображения, вы можете добавить атрибут `disableOptimizedSrcset` к
изображению:

```html

<img ngSrc="about.jpg" disableOptimizedSrcset>

```

### Отключение ленивой загрузки изображений

По умолчанию `NgOptimizedImage` устанавливает `loading=lazy` для всех изображений, которые не помечены как `priority`.
Вы можете отключить это поведение для неприоритетных изображений, установив атрибут `loading`. Этот атрибут принимает
значения: `eager`, `auto` и `lazy`. [Подробности см. в документации по стандартному атрибуту изображения
`loading`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/loading#value).

```html

<img ngSrc="cat.jpg" width="400" height="200" loading="eager">

```

### Управление декодированием изображений

По умолчанию `NgOptimizedImage` устанавливает `decoding="auto"` для всех изображений. Это позволяет браузеру выбирать
оптимальное время для декодирования изображения после его загрузки. Когда изображение помечено как `priority`, Angular
автоматически устанавливает `decoding="sync"`, чтобы гарантировать, что изображение будет декодировано и отрисовано как
можно раньше, помогая улучшить показатели **Largest Contentful Paint (LCP)**.

Вы все равно можете переопределить это поведение, явно установив атрибут `decoding`.
[Подробности см. в документации по стандартному атрибуту изображения
`decoding`](https://developer.mozilla.org/docs/Web/HTML/Element/img#decoding).

```html
<!-- По умолчанию: decoding равно 'auto' -->
<img ngSrc="gallery/landscape.jpg" width="1200" height="800">

<!-- Декодировать изображение асинхронно, чтобы избежать блокировки основного потока.-->
<img ngSrc="gallery/preview.jpg" width="600" height="400" decoding="async">

<!-- Приоритетные изображения автоматически используют decoding="sync" -->
<img ngSrc="awesome.jpg" width="500" height="625" priority >

<!-- Декодировать немедленно (может блокировать), когда пиксели нужны прямо сейчас -->
<img ngSrc="hero.jpg" width="1600" height="900" decoding="sync">
```

**Допустимые значения**

- `auto` (по умолчанию): позволяет браузеру выбрать оптимальную стратегию.
- `async`: декодирует изображение асинхронно, избегая блокировки основного потока, где это возможно.
- `sync`: декодирует изображение немедленно; может блокировать рендеринг, но гарантирует готовность пикселей, как только
  изображение станет доступным.

### Продвинутые значения 'sizes' {#advanced-sizes-values}

Возможно, вы захотите, чтобы изображения отображались с разной шириной на экранах разного размера. Распространенным
примером этого паттерна является макет на основе сетки или колонок, который отображает одну колонку на мобильных
устройствах и две колонки на более крупных устройствах. Вы можете описать это поведение в атрибуте `sizes`, используя
синтаксис "медиа-запросов", например:

```html

<img ngSrc="cat.jpg" width="400" height="200" sizes="(max-width: 768px) 100vw, 50vw">

```

Атрибут `sizes` в приведенном выше примере говорит: "Я ожидаю, что это изображение будет занимать 100 процентов ширины
экрана на устройствах шириной менее 768 пикселей. В противном случае я ожидаю, что оно будет занимать 50 процентов
ширины экрана".

Для получения дополнительной информации об атрибуте `sizes`
см. [web.dev](https://web.dev/learn/design/responsive-images/#sizes)
или [mdn](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/sizes).

## Настройка загрузчика изображений для `NgOptimizedImage` {#configuring-an-image-loader-for-ngoptimizedimage}

"Загрузчик" (loader) — это функция, которая
генерирует [URL трансформации изображения](https://web.dev/image-cdns/#how-image-cdns-use-urls-to-indicate-optimization-options)
для заданного файла изображения. Когда это уместно, `NgOptimizedImage` устанавливает трансформации размера, формата и
качества для изображения.

`NgOptimizedImage` предоставляет как универсальный загрузчик, который не применяет никаких трансформаций, так и
загрузчики для различных сторонних сервисов изображений. Он также поддерживает написание собственного пользовательского
загрузчика.

| Тип загрузчика                                | Поведение                                                                                                                                                                                                                                                                           |
| :-------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Универсальный загрузчик                       | URL, возвращаемый универсальным загрузчиком, всегда будет соответствовать значению `src`. Другими словами, этот загрузчик не применяет никаких трансформаций. Сайты, использующие Angular для обслуживания изображений, являются основным вариантом использования этого загрузчика. |
| Загрузчики для сторонних сервисов изображений | URL, возвращаемый загрузчиками для сторонних сервисов изображений, будет следовать соглашениям API, используемым конкретным сервисом изображений.                                                                                                                                   |
| Пользовательские загрузчики                   | Поведение пользовательского загрузчика определяется его разработчиком. Вам следует использовать пользовательский загрузчик, если ваш сервис изображений не поддерживается загрузчиками, предварительно настроенными в `NgOptimizedImage`.                                           |

Основываясь на сервисах изображений, часто используемых с приложениями Angular, `NgOptimizedImage` предоставляет
загрузчики, предварительно настроенные для работы со следующими сервисами:

| Сервис изображений        | Angular API               | Документация                                                               |
| :------------------------ | :------------------------ | :------------------------------------------------------------------------- |
| Cloudflare Image Resizing | `provideCloudflareLoader` | [Документация](https://developers.cloudflare.com/images/image-resizing/)   |
| Cloudinary                | `provideCloudinaryLoader` | [Документация](https://cloudinary.com/documentation/resizing_and_cropping) |
| ImageKit                  | `provideImageKitLoader`   | [Документация](https://docs.imagekit.io/)                                  |
| Imgix                     | `provideImgixLoader`      | [Документация](https://docs.imgix.com/)                                    |
| Netlify                   | `provideNetlifyLoader`    | [Документация](https://docs.netlify.com/image-cdn/overview/)               |

Для использования **универсального загрузчика** никаких дополнительных изменений кода не требуется. Это поведение по
умолчанию.

### Встроенные загрузчики {#built-in-loaders}

Чтобы использовать существующий загрузчик для **стороннего сервиса изображений**, добавьте фабрику провайдера для
выбранного вами сервиса в массив `providers`. В примере ниже используется загрузчик Imgix:

```ts
providers: [
  provideImgixLoader('https://my.base.url/'),
],
```

Базовый URL для ваших ресурсов изображений должен быть передан фабрике провайдера в качестве аргумента. Для большинства
сайтов этот базовый URL должен соответствовать одному из следующих шаблонов:

- <https://yoursite.yourcdn.com>
- <https://subdomain.yoursite.com>
- <https://subdomain.yourcdn.com/yoursite>

Вы можете узнать больше о структуре базового URL в документации соответствующего CDN-провайдера.

### Пользовательские загрузчики {#custom-loaders}

Чтобы использовать **пользовательский загрузчик**, предоставьте функцию загрузчика в качестве значения для DI-токена
`IMAGE_LOADER`. В примере ниже функция пользовательского загрузчика возвращает URL, начинающийся с
`https://example.com`, который включает `src` и `width` в качестве параметров URL.

```ts
providers: [
  {
    provide: IMAGE_LOADER,
    useValue: (config: ImageLoaderConfig) => {
      return `https://example.com/images?src=${config.src}&width=${config.width}`;
    },
  },
],
```

Функция загрузчика для директивы `NgOptimizedImage` принимает объект с типом `ImageLoaderConfig` (из `@angular/common`)
в качестве аргумента и возвращает абсолютный URL ресурса изображения. Объект `ImageLoaderConfig` содержит свойство `src`
и необязательные свойства `width` и `loaderParams`.

ПРИМЕЧАНИЕ: даже если свойство `width` может не всегда присутствовать, пользовательский загрузчик должен использовать
его для поддержки запроса изображений различной ширины, чтобы `ngSrcset` работал правильно.

### Свойство `loaderParams` {#the-loaderparams-property}

Существует дополнительный атрибут, поддерживаемый директивой `NgOptimizedImage`, называемый `loaderParams`, который
специально разработан для поддержки использования пользовательских загрузчиков. Атрибут `loaderParams` принимает объект
с любыми свойствами в качестве значения и сам по себе ничего не делает. Данные в `loaderParams` добавляются в объект
`ImageLoaderConfig`, передаваемый вашему пользовательскому загрузчику, и могут использоваться для управления поведением
загрузчика.

Обычное использование `loaderParams` — управление расширенными функциями CDN изображений.

### Пример пользовательского загрузчика

Ниже показан пример функции пользовательского загрузчика. Эта примерная функция объединяет `src` и `width` и использует
`loaderParams` для управления пользовательской функцией CDN для закругленных углов:

```ts
const myCustomLoader = (config: ImageLoaderConfig) => {
  let url = `https://example.com/images/${config.src}?`;
  let queryParams = [];
  if (config.width) {
    queryParams.push(`w=${config.width}`);
  }
  if (config.loaderParams?.roundedCorners) {
    queryParams.push('mask=corners&corner-radius=5');
  }
  return url + queryParams.join('&');
};
```

Обратите внимание, что в приведенном выше примере мы придумали имя свойства 'roundedCorners' для управления функцией
нашего пользовательского загрузчика. Затем мы могли бы использовать эту функцию при создании изображения следующим
образом:

```html

<img ngSrc="profile.jpg" width="300" height="300" [loaderParams]="{roundedCorners: true}">

```

## Часто задаваемые вопросы

### Поддерживает ли NgOptimizedImage CSS-свойство `background-image`?

NgOptimizedImage не поддерживает напрямую CSS-свойство `background-image`, но она разработана так, чтобы легко
приспособить вариант использования, когда изображение является фоном другого элемента.

Пошаговый процесс миграции с `background-image` на `NgOptimizedImage` см. в
разделе [Как перенести фоновое изображение](#how-to-migrate-your-background-image) выше.

### Почему я не могу использовать `src` с `NgOptimizedImage`?

Атрибут `ngSrc` был выбран в качестве триггера для NgOptimizedImage из-за технических соображений, касающихся того, как
изображения загружаются браузером. NgOptimizedImage вносит программные изменения в атрибут `loading` — если браузер
увидит атрибут `src` до того, как эти изменения будут внесены, он начнет жадно (eagerly) загружать файл изображения, и
изменения загрузки будут проигнорированы.

### Почему для домена моего изображения не генерируется элемент preconnect? {#why-is-a-preconnect-element-not-being-generated-for-my-image-domain}

Генерация preconnect выполняется на основе статического анализа вашего приложения. Это означает, что домен изображения
должен быть непосредственно включен в параметр загрузчика, как в следующем примере:

```ts
providers: [
  provideImgixLoader('https://my.base.url/'),
],
```

Если вы используете переменную для передачи строки домена в загрузчик или не используете загрузчик, статический анализ
не сможет идентифицировать домен, и ссылка preconnect не будет сгенерирована. В этом случае вам следует вручную добавить
ссылку preconnect в заголовок документа, как [описано выше](#add-resource-hints).

### Могу ли я использовать два разных домена изображений на одной странице?

Паттерн провайдера [загрузчиков изображений](#configuring-an-image-loader-for-ngoptimizedimage) разработан так, чтобы
быть максимально простым для обычного случая использования только одного CDN изображений внутри компонента. Однако
вполне возможно управлять несколькими CDN изображений, используя один провайдер.

Для этого мы рекомендуем написать [пользовательский загрузчик изображений](#custom-loaders), который
использует [свойство `loaderParams`](#the-loaderparams-property) для передачи флага, указывающего, какой CDN изображений
следует использовать, а затем вызывает соответствующий загрузчик на основе этого флага.

### Можете ли вы добавить новый встроенный загрузчик для моего предпочтительного CDN?

По причинам поддержки мы в настоящее время не планируем поддерживать дополнительные встроенные загрузчики в репозитории
Angular. Вместо этого мы призываем разработчиков публиковать любые дополнительные загрузчики изображений в виде
сторонних пакетов.

### Могу ли я использовать это с тегом `<picture>`

Нет, но это есть в нашей дорожной карте, так что следите за обновлениями.

Если вы ждете эту функцию, пожалуйста, проголосуйте за проблему на
Github [здесь](https://github.com/angular/angular/issues/56594).

### Как найти мое LCP-изображение с помощью Chrome DevTools?

1. Используя вкладку Performance в Chrome DevTools, нажмите кнопку "start profiling and reload page" (начать
   профилирование и перезагрузить страницу) в левом верхнем углу. Она выглядит как значок обновления страницы.

2. Это запустит снимок профилирования вашего приложения Angular.

3. Как только результат профилирования будет доступен, выберите "LCP" в разделе timings.

4. В панели внизу должна появиться сводная запись. Вы можете найти элемент LCP в строке "related node". Нажатие на него
   покажет элемент в панели Elements.

<img alt="LCP в Chrome DevTools" src="assets/images/guide/image-optimization/devtools-lcp.png">

ПРИМЕЧАНИЕ: Это идентифицирует элемент LCP только в пределах области просмотра страницы, которую вы тестируете. Также
рекомендуется использовать эмуляцию мобильных устройств для идентификации элемента LCP для экранов меньшего размера.
