# Введение в анимации Angular

ВАЖНО: Пакет `@angular/animations` теперь устарел (deprecated). Команда Angular рекомендует использовать нативный CSS с
`animate.enter` и `animate.leave` для анимаций во всем новом коде. Узнайте больше в
новом [руководстве по анимации enter и leave](guide/animations/enter-and-leave). Также
см. [Миграция с пакета Angular Animations](guide/animations/migration), чтобы узнать, как начать перенос ваших
приложений на чистые CSS-анимации.

Анимация создает иллюзию движения: HTML-элементы меняют стиль с течением времени.
Хорошо спроектированные анимации могут сделать ваше приложение более увлекательным и простым в использовании, но они
нужны не только для красоты.
Анимации могут улучшить ваше приложение и пользовательский опыт (UX) несколькими способами:

- Без анимации переходы на веб-странице могут казаться резкими и неожиданными.
- Движение значительно улучшает пользовательский опыт, поэтому анимации дают пользователям возможность заметить реакцию
  приложения на их действия.
- Хорошие анимации интуитивно привлекают внимание пользователя туда, где это необходимо.

Обычно анимации включают несколько _трансформаций_ стиля во времени.
HTML-элемент может двигаться, менять цвет, увеличиваться или уменьшаться, исчезать или соскальзывать со страницы.
Эти изменения могут происходить одновременно или последовательно. Вы можете управлять временем каждой трансформации.

Система анимации Angular построена на функциональности CSS, что означает, что вы можете анимировать любое свойство,
которое браузер считает анимируемым.
Сюда входят позиции, размеры, трансформации, цвета, границы и многое другое.
W3C поддерживает список анимируемых свойств на странице [CSS Transitions](https://www.w3.org/TR/css-transitions-1).

## Об этом руководстве

В этом руководстве рассматриваются основные возможности анимации Angular, которые помогут вам начать добавлять анимации
Angular в ваш проект.

## Начало работы

Основными модулями Angular для анимации являются `@angular/animations` и `@angular/platform-browser`.

Чтобы начать добавлять анимации Angular в ваш проект, импортируйте модули, специфичные для анимации, вместе со
стандартной функциональностью Angular.

<docs-workflow>
<docs-step title="Включение модуля анимации">
Импортируйте `provideAnimationsAsync` из `@angular/platform-browser/animations/async` и добавьте его в список провайдеров в вызове функции `bootstrapApplication`.

<docs-code header="Enabling Animations" language="ts" linenums>
bootstrapApplication(AppComponent, {
  providers: [
    provideAnimationsAsync(),
  ]
});
</docs-code>

<docs-callout important title="Если вам нужны немедленные анимации в вашем приложении">
  Если вам нужно, чтобы анимация происходила сразу же при загрузке приложения,
  вам следует переключиться на модуль анимации с жадной (eager) загрузкой. Импортируйте `provideAnimations`
  из `@angular/platform-browser/animations` и используйте `provideAnimations` **вместо**
  `provideAnimationsAsync` в вызове функции `bootstrapApplication`.
</docs-callout>

Для приложений на основе `NgModule` импортируйте `BrowserAnimationsModule`, который добавляет возможности анимации в
корневой модуль вашего приложения Angular.

<docs-code header="app.module.ts" path="adev/src/content/examples/animations/src/app/app.module.1.ts"/>
</docs-step>
<docs-step title="Импорт функций анимации в файлы компонентов">
Если вы планируете использовать конкретные функции анимации в файлах компонентов, импортируйте эти функции из `@angular/animations`.

<docs-code header="app.component.ts" path="adev/src/content/examples/animations/src/app/app.component.ts" region="imports"/>

См. все [доступные функции анимации](guide/legacy-animations#animations-api-summary) в конце этого руководства.

</docs-step>
<docs-step title="Добавление свойства метаданных анимации">
В файле компонента добавьте свойство метаданных с именем `animations:` внутри декоратора `@Component()`.
Триггер, определяющий анимацию, помещается внутри свойства метаданных `animations`.

<docs-code header="app.component.ts" path="adev/src/content/examples/animations/src/app/app.component.ts" region="decorator"/>
</docs-step>
</docs-workflow>

## Анимация перехода

Давайте анимируем переход, который меняет один HTML-элемент из одного состояния в другое.
Например, можно указать, что кнопка отображает либо **Open**, либо **Closed** в зависимости от последнего действия
пользователя.
Когда кнопка находится в состоянии `open`, она видима и желтого цвета.
Когда она в состоянии `closed`, она полупрозрачная и синяя.

В HTML эти атрибуты задаются с использованием обычных CSS-стилей, таких как цвет и прозрачность.
В Angular используйте функцию `style()` для указания набора CSS-стилей для использования с анимациями.
Соберите набор стилей в состояние анимации и дайте состоянию имя, например `open` или `closed`.

HELPFUL: Давайте создадим новый компонент `open-close` для анимации с простыми переходами.

Запустите следующую команду в терминале, чтобы сгенерировать компонент:

```shell
ng g component open-close
```

Это создаст компонент по пути `src/app/open-close.component.ts`.

### Состояние анимации и стили

Используйте функцию Angular [`state()`](api/animations/state) для определения различных состояний, вызываемых в конце
каждого перехода.
Эта функция принимает два аргумента:
Уникальное имя, например `open` или `closed`, и функцию `style()`.

Используйте функцию `style()` для определения набора стилей, связанных с данным именем состояния.
Вы должны использовать _camelCase_ для атрибутов стиля, содержащих дефисы, таких как `backgroundColor`, или заключать их
в кавычки, например `'background-color'`.

Давайте посмотрим, как функция Angular [`state()`](api/animations/state) работает с функцией `style⁣­(⁠)`, устанавливая
атрибуты стиля CSS.
В этом фрагменте кода для состояния устанавливается несколько атрибутов стиля одновременно.
В состоянии `open` кнопка имеет высоту 200 пикселей, прозрачность 1 и желтый цвет фона.

<docs-code header="open-close.component.ts" path="adev/src/content/examples/animations/src/app/open-close.component.ts" region="state1"/>

В следующем состоянии `closed` кнопка имеет высоту 100 пикселей, прозрачность 0.8 и синий цвет фона.

<docs-code header="open-close.component.ts" path="adev/src/content/examples/animations/src/app/open-close.component.ts" region="state2"/>

### Переходы и тайминг

В Angular вы можете устанавливать несколько стилей без какой-либо анимации.
Однако без дальнейшей доработки кнопка трансформируется мгновенно, без затухания, уменьшения или другого видимого
индикатора того, что происходит изменение.

Чтобы сделать изменение менее резким, нужно определить _переход_ (transition) анимации, чтобы указать изменения,
происходящие между одним состоянием и другим в течение определенного периода времени.
Функция `transition()` принимает два аргумента:
Первый аргумент принимает выражение, определяющее направление между двумя состояниями перехода, а второй аргумент
принимает один или серию шагов `animate()`.

Используйте функцию `animate()` для определения длительности, задержки и плавности (easing) перехода, а также для
назначения функции стиля для определения стилей во время выполнения переходов.
Используйте функцию `animate()` для определения функции `keyframes()` для многоступенчатых анимаций.
Эти определения помещаются во второй аргумент функции `animate()`.

#### Метаданные анимации: длительность, задержка и плавность

Функция `animate()` (второй аргумент функции transition) принимает входные параметры `timings` и `styles`.

Параметр `timings` принимает либо число, либо строку, определенную из трех частей.

<docs-code language="typescript">

animate (duration)

</docs-code>

или

<docs-code language="typescript">

animate ('duration delay easing')

</docs-code>

Первая часть, `duration` (длительность), обязательна.
Длительность может быть выражена в миллисекундах как число без кавычек или в секундах с кавычками и спецификатором
времени.
Например, длительность в одну десятую секунды может быть выражена следующим образом:

- Как простое число, в миллисекундах:
  `100`

- В строке, как миллисекунды:
  `'100ms'`

- В строке, как секунды:
  `'0.1s'`

Второй аргумент, `delay` (задержка), имеет тот же синтаксис, что и `duration`.
Например:

- Подождать 100мс, а затем запустить на 200мс: `'0.2s 100ms'`

Третий аргумент, `easing` (плавность), управляет тем, как анимация [ускоряется и замедляется](https://easings.net) во
время выполнения.
Например, `ease-in` заставляет анимацию начинаться медленно и набирать скорость по мере выполнения.

- Подождать 100мс, запустить на 200мс.
  Использовать кривую замедления, чтобы начать быстро и медленно замедлиться до точки покоя:
  `'0.2s 100ms ease-out'`

- Запустить на 200мс, без задержки.
  Использовать стандартную кривую, чтобы начать медленно, ускориться в середине и затем медленно замедлиться в конце:
  `'0.2s ease-in-out'`

- Начать немедленно, запустить на 200мс.
  Использовать кривую ускорения, чтобы начать медленно и закончить на полной скорости:
  `'0.2s ease-in'`

HELPFUL: См. тему на веб-сайте Material Design
о [Естественных кривых плавности](https://material.io/design/motion/speed.html#easing) для получения общей информации о
кривых плавности.

Этот пример обеспечивает переход состояния из `open` в `closed` с 1-секундным переходом между состояниями.

<docs-code header="open-close.component.ts" path="adev/src/content/examples/animations/src/app/open-close.component.ts" region="transition1"/>

В предыдущем фрагменте кода оператор `=>` указывает на однонаправленные переходы, а `<=>` — на двунаправленные.
Внутри перехода `animate()` указывает, сколько времени занимает переход.
В данном случае изменение состояния с `open` на `closed` занимает 1 секунду, выраженную здесь как `1s`.

Этот пример добавляет переход состояния из состояния `closed` в состояние `open` с дугой анимации перехода в 0.5
секунды.

<docs-code header="open-close.component.ts" path="adev/src/content/examples/animations/src/app/open-close.component.ts" region="transition2"/>

HELPFUL: Некоторые дополнительные замечания по использованию стилей внутри функций [`state`](api/animations/state) и
`transition`.

- Используйте [`state()`](api/animations/state) для определения стилей, которые применяются в конце каждого перехода;
  они сохраняются после завершения анимации.
- Используйте `transition()` для определения промежуточных стилей, которые создают иллюзию движения во время анимации.
- Когда анимации отключены, стили `transition()` могут быть пропущены, но стили [`state()`](api/animations/state) — нет.
- Включайте несколько пар состояний в один аргумент `transition()`:

    <docs-code language="typescript">

  transition( 'on => off, off => void' )

    </docs-code>

### Запуск анимации (Триггеры)

Анимации требуется _триггер_, чтобы она знала, когда начинаться.
Функция `trigger()` собирает состояния и переходы и дает анимации имя, чтобы вы могли прикрепить ее к запускающему
элементу в HTML-шаблоне.

Функция `trigger()` описывает имя свойства, за изменениями которого нужно следить.
Когда происходит изменение, триггер инициирует действия, включенные в его определение.
Этими действиями могут быть переходы или другие функции, как мы увидим позже.

В этом примере мы назовем триггер `openClose` и прикрепим его к элементу `button`.
Триггер описывает открытое и закрытое состояния, а также тайминги для двух переходов.

HELPFUL: В рамках каждого вызова функции `trigger()` элемент может находиться только в одном состоянии в любой момент
времени.
Однако возможно одновременное использование нескольких активных триггеров.

### Определение анимаций и прикрепление их к HTML-шаблону

Анимации определяются в метаданных компонента, который управляет анимируемым HTML-элементом.
Поместите код, определяющий ваши анимации, в свойство `animations:` внутри декоратора `@Component()`.

<docs-code header="open-close.component.ts" path="adev/src/content/examples/animations/src/app/open-close.component.ts" region="component"/>

Когда вы определили триггер анимации для компонента, прикрепите его к элементу в шаблоне этого компонента, заключив имя
триггера в квадратные скобки и поставив перед ним символ `@`.
Затем вы можете привязать триггер к выражению шаблона, используя стандартный синтаксис привязки свойств Angular, как
показано ниже, где `triggerName` — это имя триггера, а `expression` вычисляется в определенное состояние анимации.

<docs-code language="typescript">

<div [@triggerName]="expression">…</div>;

</docs-code>

Анимация выполняется или запускается, когда значение выражения меняется на новое состояние.

Следующий фрагмент кода привязывает триггер к значению свойства `isOpen`.

<docs-code header="open-close.component.html" path="adev/src/content/examples/animations/src/app/open-close.component.1.html" region="trigger"/>

В этом примере, когда выражение `isOpen` вычисляется в определенное состояние `open` или `closed`, оно уведомляет
триггер `openClose` об изменении состояния.
Затем код `openClose` должен обработать изменение состояния и запустить анимацию смены состояния.

Для элементов, входящих на страницу или покидающих ее (вставляемых или удаляемых из DOM), вы можете сделать анимации
условными.
Например, используйте `*ngIf` с триггером анимации в HTML-шаблоне.

HELPFUL: В файле компонента установите триггер, определяющий анимации, в качестве значения свойства `animations:` в
декораторе `@Component()`.

В файле HTML-шаблона используйте имя триггера, чтобы прикрепить определенные анимации к анимируемому HTML-элементу.

### Обзор кода

Вот файлы кода, обсуждаемые в примере с переходом.

<docs-code-multifile>
    <docs-code header="open-close.component.ts" path="adev/src/content/examples/animations/src/app/open-close.component.ts" region="component"/>
    <docs-code header="open-close.component.html" path="adev/src/content/examples/animations/src/app/open-close.component.1.html" region="trigger"/>
    <docs-code header="open-close.component.css" path="adev/src/content/examples/animations/src/app/open-close.component.css"/>
</docs-code-multifile>

### Резюме

Вы научились добавлять анимацию к переходу между двумя состояниями, используя `style()` и [
`state()`](api/animations/state) вместе с `animate()` для тайминга.

Узнайте о более продвинутых функциях анимации Angular в разделе "Анимация", начиная с передовых методов
в [переходах и триггерах](guide/legacy-animations/transition-and-triggers).

## Сводка API анимаций

Функциональный API, предоставляемый модулем `@angular/animations`, обеспечивает предметно-ориентированный язык (DSL) для
создания и управления анимациями в приложениях Angular.
См. [справочник API](api#animations) для полного списка и деталей синтаксиса основных функций и связанных структур
данных.

| Имя функции                       | Что делает                                                                                                                                                                                                                           |
| :-------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `trigger()`                       | Запускает анимацию и служит контейнером для всех остальных вызовов функций анимации. HTML-шаблон привязывается к `triggerName`. Используйте первый аргумент для объявления уникального имени триггера. Использует синтаксис массива. |
| `style()`                         | Определяет один или несколько CSS-стилей для использования в анимациях. Управляет визуальным внешним видом HTML-элементов во время анимации. Использует синтаксис объекта.                                                           |
| [`state()`](api/animations/state) | Создает именованный набор CSS-стилей, которые должны применяться при успешном переходе в данное состояние. Затем на состояние можно ссылаться по имени внутри других функций анимации.                                               |
| `animate()`                       | Указывает информацию о тайминге для перехода. Необязательные значения для `delay` и `easing`. Может содержать вызовы `style()` внутри.                                                                                               |
| `transition()`                    | Определяет последовательность анимации между двумя именованными состояниями. Использует синтаксис массива.                                                                                                                           |
| `keyframes()`                     | Позволяет последовательно менять стили в течение заданного интервала времени. Используется внутри `animate()`. Может включать несколько вызовов `style()` внутри каждого `keyframe()`. Использует синтаксис массива.                 |
| [`group()`](api/animations/group) | Указывает группу шагов анимации (_внутренние анимации_), которые должны выполняться параллельно. Анимация продолжается только после завершения всех внутренних шагов анимации. Используется внутри `sequence()` или `transition()`.  |
| `query()`                         | Находит один или несколько внутренних HTML-элементов внутри текущего элемента.                                                                                                                                                       |
| `sequence()`                      | Указывает список шагов анимации, которые выполняются последовательно, один за другим.                                                                                                                                                |
| `stagger()`                       | Смещает время начала анимации для нескольких элементов.                                                                                                                                                                              |
| `animation()`                     | Создает переиспользуемую анимацию, которую можно вызывать из других мест. Используется вместе с `useAnimation()`.                                                                                                                    |
| `useAnimation()`                  | Активирует переиспользуемую анимацию. Используется с `animation()`.                                                                                                                                                                  |
| `animateChild()`                  | Позволяет анимациям дочерних компонентов выполняться в том же временном интервале, что и родительская.                                                                                                                               |

</table>

## Дополнительно об анимациях Angular

HELPFUL: Посмотрите эту [презентацию](https://www.youtube.com/watch?v=rnTK9meY5us), показанную на конференции
AngularConnect в ноябре 2017 года, и сопроводительный [исходный код](https://github.com/matsko/animationsftw.in).

Вас также может заинтересовать следующее:

<docs-pill-row>
  <docs-pill href="guide/legacy-animations/transition-and-triggers" title="Переходы и триггеры"/>
  <docs-pill href="guide/legacy-animations/complex-sequences" title="Сложные последовательности анимации"/>
  <docs-pill href="guide/legacy-animations/reusable-animations" title="Переиспользуемые анимации"/>
  <docs-pill href="guide/routing/route-transition-animations" title="Анимации перехода маршрутов"/>
  <docs-pill href="guide/animations/migration" title="Миграция на нативные CSS-анимации"/>
</docs-pill-row>
