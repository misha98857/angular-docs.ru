# Сложные последовательности анимации

IMPORTANT: Пакет `@angular/animations` теперь устарел. Команда Angular рекомендует использовать нативный CSS с `animate.enter` и `animate.leave` для анимации во всем новом коде. Узнайте больше в новом руководстве по анимации [входа и выхода](guide/animations/enter-and-leave). Также ознакомьтесь с руководством [Миграция с пакета Angular Animations](guide/animations/migration), чтобы узнать, как начать перенос ваших приложений на чистые CSS-анимации.

До сих пор мы изучали простые анимации отдельных HTML-элементов.
Angular также позволяет анимировать скоординированные последовательности, такие как целая сетка или список элементов, когда они появляются на странице или покидают её.
Вы можете выбрать параллельный запуск нескольких анимаций или запускать отдельные анимации последовательно, одну за другой.

Функции, управляющие сложными последовательностями анимации:

| Функции                           | Подробности                                                               |
| :-------------------------------- | :------------------------------------------------------------------------ |
| `query()`                         | Находит один или несколько внутренних HTML-элементов.                     |
| `stagger()`                       | Применяет каскадную задержку к анимациям для нескольких элементов.        |
| [`group()`](api/animations/group) | Запускает несколько шагов анимации параллельно.                           |
| `sequence()`                      | Запускает шаги анимации один за другим.                                   |

## Функция query()

Большинство сложных анимаций полагаются на функцию `query()` для поиска дочерних элементов и применения к ним анимации. Основные примеры:

| Примеры                                | Подробности                                                                                                                                                                                                                                                            |
| :------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `query()` с последующим `animate()`    | Используется для запроса простых HTML-элементов и непосредственного применения к ним анимации.                                                                                                                                                                         |
| `query()` с последующим `animateChild()` | Используется для запроса дочерних элементов, к которым уже применены метаданные анимации, и запуска такой анимации (которая в противном случае была бы заблокирована анимацией текущего/родительского элемента). |

Первым аргументом `query()` является строка [CSS-селектора](https://developer.mozilla.org/docs/Web/CSS/CSS_Selectors), которая также может содержать следующие специфичные для Angular токены:

| Токены                     | Подробности                                                  |
| :------------------------- | :----------------------------------------------------------- |
| `:enter` <br /> `:leave`   | Для входящих/покидающих элементов.                           |
| `:animating`               | Для элементов, которые в данный момент анимируются.          |
| `@*` <br /> `@triggerName` | Для элементов с любым — или конкретным — триггером.          |
| `:self`                    | Сам анимируемый элемент.                                     |

<docs-callout title="Входящие и покидающие элементы">

Не все дочерние элементы фактически считаются входящими/покидающими; иногда это может быть неинтуитивным и сбивающим с толку. Пожалуйста, ознакомьтесь с [документацией API query](api/animations/query#entering-and-leaving-elements) для получения дополнительной информации.

Вы также можете увидеть иллюстрацию этого в примере анимации (представленном в [разделе введения](guide/legacy-animations#about-this-guide)) на вкладке Querying.

</docs-callout>

## Анимация нескольких элементов с использованием функций query() и stagger()

После запроса дочерних элементов через `query()`, функция `stagger()` позволяет определить временной интервал между каждым анимируемым элементом, тем самым анимируя элементы с задержкой между ними.

Следующий пример демонстрирует, как использовать функции `query()` и `stagger()` для анимации списка (героев), добавляя каждый элемент последовательно, с небольшой задержкой, сверху вниз.

- Используйте `query()` для поиска элемента, входящего на страницу и соответствующего определенным критериям.
- Для каждого из этих элементов используйте `style()`, чтобы задать одинаковый начальный стиль.
  Сделайте его прозрачным и используйте `transform`, чтобы сместить его с позиции, чтобы он мог "въехать" на место.

- Используйте `stagger()` для задержки каждой анимации на 30 миллисекунд.
- Анимируйте каждый элемент на экране в течение 0.5 секунды, используя специально определенную кривую плавности (easing curve), одновременно увеличивая его непрозрачность и возвращая трансформацию в исходное состояние.

<docs-code header="hero-list-page.component.ts" path="adev/src/content/examples/animations/src/app/hero-list-page.component.ts" region="page-animations"/>

## Параллельная анимация с использованием функции group()

Вы видели, как добавить задержку между каждой последующей анимацией.
Но вы также можете захотеть настроить анимации, которые происходят параллельно.
Например, вы можете захотеть анимировать два CSS-свойства одного и того же элемента, но использовать разные функции плавности (`easing`) для каждого из них.
Для этого можно использовать функцию анимации [`group()`](api/animations/group).

HELPFUL: Функция [`group()`](api/animations/group) используется для группировки *шагов* анимации, а не анимируемых элементов.

В следующем примере используются [`group()`](api/animations/group) как для `:enter`, так и для `:leave` с двумя разными настройками времени, тем самым применяя две независимые анимации к одному и тому же элементу параллельно.

<docs-code header="hero-list-groups.component.ts (excerpt)" path="adev/src/content/examples/animations/src/app/hero-list-groups.component.ts" region="animationdef"/>

## Последовательные и параллельные анимации

В сложных анимациях может происходить много событий одновременно.
Но что, если вы хотите создать анимацию, включающую несколько анимаций, происходящих одна за другой? Ранее вы использовали [`group()`](api/animations/group) для запуска нескольких анимаций одновременно, параллельно.

Вторая функция, называемая `sequence()`, позволяет запускать те же анимации одну за другой.
Внутри `sequence()` шаги анимации состоят из вызовов функций `style()` или `animate()`.

- Используйте `style()` для немедленного применения предоставленных данных стилизации.
- Используйте `animate()` для применения данных стилизации в течение заданного интервала времени.

## Пример анимации фильтра

Взгляните на другую анимацию на странице примера.
На вкладке Filter/Stagger введите текст в текстовое поле **Search Heroes**, например `Magnet` или `tornado`.

Фильтр работает в реальном времени по мере ввода.
Элементы покидают страницу по мере ввода каждой новой буквы, и фильтр становится все более строгим.
Список героев постепенно возвращается на страницу по мере удаления каждой буквы в поле фильтра.

HTML-шаблон содержит триггер под названием `filterAnimation`.

<docs-code header="hero-list-page.component.html" path="adev/src/content/examples/animations/src/app/hero-list-page.component.html" region="filter-animations" language="angular-html"/>

`filterAnimation` в декораторе компонента содержит три перехода (transitions).

<docs-code header="hero-list-page.component.ts" path="adev/src/content/examples/animations/src/app/hero-list-page.component.ts" region="filter-animations"/>

Код в этом примере выполняет следующие задачи:

- Пропускает анимацию, когда пользователь впервые открывает или переходит на эту страницу (анимация фильтра сужает то, что уже есть, поэтому она работает только с элементами, которые уже существуют в DOM).
- Фильтрует героев на основе значения поискового ввода.

Для каждого изменения:

- Скрывает элемент, покидающий DOM, устанавливая его непрозрачность и ширину в 0.
- Анимирует элемент, входящий в DOM, в течение 300 миллисекунд.
  Во время анимации элемент принимает свою ширину и непрозрачность по умолчанию.

- Если в DOM входит или покидает его несколько элементов, применяется каскадная задержка (stagger) для каждой анимации, начиная с верхней части страницы, с задержкой 50 миллисекунд между каждым элементом.

## Анимация элементов переупорядочиваемого списка

Хотя Angular корректно анимирует элементы списка `*ngFor` "из коробки", он не сможет сделать это, если их порядок изменится.
Это происходит потому, что он теряет отслеживание того, какой элемент является каким, что приводит к поломке анимации.
Единственный способ помочь Angular отслеживать такие элементы — назначить `TrackByFunction` директиве `NgForOf`.
Это гарантирует, что Angular всегда знает, какой элемент является каким, что позволяет ему всегда применять правильные анимации к правильным элементам.

IMPORTANT: Если вам нужно анимировать элементы списка `*ngFor` и существует вероятность того, что порядок таких элементов изменится во время выполнения, всегда используйте `TrackByFunction`.

## Анимации и инкапсуляция вида компонента (View Encapsulation)

Анимации Angular основаны на DOM-структуре компонентов и не учитывают напрямую [инкапсуляцию вида](guide/components/styling#style-scoping). Это означает, что компоненты, использующие `ViewEncapsulation.Emulated`, ведут себя точно так же, как если бы они использовали `ViewEncapsulation.None` (`ViewEncapsulation.ShadowDom` и `ViewEncapsulation.ExperimentalIsolatedShadowDom` ведут себя иначе, как мы обсудим далее).

Например, если функция `query()` (которую вы будете часто видеть в остальной части руководства по анимации) будет применена в верхней части дерева компонентов, использующих эмулированную инкапсуляцию вида, такой запрос сможет идентифицировать (и, следовательно, анимировать) DOM-элементы на любой глубине дерева.

С другой стороны, `ViewEncapsulation.ShadowDom` и `ViewEncapsulation.ExperimentalIsolatedShadowDom` изменяют DOM-структуру компонента, "скрывая" DOM-элементы внутри элементов [`ShadowRoot`](https://developer.mozilla.org/docs/Web/API/ShadowRoot). Такие манипуляции с DOM мешают правильной работе некоторых реализаций анимации, поскольку они полагаются на простые структуры DOM и не учитывают элементы `ShadowRoot`. Поэтому рекомендуется избегать применения анимации к представлениям, включающим компоненты, использующие инкапсуляцию вида ShadowDom.

## Сводка по последовательностям анимации

Функции Angular для анимации нескольких элементов начинаются с `query()` для поиска внутренних элементов; например, сбора всех изображений внутри `<div>`.
Остальные функции, `stagger()`, [`group()`](api/animations/group) и `sequence()`, применяют каскады или позволяют управлять тем, как применяются несколько шагов анимации.

## Подробнее об анимациях Angular

Вас также может заинтересовать следующее:

<docs-pill-row>
  <docs-pill href="guide/legacy-animations" title="Введение в анимации Angular"/>
  <docs-pill href="guide/legacy-animations/transition-and-triggers" title="Переходы и триггеры"/>
  <docs-pill href="guide/legacy-animations/reusable-animations" title="Повторно используемые анимации"/>
  <docs-pill href="guide/routing/route-transition-animations" title="Анимации переходов маршрутов"/>
  <docs-pill href="guide/animations/migration" title="Миграция на нативные CSS-анимации"/>
</docs-pill-row>