# Обзор Angular Elements

_Angular Elements_ — это компоненты Angular, упакованные как _пользовательские элементы_ (custom elements), также
называемые Web Components (веб-компоненты). Это веб-стандарт для определения новых HTML-элементов независимым от
фреймворка способом.

[Пользовательские элементы](https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements) — это функция
веб-платформы, доступная во всех браузерах, поддерживаемых Angular.
Пользовательский элемент расширяет HTML, позволяя определить тег, содержимое которого создается и управляется кодом
JavaScript.
Браузер поддерживает `CustomElementRegistry` определенных пользовательских элементов, который сопоставляет создаваемый
JavaScript-класс с HTML-тегом.

Пакет `@angular/elements` экспортирует API `createCustomElement()`, который предоставляет мост от интерфейса компонентов
Angular и функциональности обнаружения изменений к встроенному DOM API.

Преобразование компонента в пользовательский элемент делает всю необходимую инфраструктуру Angular доступной браузеру.
Создание пользовательского элемента — это простой и понятный процесс, который автоматически связывает представление,
определенное компонентом, с обнаружением изменений и привязкой данных, сопоставляя функциональность Angular с
соответствующими встроенными эквивалентами HTML.

## Использование пользовательских элементов

Пользовательские элементы инициализируются самостоятельно — они запускаются при добавлении в DOM и уничтожаются при
удалении из него.
После добавления пользовательского элемента в DOM любой страницы он выглядит и ведет себя как любой другой HTML-элемент
и не требует специальных знаний терминов или соглашений об использовании Angular.

Чтобы добавить пакет `@angular/elements` в ваше рабочее пространство, выполните следующую команду:

<docs-code-multifile>
  <docs-code header="npm" language="shell">
    npm install @angular/elements
  </docs-code>
  <docs-code header="yarn" language="shell">
    yarn add @angular/elements
  </docs-code>
  <docs-code header="pnpm" language="shell">
    pnpm add @angular/elements
  </docs-code>
  <docs-code header="bun" language="shell">
    bun add @angular/elements
  </docs-code>
</docs-code-multifile>

### Как это работает

Функция `createCustomElement()` преобразует компонент в класс, который можно зарегистрировать в браузере как
пользовательский элемент.
После регистрации настроенного класса в реестре пользовательских элементов браузера, используйте новый элемент так же,
как встроенный HTML-элемент, в контенте, который вы добавляете непосредственно в DOM:

```html

<my-popup message="Use Angular!"></my-popup>

```

Когда ваш пользовательский элемент размещается на странице, браузер создает экземпляр зарегистрированного класса и
добавляет его в DOM.
Контент предоставляется шаблоном компонента, который использует синтаксис шаблонов Angular, и рендерится с
использованием данных компонента и DOM.
Input-свойства компонента соответствуют входным атрибутам элемента.

## Преобразование компонентов в пользовательские элементы

Angular предоставляет функцию `createCustomElement()` для преобразования компонента Angular вместе с его зависимостями в
пользовательский элемент.

Процесс преобразования реализует интерфейс `NgElementConstructor` и создает класс-конструктор, настроенный на создание
самоинициализирующегося экземпляра вашего компонента.

Используйте нативную функцию браузера [
`customElements.define()`](https://developer.mozilla.org/docs/Web/API/CustomElementRegistry/define) для регистрации
настроенного конструктора и связанного с ним тега пользовательского элемента в [
`CustomElementRegistry`](https://developer.mozilla.org/docs/Web/API/CustomElementRegistry).
Когда браузер встречает тег зарегистрированного элемента, он использует конструктор для создания экземпляра
пользовательского элемента.

ВАЖНО: Избегайте использования селектора компонента в качестве тега пользовательского элемента.
Это может привести к неожиданному поведению, так как Angular создаст два экземпляра компонента для одного DOM-элемента:
один обычный компонент Angular и второй, использующий пользовательский элемент.

### Сопоставление

Пользовательский элемент _хостит_ (содержит) компонент Angular, обеспечивая мост между данными и логикой, определенными
в компоненте, и стандартными API DOM.
Свойства и логика компонента напрямую сопоставляются с HTML-атрибутами и системой событий браузера.

- API создания анализирует компонент в поиске Input-свойств и определяет соответствующие атрибуты для пользовательского
  элемента.
  Он преобразует имена свойств для совместимости с пользовательскими элементами, которые не различают регистр.
  Результирующие имена атрибутов используют нижний регистр с разделением дефисами (kebab-case).
  Например, для компонента с `inputProp = input({alias: 'myInputProp'})`, соответствующий пользовательский элемент
  определяет атрибут `my-input-prop`.

- Output-свойства компонента отправляются как
  HTML [Custom Events](https://developer.mozilla.org/docs/Web/API/CustomEvent) (пользовательские события), при этом имя
  пользовательского события совпадает с именем Output-свойства.
  Например, для компонента с `valueChanged = output()`, соответствующий пользовательский элемент отправляет события с
  именем "valueChanged", а передаваемые данные сохраняются в свойстве `detail` события.
  Если вы укажете псевдоним, будет использовано это значение; например, `clicks = output<string>({alias: 'myClick'});`
  приведет к отправке событий с именем "myClick".

Для получения дополнительной информации см. документацию Web Component
по [созданию пользовательских событий](https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events).

## Пример: Сервис Popup

Раньше, если вы хотели добавить компонент в приложение во время выполнения, вам приходилось определять _динамический
компонент_, затем загружать его, прикреплять к элементу в DOM и настраивать все зависимости, обнаружение изменений и
обработку событий.

Использование пользовательского элемента Angular делает этот процесс проще и прозрачнее, автоматически предоставляя всю
инфраструктуру и фреймворк — все, что вам нужно сделать, это определить желаемую обработку событий.
(Вам все же придется исключить компонент из компиляции, если вы не собираетесь использовать его в своем приложении.)

Следующий пример приложения Popup Service определяет компонент, который можно загрузить динамически или преобразовать в
пользовательский элемент.

| Файлы                | Детали                                                                                                                                                                                                                                                          |
| :------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `popup.component.ts` | Определяет простой всплывающий элемент, который отображает входное сообщение, с анимацией и стилизацией.                                                                                                                                                        |
| `popup.service.ts`   | Создает внедряемый сервис, который предоставляет два разных способа вызова `PopupComponent`: как динамический компонент или как пользовательский элемент. Обратите внимание, насколько больше настройки требуется для метода динамической загрузки.             |
| `app.component.ts`   | Определяет корневой компонент приложения, который использует `PopupService` для добавления всплывающего окна в DOM во время выполнения. Когда приложение запускается, конструктор корневого компонента преобразует `PopupComponent` в пользовательский элемент. |

Для сравнения в демо показаны оба метода.
Одна кнопка добавляет всплывающее окно с использованием метода динамической загрузки, а другая использует
пользовательский элемент.
Результат одинаков, но подготовка отличается.

<docs-code-multifile>
    <docs-code header="popup.component.ts" path="adev/src/content/examples/elements/src/app/popup.component.ts"/>
    <docs-code header="popup.service.ts" path="adev/src/content/examples/elements/src/app/popup.service.ts"/>
    <docs-code header="app.component.ts" path="adev/src/content/examples/elements/src/app/app.component.ts"/>
</docs-code-multifile>

## Типизация для пользовательских элементов

Общие API DOM, такие как `document.createElement()` или `document.querySelector()`, возвращают тип элемента,
соответствующий указанным аргументам.
Например, вызов `document.createElement('a')` возвращает `HTMLAnchorElement`, и TypeScript знает, что у него есть
свойство `href`.
Аналогично, `document.createElement('div')` возвращает `HTMLDivElement`, у которого, как знает TypeScript, нет свойства
`href`.

При вызове с неизвестными элементами, такими как имя пользовательского элемента (`popup-element` в нашем примере),
методы возвращают общий тип, такой как `HTMLElement`, поскольку TypeScript не может вывести правильный тип возвращаемого
элемента.

Пользовательские элементы, созданные с помощью Angular, расширяют `NgElement` (который, в свою очередь, расширяет
`HTMLElement`).
Кроме того, эти пользовательские элементы будут иметь свойство для каждого Input-свойства соответствующего компонента.
Например, наш `popup-element` имеет свойство `message` типа `string`.

Есть несколько вариантов, если вы хотите получить правильные типы для ваших пользовательских элементов.
Предположим, вы создаете пользовательский элемент `my-dialog` на основе следующего компонента:

```ts

@Component(…)
class MyDialog {
  content =  input(string);
}

```

Самый простой способ получить точную типизацию — привести возвращаемое значение соответствующих методов DOM к
правильному типу.
Для этого используйте типы `NgElement` и `WithProperties` (оба экспортируются из `@angular/elements`):

```ts

const aDialog = document.createElement('my-dialog') as NgElement & WithProperties<{content: string}>;
aDialog.content = 'Hello, world!';
aDialog.content = 123; // <-- ОШИБКА: TypeScript знает, что это должна быть строка.
aDialog.body = 'News'; // <-- ОШИБКА: TypeScript знает, что у aDialog нет свойства body.

```

Это хороший способ быстро получить возможности TypeScript, такие как проверка типов и автодополнение, для вашего
пользовательского элемента.
Но это может стать обременительным, если вам нужно использовать его в нескольких местах, так как вам придется приводить
возвращаемый тип при каждом появлении.

Альтернативный способ, требующий определения типа каждого пользовательского элемента только один раз, — это расширение
`HTMLElementTagNameMap`, который TypeScript использует для вывода типа возвращаемого элемента на основе его имени тега (
для методов DOM, таких как `document.createElement()`, `document.querySelector()` и т. д.):

```ts

declare global {
  interface HTMLElementTagNameMap {
    'my-dialog': NgElement & WithProperties<{content: string}>;
    'my-other-element': NgElement & WithProperties<{foo: 'bar'}>;
    …
  }
}

```

Теперь TypeScript может выводить правильный тип так же, как он делает это для встроенных элементов:

```ts

document.createElement('div')               //--> HTMLDivElement (встроенный элемент)
document.querySelector('foo')               //--> Element        (неизвестный элемент)
document.createElement('my-dialog')         //--> NgElement & WithProperties<{content: string}> (пользовательский элемент)
document.querySelector('my-other-element')  //--> NgElement & WithProperties<{foo: 'bar'}>      (пользовательский элемент)

```

## Ограничения

Следует соблюдать осторожность при уничтожении и повторном присоединении пользовательских элементов, созданных с помощью
`@angular/elements`, из-за проблем с колбэком [disconnect()](https://github.com/angular/angular/issues/38778). Случаи,
когда вы можете столкнуться с этой проблемой:

- Рендеринг компонента внутри `ng-if` или `ng-repeat` в `AngularJs`
- Ручное отсоединение и повторное присоединение элемента к DOM
