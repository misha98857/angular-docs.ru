# Серверный и гибридный рендеринг

По умолчанию Angular поставляет все приложения с рендерингом на стороне клиента (CSR). Хотя этот подход обеспечивает
легковесную начальную загрузку, он влечет за собой компромиссы, включая более медленное время загрузки, ухудшение
показателей производительности и более высокие требования к ресурсам, поскольку устройство пользователя выполняет
большую часть вычислений. В результате многие приложения достигают значительного улучшения производительности за счет
интеграции рендеринга на стороне сервера (SSR) в стратегию гибридного рендеринга.

## Что такое гибридный рендеринг?

Гибридный рендеринг позволяет разработчикам использовать преимущества рендеринга на стороне сервера (SSR),
пре-рендеринга (также известного как «генерация статических сайтов» или SSG) и рендеринга на стороне клиента (CSR) для
оптимизации вашего Angular-приложения. Это дает вам тонкий контроль над тем, как рендерятся различные части вашего
приложения, чтобы обеспечить пользователям наилучший опыт.

## Настройка гибридного рендеринга

Вы можете создать **новый** проект с гибридным рендерингом, используя флаг рендеринга на стороне сервера (т.е. `--ssr`)
с командой Angular CLI `ng new`:

```shell
ng new --ssr
```

Вы также можете включить гибридный рендеринг, добавив рендеринг на стороне сервера в существующий проект с помощью
команды `ng add`:

```shell
ng add @angular/ssr
```

ПРИМЕЧАНИЕ: По умолчанию Angular выполняет пре-рендеринг всего приложения и генерирует серверный файл. Чтобы отключить
это и создать полностью статическое приложение, установите `outputMode` в значение `static`. Чтобы включить SSR,
обновите серверные маршруты для использования `RenderMode.Server`. Для получения более подробной информации см.
разделы [`Серверная маршрутизация`](#server-routing) и [
`Генерация полностью статического приложения`](#generate-a-fully-static-application).

## Серверная маршрутизация

### Настройка серверных маршрутов

Вы можете создать конфигурацию серверного маршрута, объявив массив объектов [
`ServerRoute`](api/ssr/ServerRoute 'API reference'). Эта конфигурация обычно находится в файле с именем
`app.routes.server.ts`.

```typescript
// app.routes.server.ts
import { RenderMode, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  {
    path: '', // Рендерит маршрут "/" на клиенте (CSR)
    renderMode: RenderMode.Client,
  },
  {
    path: 'about', // Эта страница статична, поэтому мы выполняем её пре-рендеринг (SSG)
    renderMode: RenderMode.Prerender,
  },
  {
    path: 'profile', // Эта страница требует пользовательских данных, поэтому используем SSR
    renderMode: RenderMode.Server,
  },
  {
    path: '**', // Все остальные маршруты будут отрендерены на сервере (SSR)
    renderMode: RenderMode.Server,
  },
];
```

Вы можете добавить эту конфигурацию в свое приложение с помощью [
`provideServerRendering`](api/ssr/provideServerRendering 'API reference'), используя функцию [
`withRoutes`](api/ssr/withRoutes 'API reference'):

```typescript
import { provideServerRendering, withRoutes } from '@angular/ssr';
import { serverRoutes } from './app.routes.server';

// app.config.server.ts
const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering(withRoutes(serverRoutes)),
    // ... другие провайдеры ...
  ]
};
```

При использовании [паттерна App shell](ecosystem/service-workers/app-shell) необходимо указать компонент, который будет
использоваться в качестве оболочки приложения (app shell) для маршрутов, рендерящихся на стороне клиента. Для этого
используйте функцию [`withAppShell`](api/ssr/withAppShell 'API reference'):

```typescript
import { provideServerRendering, withRoutes, withAppShell } from '@angular/ssr';
import { AppShellComponent } from './app-shell/app-shell.component';

const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering(
      withRoutes(serverRoutes),
      withAppShell(AppShellComponent),
    ),
    // ... другие провайдеры ...
  ]
};
```

### Режимы рендеринга

Конфигурация серверной маршрутизации позволяет указать, как должен рендериться каждый маршрут в вашем приложении,
установив [`RenderMode`](api/ssr/RenderMode 'API reference'):

| Режим рендеринга    | Описание                                                                                                     |
| ------------------- | ------------------------------------------------------------------------------------------------------------ |
| **Server (SSR)**    | Рендерит приложение на сервере для каждого запроса, отправляя в браузер полностью заполненную HTML-страницу. |
| **Client (CSR)**    | Рендерит приложение в браузере. Это стандартное поведение Angular.                                           |
| **Prerender (SSG)** | Выполняет пре-рендеринг приложения во время сборки, генерируя статические HTML-файлы для каждого маршрута.   |

#### Выбор режима рендеринга

Каждый режим рендеринга имеет свои преимущества и недостатки. Вы можете выбирать режимы рендеринга в зависимости от
конкретных потребностей вашего приложения.

##### Рендеринг на стороне клиента (CSR)

Рендеринг на стороне клиента имеет самую простую модель разработки, так как вы можете писать код, предполагая, что он
всегда выполняется в веб-браузере. Это позволяет использовать широкий спектр клиентских библиотек, которые также
предполагают запуск в браузере.

Рендеринг на стороне клиента, как правило, имеет худшую производительность по сравнению с другими режимами рендеринга,
поскольку он должен загрузить, распарсить и выполнить JavaScript вашей страницы, прежде чем пользователь увидит
какой-либо отрендеренный контент. Если ваша страница запрашивает дополнительные данные с сервера по мере рендеринга,
пользователям также приходится ждать выполнения этих дополнительных запросов, прежде чем они смогут увидеть полный
контент.

Если ваша страница индексируется поисковыми роботами, рендеринг на стороне клиента может негативно повлиять на поисковую
оптимизацию (SEO), так как у поисковых роботов есть ограничения на объем выполняемого JavaScript при индексации
страницы.

При рендеринге на стороне клиента серверу не нужно выполнять никакой работы для рендеринга страницы, кроме отдачи
статических JavaScript-ассетов. Вы можете учитывать этот фактор, если стоимость сервера является важным аспектом.

Приложения, поддерживающие устанавливаемый офлайн-режим с
помощью [Service Worker-ов](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API), могут полагаться на
рендеринг на стороне клиента без необходимости связи с сервером.

##### Рендеринг на стороне сервера (SSR)

Рендеринг на стороне сервера обеспечивает более быструю загрузку страниц, чем рендеринг на стороне клиента. Вместо
ожидания загрузки и запуска JavaScript, сервер напрямую рендерит HTML-документ при получении запроса от браузера.
Пользователь испытывает только задержку, необходимую серверу для получения данных и рендеринга запрошенной страницы.
Этот режим также устраняет необходимость в дополнительных сетевых запросах из браузера, так как ваш код может получать
данные во время рендеринга на сервере.

Рендеринг на стороне сервера, как правило, обеспечивает отличную поисковую оптимизацию (SEO), так как поисковые роботы
получают полностью отрендеренный HTML-документ.

Рендеринг на стороне сервера требует от вас написания кода, который не зависит строго от API браузера, и ограничивает
выбор JavaScript-библиотек, предполагающих запуск в браузере.

При рендеринге на стороне сервера ваш сервер запускает Angular для создания HTML-ответа на каждый запрос, что может
увеличить расходы на хостинг сервера.

##### Пре-рендеринг во время сборки (Build-time prerendering)

Пре-рендеринг обеспечивает более быструю загрузку страниц, чем как рендеринг на стороне клиента, так и рендеринг на
стороне сервера. Поскольку пре-рендеринг создает HTML-документы во время _сборки_ (build-time), сервер может напрямую
отвечать на запросы статическим HTML-документом без какой-либо дополнительной работы.

Пре-рендеринг требует, чтобы вся информация, необходимая для рендеринга страницы, была доступна во время _сборки_. Это
означает, что предварительно отрендеренные страницы не могут включать данные, специфичные для конкретного пользователя,
загружающего страницу. Пре-рендеринг в первую очередь полезен для страниц, которые одинаковы для всех пользователей
вашего приложения.

Поскольку пре-рендеринг происходит во время сборки, это может значительно увеличить время сборки для продакшена.
Использование [`getPrerenderParams`](api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams 'API reference') для
создания большого количества HTML-документов может повлиять на общий размер файлов ваших развертываний и, следовательно,
привести к более медленному развертыванию.

Пре-рендеринг, как правило, обеспечивает отличную поисковую оптимизацию (SEO), так как поисковые роботы получают
полностью отрендеренный HTML-документ.

Пре-рендеринг требует от вас написания кода, который не зависит строго от API браузера, и ограничивает выбор
JavaScript-библиотек, предполагающих запуск в браузере.

Пре-рендеринг создает крайне малую нагрузку на сервер при запросе, так как ваш сервер отвечает статическими
HTML-документами. Статические файлы также легко кэшируются сетями доставки контента (CDN), браузерами и промежуточными
слоями кэширования для еще более быстрой последующей загрузки страниц. Полностью статические сайты также могут быть
развернуты исключительно через CDN или статический файловый сервер, что устраняет необходимость в поддержке
пользовательской серверной среды выполнения для вашего приложения. Это повышает масштабируемость за счет снятия нагрузки
с веб-сервера приложения, что особенно полезно для приложений с высоким трафиком.

ПРИМЕЧАНИЕ: При использовании Angular Service Worker первый запрос рендерится на сервере, но все последующие запросы
обрабатываются Service Worker-ом и рендерятся на стороне клиента.

### Установка заголовков и кодов состояния

Вы можете установить пользовательские заголовки и коды состояния для отдельных серверных маршрутов, используя свойства
`headers` и `status` в конфигурации `ServerRoute`.

```typescript
// app.routes.server.ts
import { RenderMode, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  {
    path: 'profile',
    renderMode: RenderMode.Server,
    headers: {
      'X-My-Custom-Header': 'some-value',
    },
    status: 201,
  },
  // ... другие маршруты
];
```

### Перенаправления (Redirects)

Angular обрабатывает перенаправления, указанные свойством [`redirectTo`](api/router/Route#redirectTo 'API reference') в
конфигурации маршрута, по-разному на стороне сервера.

**Рендеринг на стороне сервера (SSR)**
Перенаправления выполняются с использованием стандартных HTTP-перенаправлений (например, 301, 302) в рамках процесса
серверного рендеринга.

**Пре-рендеринг (SSG)**
Перенаправления реализуются как «мягкие» перенаправления с использованием тегов [
`<meta http-equiv="refresh">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#refresh) в предварительно
отрендеренном HTML.

### Настройка пре-рендеринга во время сборки (SSG)

При использовании [`RenderMode.Prerender`](api/ssr/RenderMode#Prerender 'API reference') вы можете указать несколько
параметров конфигурации для настройки процесса пре-рендеринга и обслуживания.

#### Параметризованные маршруты

Для каждого маршрута с [`RenderMode.Prerender`](api/ssr/RenderMode#Prerender 'API reference') вы можете указать
функцию [`getPrerenderParams`](api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams 'API reference'). Эта функция
позволяет контролировать, какие конкретные параметры создают отдельные предварительно отрендеренные документы.

Функция [`getPrerenderParams`](api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams 'API reference') возвращает
`Promise`, который разрешается в массив объектов. Каждый объект представляет собой карту «имя параметра маршрута —
значение». Например, если вы определяете маршрут как `post/:id`, `getPrerenderParams` может вернуть массив
`[{id: 123}, {id: 456}]`, и таким образом отрендерить отдельные документы для `post/123` и `post/456`.

Тело функции [`getPrerenderParams`](api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams 'API reference') может
использовать функцию Angular [`inject`](api/core/inject 'API reference') для внедрения зависимостей и выполнения любой
работы по определению того, какие маршруты следует предварительно отрендерить. Обычно это включает выполнение запросов
для получения данных для построения массива значений параметров.

Вы также можете использовать эту функцию с маршрутами, захватывающими все пути (catch-all, например, `/**`), где имя
параметра будет `"**"`, а возвращаемое значение будет сегментами пути, такими как `foo/bar`. Их можно комбинировать с
другими параметрами (например, `/post/:id/**`) для обработки более сложной конфигурации маршрутов.

```ts
// app.routes.server.ts
import { RenderMode, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  {
    path: 'post/:id',
    renderMode: RenderMode.Prerender,
    async getPrerenderParams() {
      const dataService = inject(PostService);
      const ids = await dataService.getIds(); // Предположим, возвращает ['1', '2', '3']

      return ids.map(id => ({ id })); // Генерирует пути вида: /post/1, /post/2, /post/3
    },
  },
  {
    path: 'post/:id/**',
    renderMode: RenderMode.Prerender,
    async getPrerenderParams() {
      return [
        { id: '1', '**': 'foo/3' },
        { id: '2', '**': 'bar/4' },
      ]; // Генерирует пути вида: /post/1/foo/3, /post/2/bar/4
    },
  },
];
```

Поскольку [`getPrerenderParams`](api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams 'API reference') применяется
исключительно к [`RenderMode.Prerender`](api/ssr/RenderMode#Prerender 'API reference'), эта функция всегда выполняется
во время _сборки_. `getPrerenderParams` не должна полагаться на какие-либо специфичные для браузера или сервера API для
получения данных.

ВАЖНО: При использовании [`inject`](api/core/inject 'API reference') внутри `getPrerenderParams`, помните, что `inject`
должен использоваться синхронно. Его нельзя вызывать внутри асинхронных колбэков или после любых операторов `await`. Для
получения дополнительной информации обратитесь к `runInInjectionContext`.

#### Стратегии отката (Fallback strategies)

При использовании режима [`RenderMode.Prerender`](api/ssr/RenderMode#Prerender 'API reference') вы можете указать
стратегию отката для обработки запросов к путям, которые не были предварительно отрендерены.

Доступные стратегии отката:

- **Server:** Переключается на рендеринг на стороне сервера. Это поведение **по умолчанию**, если свойство `fallback` не
  указано.
- **Client:** Переключается на рендеринг на стороне клиента.
- **None:** Нет отката. Angular не будет обрабатывать запросы к путям, которые не были предварительно отрендерены.

```ts
// app.routes.server.ts
import { RenderMode, PrerenderFallback, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  {
    path: 'post/:id',
    renderMode: RenderMode.Prerender,
    fallback: PrerenderFallback.Client, // Откат к CSR, если не отрендерено заранее
    async getPrerenderParams() {
      // Эта функция возвращает массив объектов, представляющих предварительно отрендеренные посты по путям:
      // `/post/1`, `/post/2` и `/post/3`.
      // Путь `/post/4` будет использовать поведение отката, если он будет запрошен.
      return [{ id: 1 }, { id: 2 }, { id: 3 }];
    },
  },
];
```

## Создание серверно-совместимых компонентов

Некоторые распространенные API браузера и возможности могут быть недоступны на сервере. Приложения не могут использовать
специфичные для браузера глобальные объекты, такие как `window`, `document`, `navigator` или `location`, а также
определенные свойства `HTMLElement`.

В общем случае код, который зависит от специфичных для браузера символов, должен выполняться только в браузере, а не на
сервере. Это можно обеспечить с помощью хуков жизненного цикла `afterEveryRender` и `afterNextRender`. Они выполняются
только в браузере и пропускаются на сервере.

```angular-ts
import { Component, viewChild, afterNextRender } from '@angular/core';

@Component({
  selector: 'my-cmp',
  template: `<span #content>{{ ... }}</span>`,
})
export class MyComponent {
  contentRef = viewChild.required<ElementRef>('content');

  constructor() {
    afterNextRender(() => {
      // Безопасно проверять `scrollHeight`, так как это будет выполняться только в браузере, а не на сервере.
      console.log('content height: ' + this.contentRef().nativeElement.scrollHeight);
    });
  }
}
```

## Установка провайдеров на сервере

На стороне сервера значения провайдеров верхнего уровня устанавливаются один раз при первоначальном парсинге и
вычислении кода приложения.
Это означает, что провайдеры, настроенные с помощью `useValue`, будут сохранять свое значение между несколькими
запросами до тех пор, пока серверное приложение не будет перезапущено.

Если вы хотите генерировать новое значение для каждого запроса, используйте фабричный провайдер с `useFactory`.
Фабричная функция будет запускаться для каждого входящего запроса, гарантируя, что каждый раз создается и присваивается
токену новое значение.

## Доступ к Document через DI

При работе с рендерингом на стороне сервера следует избегать прямых ссылок на специфичные для браузера глобальные
объекты, такие как `document`. Вместо этого используйте токен [`DOCUMENT`](api/core/DOCUMENT) для доступа к объекту
document платформо-независимым способом.

```ts
import { Injectable, inject, DOCUMENT } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class CanonicalLinkService {
  private readonly document = inject(DOCUMENT);

  // Во время серверного рендеринга внедряем тег <link rel="canonical">,
  // чтобы сгенерированный HTML включал правильный канонический URL
  setCanonical(href: string): void {
    const link = this.document.createElement('link');
    link.rel = 'canonical';
    link.href = href;
    this.document.head.appendChild(link);
  }
}

```

ПОЛЕЗНО: Для управления мета-тегами Angular предоставляет сервис `Meta`.

## Доступ к Request и Response через DI

Пакет `@angular/core` предоставляет несколько токенов для взаимодействия со средой рендеринга на стороне сервера. Эти
токены дают вам доступ к важной информации и объектам внутри вашего Angular-приложения во время SSR.

- **[`REQUEST`](api/core/REQUEST 'API reference'):** Предоставляет доступ к текущему объекту запроса, который имеет
  тип [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) из Web API. Это позволяет получать доступ к
  заголовкам, файлам cookie и другой информации о запросе.
- **[`RESPONSE_INIT`](api/core/RESPONSE_INIT 'API reference'):** Предоставляет доступ к параметрам инициализации ответа,
  которые имеют тип [`ResponseInit`](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#parameters) из
  Web API. Это позволяет динамически устанавливать заголовки и код состояния для ответа. Используйте этот токен для
  установки заголовков или кодов состояния, которые необходимо определить во время выполнения.
- **[`REQUEST_CONTEXT`](api/core/REQUEST_CONTEXT 'API reference'):** Предоставляет доступ к дополнительному контексту,
  связанному с текущим запросом. Этот контекст может быть передан в качестве второго параметра функции [
  `handle`](api/ssr/AngularAppEngine#handle 'API reference'). Обычно это используется для предоставления дополнительной
  информации, связанной с запросом, которая не является частью стандартного Web API.

```angular-ts
import { inject, REQUEST } from '@angular/core';

@Component({
  selector: 'app-my-component',
  template: `<h1>My Component</h1>`,
})
export class MyComponent {
  constructor() {
    const request = inject(REQUEST);
    console.log(request?.url);
  }
}
```

ВАЖНО: Вышеуказанные токены будут `null` в следующих сценариях:

- Во время процессов сборки.
- Когда приложение рендерится в браузере (CSR).
- При выполнении генерации статического сайта (SSG).
- Во время извлечения маршрутов в разработке (в момент запроса).

## Генерация полностью статического приложения

По умолчанию Angular выполняет пре-рендеринг всего приложения и генерирует серверный файл для обработки запросов. Это
позволяет вашему приложению отдавать пользователям предварительно отрендеренный контент. Однако, если вы предпочитаете
полностью статический сайт без сервера, вы можете отказаться от этого поведения, установив `outputMode` в значение
`static` в вашем файле конфигурации `angular.json`.

Когда `outputMode` установлен в `static`, Angular генерирует предварительно отрендеренные HTML-файлы для каждого
маршрута во время сборки, но не генерирует серверный файл и не требует сервера Node.js для обслуживания приложения. Это
полезно для развертывания у хостинг-провайдеров статических сайтов, где бэкенд-сервер не требуется.

Чтобы настроить это, обновите ваш файл `angular.json` следующим образом:

```json
{
  "projects": {
    "your-app": {
      "architect": {
        "build": {
          "options": {
            "outputMode": "static"
          }
        }
      }
    }
  }
}
```

## Кэширование данных при использовании HttpClient

`HttpClient` кэширует исходящие сетевые запросы при работе на сервере. Эта информация сериализуется и передается в
браузер как часть начального HTML, отправленного с сервера. В браузере `HttpClient` проверяет, есть ли у него данные в
кэше, и если да, использует их повторно вместо выполнения нового HTTP-запроса во время начального рендеринга приложения.
`HttpClient` прекращает использование кэша, как только приложение
становится [стабильным](api/core/ApplicationRef#isStable) во время работы в браузере.

### Настройка параметров кэширования

Вы можете настроить, как Angular кэширует HTTP-ответы во время рендеринга на стороне сервера (SSR) и повторно использует
их во время гидратации, настроив `HttpTransferCacheOptions`.
Эта конфигурация предоставляется глобально с помощью `withHttpTransferCacheOptions` внутри `provideClientHydration()`.

По умолчанию `HttpClient` кэширует все `HEAD` и `GET` запросы, которые не содержат заголовков `Authorization` или
`Proxy-Authorization`. Вы можете переопределить эти настройки, используя `withHttpTransferCacheOptions` в конфигурации
гидратации.

```ts
import { bootstrapApplication } from '@angular/platform-browser';
import { provideClientHydration, withHttpTransferCacheOptions } from '@angular/platform-browser';

bootstrapApplication(AppComponent, {
  providers: [
    provideClientHydration(
      withHttpTransferCacheOptions({
        includeHeaders: ['ETag', 'Cache-Control'],
        filter: (req) => !req.url.includes('/api/profile'),
        includePostRequests: true,
        includeRequestsWithAuthHeaders: false,
      }),
    ),
  ],
});
```

---

### `includeHeaders`

Указывает, какие заголовки из ответа сервера должны быть включены в кэшированные записи.
По умолчанию заголовки не включаются.

```ts
withHttpTransferCacheOptions({
  includeHeaders: ['ETag', 'Cache-Control'],
});
```

ВАЖНО: Избегайте включения конфиденциальных заголовков, таких как токены аутентификации. Это может привести к утечке
пользовательских данных между запросами.

---

### `includePostRequests`

По умолчанию кэшируются только `GET` и `HEAD` запросы.
Вы можете включить кэширование для `POST` запросов, когда они используются как операции чтения, например,
GraphQL-запросы.

```ts
withHttpTransferCacheOptions({
  includePostRequests: true,
});
```

Используйте это только тогда, когда `POST` запросы являются **идемпотентными** и безопасными для повторного
использования между серверным и клиентским рендерингом.

---

### `includeRequestsWithAuthHeaders`

Определяет, подлежат ли кэшированию запросы, содержащие заголовки `Authorization` или `Proxy-Authorization`.
По умолчанию они исключаются, чтобы предотвратить кэширование ответов, специфичных для пользователя.

```ts
withHttpTransferCacheOptions({
  includeRequestsWithAuthHeaders: true,
});
```

Включайте только тогда, когда заголовки аутентификации **не** влияют на содержимое ответа (например, публичные токены
для API аналитики).

### Переопределения для каждого запроса

Вы можете переопределить поведение кэширования для конкретного запроса, используя опцию запроса `transferCache`.

```ts
// Включить определенные заголовки для этого запроса
http.get('/api/profile', { transferCache: { includeHeaders: ['CustomHeader'] } });
```

### Отключение кэширования

Вы можете отключить HTTP-кэширование запросов, отправленных с сервера, либо глобально, либо индивидуально.

#### Глобально

Чтобы отключить кэширование для всех запросов в вашем приложении, используйте функцию `withNoHttpTransferCache`:

```ts
import { bootstrapApplication, provideClientHydration, withNoHttpTransferCache } from '@angular/platform-browser';

bootstrapApplication(AppComponent, {
  providers: [
    provideClientHydration(withNoHttpTransferCache())
  ]
});
```

#### `filter`

Вы также можете выборочно отключить кэширование для определенных запросов, используя опцию [
`filter`](api/common/http/HttpTransferCacheOptions) в `withHttpTransferCacheOptions`. Например, вы можете отключить
кэширование для определенной конечной точки API:

```ts
import { bootstrapApplication, provideClientHydration, withHttpTransferCacheOptions } from '@angular/platform-browser';

bootstrapApplication(AppComponent, {
  providers: [
    provideClientHydration(withHttpTransferCacheOptions({
      filter: (req) => !req.url.includes('/api/sensitive-data')
    }))
  ]
});
```

Используйте эту опцию для исключения конечных точек с пользовательскими или динамическими данными (например,
`/api/profile`).

#### Индивидуально

Чтобы отключить кэширование для отдельного запроса, вы можете указать опцию [
`transferCache`](api/common/http/HttpRequest#transferCache) в `HttpRequest`.

```ts
httpClient.get('/api/sensitive-data', { transferCache: false });
```

## Настройка сервера

### Node.js

Пакет `@angular/ssr/node` расширяет `@angular/ssr` специально для сред Node.js. Он предоставляет API, которые упрощают
реализацию рендеринга на стороне сервера в вашем приложении Node.js. Полный список функций и примеры использования см.
в [справочнике API `@angular/ssr/node`](api/ssr/node/AngularNodeAppEngine).

```ts
// server.ts
import { AngularNodeAppEngine, createNodeRequestHandler, writeResponseToNodeResponse } from '@angular/ssr/node';
import express from 'express';

const app = express();
const angularApp = new AngularNodeAppEngine();

app.use('*', (req, res, next) => {
  angularApp
    .handle(req)
    .then(response => {
      if (response) {
        writeResponseToNodeResponse(response, res);
      } else {
        next(); // Передать управление следующему middleware
      }
    })
    .catch(next);
});

/**
 * Обработчик запросов, используемый Angular CLI (dev-server и во время сборки).
 */
export const reqHandler = createNodeRequestHandler(app);
```

### Non-Node.js

Пакет `@angular/ssr` предоставляет основные API для рендеринга вашего Angular-приложения на стороне сервера на
платформах, отличных от Node.js. Он использует стандартные объекты [
`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) и [
`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) из Web API, позволяя интегрировать Angular SSR в
различные серверные среды. Для получения подробной информации и примеров см. [справочник API
`@angular/ssr`](api/ssr/AngularAppEngine).

```ts
// server.ts
import { AngularAppEngine, createRequestHandler } from '@angular/ssr';

const angularApp = new AngularAppEngine();

/**
 * Это обработчик запросов, используемый Angular CLI (dev-server и во время сборки).
 */
export const reqHandler = createRequestHandler(async (req: Request) => {
  const res: Response|null = await angularApp.render(req);

  // ...
});
```
