# Использование DOM API

TIP: Это руководство предполагает, что вы уже ознакомились с [Руководством по основам](essentials). Если вы новичок в
Angular, сначала прочитайте его.

Angular берет на себя большую часть задач по созданию, обновлению и удалению DOM. Однако в редких случаях вам может
понадобиться напрямую взаимодействовать с DOM компонента. Компоненты могут внедрять `ElementRef` для получения ссылки на
хост-элемент компонента:

```ts
@Component({...})
export class ProfilePhoto {
  constructor() {
    const elementRef = inject(ElementRef);
    console.log(elementRef.nativeElement);
  }
}
```

Свойство `nativeElement` ссылается на экземпляр
хост-элемента [Element](https://developer.mozilla.org/docs/Web/API/Element).

Вы можете использовать функции Angular `afterEveryRender` и `afterNextRender` для регистрации **функции обратного вызова
рендеринга**, которая запускается после того, как Angular завершит рендеринг страницы.

```ts
@Component({...})
export class ProfilePhoto {
  constructor() {
    const elementRef = inject(ElementRef);
    afterEveryRender(() => {
      // Фокусировка на первом элементе input в этом компоненте.
      elementRef.nativeElement.querySelector('input')?.focus();
    });
  }
}
```

Функции `afterEveryRender` и `afterNextRender` должны вызываться в _контексте внедрения_ (injection context), обычно в
конструкторе компонента.

**Избегайте прямых манипуляций с DOM, когда это возможно.** Всегда отдавайте предпочтение описанию структуры DOM в
шаблонах компонентов и обновлению этого DOM с помощью привязок.

**Функции обратного вызова рендеринга никогда не выполняются во время рендеринга на стороне сервера (SSR) или
предварительного рендеринга (pre-rendering) на этапе сборки.**

**Никогда не манипулируйте DOM напрямую внутри других хуков жизненного цикла Angular**. Angular не гарантирует, что DOM
компонента полностью отрисован в какой-либо момент, кроме как в функциях обратного вызова рендеринга. Кроме того, чтение
или изменение DOM во время других хуков жизненного цикла может негативно повлиять на производительность страницы,
вызывая [layout thrashing (синхронный пересчет макета)](https://web.dev/avoid-large-complex-layouts-and-layout-thrashing).

## Использование Renderer2 компонента

Компоненты могут внедрять экземпляр `Renderer2` для выполнения определенных манипуляций с DOM, которые связаны с другими
возможностями Angular.

Любые DOM-элементы, созданные с помощью `Renderer2` компонента, участвуют
в [инкапсуляции стилей](guide/components/styling#style-scoping) этого компонента.

Некоторые API `Renderer2` также связаны с системой анимации Angular. Вы можете использовать метод `setProperty` для
обновления синтетических свойств анимации и метод `listen` для добавления слушателей событий для синтетических событий
анимации. Подробнее см. в руководстве по [Анимациям](guide/animations).

За исключением этих двух узких сценариев использования, нет никакой разницы между использованием `Renderer2` и нативных
DOM API. API `Renderer2` не поддерживают манипуляции с DOM в контекстах рендеринга на стороне сервера или
предварительного рендеринга на этапе сборки.

## Когда использовать DOM API

Хотя Angular берет на себя большинство задач рендеринга, некоторые поведения все же могут потребовать использования DOM
API. Некоторые распространенные случаи использования включают:

- Управление фокусом элемента
- Измерение геометрии элемента, например, с помощью `getBoundingClientRect`
- Чтение текстового содержимого элемента
- Настройка нативных наблюдателей, таких как [
  `MutationObserver`](https://developer.mozilla.org/docs/Web/API/MutationObserver), [
  `ResizeObserver`](https://developer.mozilla.org/docs/Web/API/ResizeObserver) или [
  `IntersectionObserver`](https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API).

Избегайте вставки, удаления и изменения DOM-элементов. В частности, **никогда не устанавливайте свойство `innerHTML`
элемента напрямую**, так как это может сделать ваше приложение уязвимым
для [межсайтового скриптинга (XSS)](https://developer.mozilla.org/docs/Glossary/Cross-site_scripting). Привязки шаблонов
Angular, включая привязки для `innerHTML`, содержат защитные механизмы, которые помогают предотвратить XSS-атаки.
Подробнее см. в [Руководстве по безопасности](best-practices/security).
