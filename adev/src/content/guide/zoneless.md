# Angular без ZoneJS (Zoneless)

## Зачем использовать Zoneless?

Основные преимущества удаления ZoneJS как зависимости:

- **Улучшенная производительность**: ZoneJS использует события DOM и асинхронные задачи как индикаторы того, когда
  состояние приложения _могло_ обновиться, и впоследствии запускает синхронизацию приложения для выполнения обнаружения
  изменений в представлениях приложения. ZoneJS не знает, изменилось ли состояние приложения на самом деле, поэтому эта
  синхронизация запускается чаще, чем необходимо.
- **Улучшенные Core Web Vitals**: ZoneJS создает значительные накладные расходы, как в размере бандла, так и во времени
  запуска.
- **Улучшенный опыт отладки**: ZoneJS усложняет отладку кода. Стек вызовов (stack traces) труднее понять с ZoneJS. Также
  сложно понять, когда код ломается из-за того, что он находится вне зоны Angular.
- **Лучшая совместимость с экосистемой**: ZoneJS работает путем патчинга API браузера, но не имеет автоматических патчей
  для каждого нового API браузера. Некоторые API невозможно эффективно пропатчить, например `async`/`await`, и их
  приходится даунгрейдить (downlevel) для работы с ZoneJS. Иногда библиотеки в экосистеме также несовместимы с тем, как
  ZoneJS патчит нативные API. Удаление ZoneJS как зависимости обеспечивает лучшую долгосрочную совместимость за счет
  устранения источника сложности, "monkey patching" и постоянного обслуживания.

## Включение Zoneless в приложении

```typescript
// standalone bootstrap
bootstrapApplication(MyApp, {providers: [
  provideZonelessChangeDetection(),
]});

// NgModule bootstrap
platformBrowser().bootstrapModule(AppModule);
@NgModule({
  providers: [provideZonelessChangeDetection()]
})
export class AppModule {}
```

## Удаление ZoneJS

Zoneless-приложения должны полностью удалить ZoneJS из сборки, чтобы уменьшить размер бандла. ZoneJS обычно загружается
через опцию `polyfills` в `angular.json`, как в целях `build`, так и в `test`. Удалите `zone.js` и `zone.js/testing` из
обоих мест, чтобы исключить их из сборки. Проекты, использующие явный файл `polyfills.ts`, должны удалить
`import 'zone.js';` и `import 'zone.js/testing';` из этого файла.

После удаления ZoneJS из сборки больше нет необходимости в зависимости `zone.js`, и пакет можно удалить полностью:

```shell
npm uninstall zone.js
```

## Требования для совместимости с Zoneless

Angular полагается на уведомления от основных API, чтобы определить, когда запускать обнаружение изменений и в каких
представлениях.
Эти уведомления включают:

- `ChangeDetectorRef.markForCheck` (вызывается автоматически через `AsyncPipe`)
- `ComponentRef.setInput`
- Обновление сигнала, который читается в шаблоне
- Коллбэки привязанных слушателей хоста или шаблона (host or template listeners)
- Прикрепление представления, которое было помечено как "dirty" одним из вышеперечисленных способов

### Компоненты, совместимые с `OnPush`

Один из способов убедиться, что компонент использует правильные механизмы уведомления, описанные выше, —
использовать [ChangeDetectionStrategy.OnPush](/best-practices/skipping-subtrees#using-onpush).

Стратегия обнаружения изменений `OnPush` не является обязательной, но это рекомендуемый шаг к совместимости с Zoneless
для компонентов приложения. Для компонентов библиотек не всегда возможно использовать `ChangeDetectionStrategy.OnPush`.
Когда компонент библиотеки является хостом для пользовательских компонентов, которые могут использовать
`ChangeDetectionStrategy.Default`, он не может использовать `OnPush`, так как это предотвратит обновление дочернего
компонента, если тот не совместим с `OnPush` и полагается на ZoneJS для запуска обнаружения изменений. Компоненты могут
использовать стратегию `Default`, пока они уведомляют Angular о необходимости запуска обнаружения изменений (вызывая
`markForCheck`, используя сигналы, `AsyncPipe` и т.д.).
Быть хостом для пользовательского компонента означает использование API, такого как `ViewContainerRef.createComponent`,
а не просто размещение части шаблона из пользовательского компонента (т.е. проекция контента или использование входного
параметра template ref).

### Удаление `NgZone.onMicrotaskEmpty`, `NgZone.onUnstable`, `NgZone.isStable` или `NgZone.onStable`

Приложения и библиотеки должны удалить использование `NgZone.onMicrotaskEmpty`, `NgZone.onUnstable` и `NgZone.onStable`.
Эти Observable никогда не будут эмитить значения, когда приложение включает обнаружение изменений без зон (zoneless).
Аналогично, `NgZone.isStable` всегда будет `true` и не должно использоваться как условие для выполнения кода.

Observable `NgZone.onMicrotaskEmpty` и `NgZone.onStable` чаще всего используются для ожидания завершения обнаружения
изменений Angular перед выполнением задачи. Вместо этого их можно заменить на `afterNextRender`, если нужно дождаться
одного цикла обнаружения изменений, или `afterEveryRender`, если есть условие, которое может охватывать несколько
раундов обнаружения изменений. В других случаях эти Observable использовались потому, что они были знакомы и имели
тайминги, схожие с необходимыми. Вместо этого можно использовать более простые или прямые DOM API, такие как
`MutationObserver`, когда коду нужно дождаться определенного состояния DOM (а не ждать его косвенно через хуки
рендеринга Angular).

<docs-callout title="NgZone.run и NgZone.runOutsideAngular совместимы с Zoneless">
`NgZone.run` и `NgZone.runOutsideAngular` не нужно удалять, чтобы код был совместим с Zoneless-приложениями. Фактически, удаление этих вызовов может привести к регрессии производительности для библиотек, которые используются в приложениях, все еще полагающихся на ZoneJS.
</docs-callout>

### `PendingTasks` для рендеринга на стороне сервера (SSR)

Если вы используете SSR с Angular, вы, возможно, знаете, что он полагается на ZoneJS для определения того, когда
приложение "стабильно" и может быть сериализовано. Если существуют асинхронные задачи, которые должны предотвращать
сериализацию, приложение, не использующее ZoneJS, должно сообщить о них Angular с помощью
сервиса [PendingTasks](/api/core/PendingTasks). Сериализация будет ждать первого момента, когда все ожидающие задачи
будут удалены.

Два наиболее простых способа использования ожидающих задач — это метод `run`:

```typescript
const taskService = inject(PendingTasks);
taskService.run(async () => {
  const someResult = await doSomeWorkThatNeedsToBeRendered();
  this.someState.set(someResult);
});
```

Для более сложных случаев использования вы можете вручную добавлять и удалять ожидающую задачу:

```typescript
const taskService = inject(PendingTasks);
const taskCleanup = taskService.add();
try {
  await doSomeWorkThatNeedsToBeRendered();
} catch {
  // handle error
} finally {
  taskCleanup();
}
```

Кроме того, хелпер [pendingUntilEvent](/api/core/rxjs-interop/pendingUntilEvent#) в `rxjs-interop` гарантирует, что
приложение остается нестабильным до тех пор, пока Observable не сэмитит значение, не завершится, не выдаст ошибку или
пока от него не отпишутся.

```typescript
readonly myObservableState = someObservable.pipe(pendingUntilEvent());
```

Фреймворк также использует этот сервис внутри для предотвращения сериализации до завершения асинхронных задач. К ним
относятся, помимо прочего, текущая навигация Роутера и незавершенный запрос `HttpClient`.

## Тестирование и отладка

### Использование Zoneless в `TestBed`

Функция провайдера zoneless также может использоваться с `TestBed`, чтобы помочь убедиться, что тестируемые компоненты
совместимы с Zoneless-приложением Angular.

```typescript
TestBed.configureTestingModule({
  providers: [provideZonelessChangeDetection()]
});

const fixture = TestBed.createComponent(MyComponent);
await fixture.whenStable();
```

Чтобы гарантировать, что тесты имеют поведение, максимально похожее на продакшн-код, избегайте использования
`fixture.detectChanges()`, когда это возможно. Это принудительно запускает обнаружение изменений, когда Angular,
возможно, не запланировал бы его. Тесты должны гарантировать, что эти уведомления происходят, и позволять Angular
решать, когда синхронизировать состояние, вместо того чтобы вручную форсировать это в тесте.

Для существующих наборов тестов использование `fixture.detectChanges()` является распространенным паттерном, и,
вероятно, не стоит усилий по их конвертации в `await fixture.whenStable()`. `TestBed` по-прежнему будет требовать, чтобы
компонент фикстуры был совместим с `OnPush`, и выбросит `ExpressionChangedAfterItHasBeenCheckedError`, если обнаружит,
что значения шаблона были обновлены без уведомления об изменении (например,
`fixture.componentInstance.someValue = 'newValue';`).
Если компонент используется в продакшене, эту проблему следует решить, обновив компонент для использования сигналов для
состояния или вызвав `ChangeDetectorRef.markForCheck()`.
Если компонент используется только как обертка для тестов и никогда не используется в приложении, допустимо использовать
`fixture.changeDetectorRef.markForCheck()`.

### Проверка в режиме отладки для гарантии обнаружения обновлений

Angular также предоставляет дополнительный инструмент, помогающий проверить, что приложение обновляет состояние
способом, совместимым с zoneless. `provideCheckNoChangesConfig({exhaustive: true, interval: <milliseconds>})` можно
использовать для периодической проверки того, что никакие привязки не были обновлены без уведомления. Angular
выбрасывает `ExpressionChangedAfterItHasBeenCheckedError`, если есть обновленная привязка, которая не была бы обновлена
механизмом обнаружения изменений zoneless.
