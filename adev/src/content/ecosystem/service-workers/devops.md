# DevOps для Service Worker

Эта страница является справочником по развертыванию и поддержке production-приложений, использующих Angular Service
Worker.
Здесь объясняется, как Angular Service Worker вписывается в более широкую производственную среду, как он ведет себя в
различных условиях, а также описываются доступные ресурсы и механизмы отказоустойчивости.

## Service Worker и кэширование ресурсов приложения

Представьте Angular Service Worker как кэш прямого доступа или пограничный узел сети доставки контента (CDN),
установленный в веб-браузере конечного пользователя.
Service Worker отвечает на запросы приложения Angular за ресурсами или данными из локального кэша, не дожидаясь ответа
от сети.
Как и любой кэш, он имеет правила устаревания и обновления контента.

### Версии приложения {#application-versions}

В контексте Angular Service Worker «версия» — это набор ресурсов, представляющих конкретную сборку (build) приложения
Angular.
Всякий раз, когда развертывается новая сборка приложения, Service Worker рассматривает её как новую версию.
Это происходит даже в том случае, если обновлен только один файл.
В любой момент времени Service Worker может иметь в своем кэше несколько версий приложения и обслуживать их
одновременно.
Для получения дополнительной информации см. раздел [Вкладки приложения](#application-tabs).

Чтобы сохранить целостность приложения, Angular Service Worker группирует все файлы в одну версию.
Файлы, сгруппированные в версию, обычно включают HTML, JS и CSS файлы.
Группировка этих файлов необходима для целостности, поскольку файлы HTML, JS и CSS часто ссылаются друг на друга и
зависят от конкретного содержимого.
Например, файл `index.html` может содержать тег `<script>`, ссылающийся на `bundle.js`, и пытаться вызвать функцию
`startApp()` из этого скрипта.
Каждый раз, когда обслуживается эта версия `index.html`, вместе с ней должен обслуживаться соответствующий `bundle.js`.
Предположим, что функция `startApp()` переименована в `runApp()` в обоих файлах.
В этом сценарии недопустимо обслуживать старый `index.html`, который вызывает `startApp()`, вместе с новым бандлом,
определяющим `runApp()`.

Эта целостность файлов особенно важна при ленивой загрузке (lazy loading).
JS-бандл может ссылаться на множество ленивых чанков (lazy chunks), и имена файлов этих чанков уникальны для конкретной
сборки приложения.
Если запущенное приложение версии `X` пытается загрузить ленивый чанк, но сервер уже обновился до версии `X + 1`,
операция ленивой загрузки завершится ошибкой.

Идентификатор версии приложения определяется содержимым всех ресурсов и изменяется, если изменяется любой из них.
На практике версия определяется содержимым файла `ngsw.json`, который включает хеши для всего известного контента.
Если какой-либо из кэшированных файлов изменяется, его хеш меняется в `ngsw.json`. Это изменение заставляет Angular
Service Worker рассматривать активный набор файлов как новую версию.

HELPFUL: Процесс сборки создает файл манифеста `ngsw.json`, используя информацию из `ngsw-config.json`.

Благодаря такому поведению версионирования Angular Service Worker, сервер приложений может гарантировать, что приложение
Angular всегда имеет согласованный набор файлов.

#### Проверка обновлений

Каждый раз, когда пользователь открывает или обновляет приложение, Angular Service Worker проверяет наличие обновлений,
отслеживая изменения в манифесте `ngsw.json`.
Если обновление найдено, оно загружается и кэшируется автоматически, и будет использовано при следующей загрузке
приложения.

### Целостность ресурсов

Одним из потенциальных побочных эффектов длительного кэширования является непреднамеренное кэширование недействительного
ресурса.
В обычном HTTP-кэше жесткое обновление (hard refresh) или истечение срока действия кэша ограничивают негативные
последствия кэширования невалидного файла.
Service Worker игнорирует такие ограничения и фактически кэширует всё приложение на длительный срок.
Важно, чтобы Service Worker получал правильный контент, поэтому он хранит хеши ресурсов для поддержания их целостности.

#### Хешированный контент

Чтобы гарантировать целостность ресурсов, Angular Service Worker проверяет хеши всех ресурсов, для которых у него есть
хеш.
Для приложения, созданного с помощью [Angular CLI](tools/cli), это всё, что находится в каталоге `dist` и покрывается
конфигурацией `src/ngsw-config.json` пользователя.

Если конкретный файл не проходит проверку, Angular Service Worker пытается повторно получить контент, используя
URL-параметр для сброса кэша ("cache-busting"), чтобы предотвратить браузерное или промежуточное кэширование.
Если этот контент также не проходит проверку, Service Worker считает всю версию приложения недействительной и прекращает
обслуживание приложения.
При необходимости Service Worker переходит в безопасный режим (safe mode), где запросы перенаправляются в сеть. Service
Worker не использует свой кэш, если существует высокий риск обслуживания сломанного, устаревшего или невалидного
контента.

Несовпадение хешей может происходить по разным причинам:

- Кэширующие слои между исходным сервером и конечным пользователем могут отдавать устаревший контент.
- Неатомарное развертывание может привести к тому, что Angular Service Worker увидит частично обновленный контент.
- Ошибки в процессе сборки могут привести к обновлению ресурсов без обновления `ngsw.json`.
  Может произойти и обратное: обновление `ngsw.json` без обновления ресурсов.

#### Нехешированный контент

Единственные ресурсы, которые имеют хеши в манифесте `ngsw.json`, — это ресурсы, присутствовавшие в каталоге `dist` на
момент создания манифеста.
Другие ресурсы, особенно загружаемые из CDN, имеют контент, который неизвестен во время сборки или обновляется чаще, чем
развертывается приложение.

Если у Angular Service Worker нет хеша для проверки валидности ресурса, он всё равно кэширует его содержимое. При этом
он соблюдает заголовки HTTP-кэширования, используя политику _stale while revalidate_ (использовать устаревшее при
обновлении).
Angular Service Worker продолжает отдавать ресурс даже после того, как его заголовки HTTP-кэширования указывают, что он
больше не действителен. В то же время он пытается обновить просроченный ресурс в фоновом режиме.
Таким образом, сломанные нехешированные ресурсы не остаются в кэше дольше установленного срока их жизни.

### Вкладки приложения {#application-tabs}

Для приложения может быть проблематично, если версия получаемых ресурсов меняется внезапно или без предупреждения.
Описание таких проблем см. в разделе [Версии приложения](#application-versions).

Angular Service Worker предоставляет гарантию: запущенное приложение продолжает использовать ту же версию приложения.
Если другой экземпляр приложения открывается в новой вкладке браузера, то обслуживается самая актуальная версия
приложения.
В результате эта новая вкладка может работать с другой версией приложения, отличной от исходной вкладки.

IMPORTANT: Эта гарантия **сильнее**, чем та, что предоставляется обычной моделью веб-развертывания. Без Service Worker
нет гарантии, что лениво загружаемый код принадлежит той же версии, что и начальный код приложения.

Angular Service Worker может изменить версию запущенного приложения при возникновении ошибок, таких как:

- Текущая версия становится недействительной из-за несовпадения хеша.
- Несвязанная ошибка заставляет Service Worker перейти в безопасный режим и временно деактивироваться.

Angular Service Worker очищает версии приложения, когда ни одна вкладка их не использует.

Другие причины, по которым Angular Service Worker может изменить версию запущенного приложения, являются нормальными
событиями:

- Страница перезагружается/обновляется.
- Страница запрашивает немедленную активацию обновления с помощью сервиса `SwUpdate`.

### Обновления Service Worker

Angular Service Worker — это небольшой скрипт, который запускается в веб-браузерах.
Время от времени Service Worker обновляется для исправления ошибок и улучшения функциональности.

Angular Service Worker загружается при первом открытии приложения и при доступе к приложению после периода бездействия.
Если Service Worker изменился, он обновляется в фоновом режиме.

Большинство обновлений Angular Service Worker прозрачны для приложения. Старые кэши остаются действительными, и контент
по-прежнему обслуживается нормально.
Иногда исправление ошибки или новая функция в Angular Service Worker может потребовать аннулирования старых кэшей.
В этом случае Service Worker прозрачно обновляет приложение из сети.

### Обход Service Worker {#bypassing-the-service-worker}

В некоторых случаях вам может потребоваться полностью обойти Service Worker и позволить браузеру обработать запрос.
Примером может служить использование функции, которая в настоящее время не поддерживается в Service Worker,
например, [отчет о ходе загрузки файлов](https://github.com/w3c/ServiceWorker/issues/1141).

Чтобы обойти Service Worker, установите `ngsw-bypass` в качестве заголовка запроса или параметра запроса.
Значение заголовка или параметра запроса игнорируется и может быть пустым или опущенным.

### Запросы Service Worker, когда сервер недоступен

Service Worker обрабатывает все запросы, за исключением случаев,
когда [Service Worker явно обойден](#bypassing-the-service-worker).
Service Worker либо возвращает кэшированный ответ, либо отправляет запрос на сервер, в зависимости от состояния и
конфигурации кэша.
Service Worker кэширует ответы только на не изменяющие данные запросы, такие как `GET` и `HEAD`.

Если Service Worker получает ошибку от сервера или не получает ответа, он возвращает статус ошибки, указывающий на
результат вызова.
Например, если Service Worker не получает ответа, он создает
статус [504 Gateway Timeout](https://developer.mozilla.org/docs/Web/HTTP/Status/504) для возврата. Статус `504` в этом
примере может быть возвращен, потому что сервер находится в автономном режиме или клиент отключен от сети.

## Отладка Angular Service Worker

Иногда может потребоваться изучить Angular Service Worker в рабочем состоянии, чтобы исследовать проблемы или убедиться,
что он работает так, как задумано.
Браузеры предоставляют встроенные инструменты для отладки Service Worker, а сам Angular Service Worker включает полезные
функции отладки.

### Поиск и анализ отладочной информации

Angular Service Worker предоставляет отладочную информацию в виртуальном каталоге `ngsw/`.
В настоящее время единственным доступным URL является `ngsw/state`.
Вот пример содержимого этой страницы отладки:

<docs-code hideCopy language="shell">

NGSW Debug Info:

Driver version: 13.3.7
Driver state: NORMAL ((nominal))
Latest manifest hash: eea7f5f464f90789b621170af5a569d6be077e5c
Last update check: never

=== Version eea7f5f464f90789b621170af5a569d6be077e5c ===

Clients: 7b79a015-69af-4d3d-9ae6-95ba90c79486, 5bc08295-aaf2-42f3-a4cc-9e4ef9100f65

=== Idle Task Queue ===
Last update tick: 1s496u
Last update run: never
Task queue:

- init post-load (update, cleanup)

Debug log:

</docs-code>

#### Состояние драйвера (Driver state)

Первая строка указывает на состояние драйвера:

<docs-code hideCopy language="shell">

Driver state: NORMAL ((nominal))

</docs-code>

`NORMAL` указывает, что Service Worker работает нормально и не находится в деградированном состоянии.

Существует два возможных деградированных состояния:

| Деградированные состояния | Подробности                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| :------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `EXISTING_CLIENTS_ONLY`   | У Service Worker нет чистой копии последней известной версии приложения. Старые кэшированные версии безопасны для использования, поэтому существующие вкладки продолжают работать из кэша, но новые загрузки приложения будут обслуживаться из сети. Service Worker попытается восстановиться из этого состояния, когда будет обнаружена и установлена новая версия приложения. Это происходит, когда становится доступен новый `ngsw.json`. |
| `SAFE_MODE`               | Service Worker не может гарантировать безопасность использования кэшированных данных. Либо произошла непредвиденная ошибка, либо все кэшированные версии недействительны. Весь трафик будет обслуживаться из сети, выполняя как можно меньше кода Service Worker.                                                                                                                                                                            |

В обоих случаях примечание в скобках указывает на ошибку, которая заставила Service Worker перейти в деградированное
состояние.

Оба состояния являются временными; они сохраняются только в течение времени
жизни [экземпляра ServiceWorker](https://developer.mozilla.org/docs/Web/API/ServiceWorkerGlobalScope).
Браузер иногда завершает работу простаивающего Service Worker для экономии памяти и мощности процессора и создает новый
экземпляр Service Worker в ответ на сетевые события.
Новый экземпляр запускается в режиме `NORMAL`, независимо от состояния предыдущего экземпляра.

#### Хеш последнего манифеста (Latest manifest hash)

<docs-code hideCopy language="shell">

Latest manifest hash: eea7f5f464f90789b621170af5a569d6be077e5c

</docs-code>

Это SHA1-хеш самой актуальной версии приложения, о которой знает Service Worker.

#### Последняя проверка обновлений (Last update check)

<docs-code hideCopy language="shell">

Last update check: never

</docs-code>

Это указывает, когда Service Worker в последний раз проверял наличие новой версии или обновления приложения.
`never` означает, что Service Worker никогда не проверял наличие обновлений.

В этом примере файла отладки проверка обновлений в данный момент запланирована, как объясняется в следующем разделе.

#### Версия (Version)

<docs-code hideCopy language="shell">

=== Version eea7f5f464f90789b621170af5a569d6be077e5c ===

Clients: 7b79a015-69af-4d3d-9ae6-95ba90c79486, 5bc08295-aaf2-42f3-a4cc-9e4ef9100f65

</docs-code>

В этом примере у Service Worker есть одна кэшированная версия приложения, которая используется для обслуживания двух
разных вкладок.

HELPFUL: Этот хеш версии совпадает с «хешем последнего манифеста», указанным выше. Оба клиента находятся на последней
версии. Каждый клиент указан по своему ID из API `Clients` в браузере.

#### Очередь фоновых задач (Idle Task Queue)

<docs-code hideCopy language="shell">

=== Idle Task Queue ===
Last update tick: 1s496u
Last update run: never
Task queue:

- init post-load (update, cleanup)

</docs-code>

Idle Task Queue — это очередь всех ожидающих задач, которые выполняются в фоновом режиме в Service Worker.
Если в очереди есть какие-либо задачи, они перечисляются с описанием.
В этом примере у Service Worker запланирована одна такая задача — операция после инициализации, включающая проверку
обновлений и очистку устаревших кэшей.

Счетчики последнего тика/запуска обновления показывают время, прошедшее с момента определенных событий, связанных с
очередью простоя.
Счетчик "Last update run" показывает, когда в последний раз фактически выполнялись фоновые задачи.
"Last update tick" показывает время с момента последнего события, после которого очередь могла быть обработана.

#### Журнал отладки (Debug log)

<docs-code hideCopy language="shell">

Debug log:

</docs-code>

Ошибки, возникающие внутри Service Worker, регистрируются здесь.

### Инструменты разработчика

Браузеры, такие как Chrome, предоставляют инструменты разработчика для взаимодействия с Service Worker.
Такие инструменты могут быть мощными при правильном использовании, но следует помнить о нескольких вещах.

- При использовании инструментов разработчика Service Worker продолжает работать в фоновом режиме и никогда не
  перезапускается.
  Это может привести к тому, что поведение при открытых Dev Tools будет отличаться от поведения, с которым может
  столкнуться пользователь.

- Если вы посмотрите в средство просмотра Cache Storage, кэш часто бывает устаревшим.
  Щелкните правой кнопкой мыши заголовок Cache Storage и обновите кэши.

- Остановка и запуск Service Worker на панели Service Worker инициирует проверку обновлений.

## Безопасность Service Worker

Ошибки или неправильная конфигурация могут заставить Angular Service Worker вести себя неожиданным образом.
Если это произойдет, Angular Service Worker содержит несколько механизмов отказоустойчивости на случай, если
администратору потребуется быстро деактивировать Service Worker.

### Механизм Fail-safe {#fail-safe}

Чтобы деактивировать Service Worker, переименуйте файл `ngsw.json` или удалите его.
Когда запрос Service Worker к `ngsw.json` вернет `404`, Service Worker удалит все свои кэши и отменит свою регистрацию,
по сути самоуничтожившись.

### Safety Worker {#safety-worker}

<!-- vale Angular.Google_Acronyms = NO -->

Небольшой скрипт `safety-worker.js` также включен в NPM-пакет `@angular/service-worker`.
При загрузке он отменяет свою регистрацию в браузере и удаляет кэши Service Worker.
Этот скрипт можно использовать как крайнюю меру для избавления от нежелательных Service Worker, уже установленных на
страницах клиентов.

<!-- vale Angular.Google_Acronyms = YES -->

CRITICAL: Вы не можете зарегистрировать этот воркер напрямую, так как старые клиенты с кэшированным состоянием могут не
увидеть новый `index.html`, который устанавливает другой скрипт воркера.

Вместо этого вы должны отдавать содержимое `safety-worker.js` по URL-адресу скрипта Service Worker, регистрацию которого
вы пытаетесь отменить. Вы должны продолжать делать это до тех пор, пока не будете уверены, что все пользователи успешно
отменили регистрацию старого воркера.
Для большинства сайтов это означает, что вы должны отдавать safety worker по старому URL-адресу Service Worker навсегда.
Этот скрипт можно использовать для деактивации `@angular/service-worker` и удаления соответствующих кэшей. Он также
удаляет любые другие Service Worker, которые могли обслуживаться на вашем сайте в прошлом.

### Изменение местоположения вашего приложения

IMPORTANT: Service Worker не работает за перенаправлением (redirect).
Возможно, вы уже сталкивались с ошибкой `The script resource is behind a redirect, which is disallowed`.

Это может стать проблемой, если вам нужно изменить местоположение вашего приложения.
Если вы настроите перенаправление со старого местоположения, например `example.com`, на новое, `www.example.com` в
данном примере, воркер перестанет работать.
Кроме того, перенаправление даже не сработает для пользователей, которые загружают сайт полностью из Service Worker.
Старый воркер, который был зарегистрирован на `example.com`, пытается обновиться и отправляет запрос на старое
местоположение `example.com`. Этот запрос перенаправляется на новое местоположение `www.example.com` и создает ошибку:
`The script resource is behind a redirect, which is disallowed`.

Чтобы исправить это, вам может потребоваться деактивировать старый воркер, используя один из предыдущих
методов: [Fail-safe](#fail-safe) или [Safety Worker](#safety-worker).

## Дополнительно об Angular Service Worker

Вас также может заинтересовать следующее:

<docs-pill-row>
  <docs-pill href="ecosystem/service-workers/config" title="Файл конфигурации"/>
  <docs-pill href="ecosystem/service-workers/communications" title="Взаимодействие с Service Worker"/>
</docs-pill-row>
