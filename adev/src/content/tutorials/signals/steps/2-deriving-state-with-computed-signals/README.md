# Вычисление состояния с помощью computed-сигналов

Теперь, когда вы
узнали, [как создавать и обновлять сигналы](/tutorials/signals/1-creating-and-updating-your-first-signal), давайте
изучим computed-сигналы. Computed-сигналы — это производные значения, которые автоматически обновляются при изменении их
зависимостей. Они идеально подходят для создания реактивных вычислений на основе других сигналов.

В этом упражнении вы узнаете, как использовать функцию `computed()` для создания производного состояния, которое
обновляется автоматически при изменении базовых сигналов.

Давайте улучшим нашу систему статусов пользователей, добавив вычисляемые значения, которые получают информацию из нашего
сигнала статуса пользователя. Стартовый код теперь включает три варианта статуса: `'online'`, `'away'` и `'offline'`.

<hr />

<docs-workflow>

<docs-step title="Импорт функции computed">
Добавьте `computed` в существующие импорты.

```ts
// Add computed to existing imports
import {Component, signal, computed, ChangeDetectionStrategy} from '@angular/core';
```

</docs-step>

<docs-step title="Создание computed-сигнала для уведомлений">
Добавьте computed-сигнал, который определяет, должны ли быть включены уведомления, основываясь на статусе пользователя.

```ts
notificationsEnabled = computed(() => this.userStatus() === 'online');
```

Этот computed-сигнал будет автоматически пересчитываться всякий раз, когда изменяется сигнал `userStatus`. Обратите
внимание, как мы вызываем `this.userStatus()` внутри функции computed для чтения значения сигнала.
</docs-step>

<docs-step title="Создание computed-сигнала для описательного сообщения">
Добавьте computed-сигнал, который создает описательное сообщение на основе статуса пользователя.

```ts
statusMessage = computed(() => {
  const status = this.userStatus();
  switch (status) {
    case 'online': return 'Available for meetings and messages';
    case 'away': return 'Temporarily away, will respond soon';
    case 'offline': return 'Not available, check back later';
    default: return 'Status unknown';
  }
});
```

Это показывает, как computed-сигналы могут обрабатывать более сложную логику с помощью операторов switch и
преобразований строк.
</docs-step>

<docs-step title="Создание computed-сигнала, вычисляющего доступность в рабочее время">
Добавьте computed-сигнал, который вычисляет, находится ли пользователь в рамках своего рабочего времени.

```ts
isWithinWorkingHours = computed(() => {
  const now = new Date();
  const hour = now.getHours();
  const isWeekday = now.getDay() > 0 && now.getDay() < 6;
  return isWeekday && hour >= 9 && hour < 17 && this.userStatus() !== 'offline';
});
```

Это демонстрирует, как computed-сигналы могут выполнять вычисления и комбинировать несколько источников данных. Значение
обновляется автоматически при изменении `userStatus`.
</docs-step>

<docs-step title="Отображение вычисляемых значений в шаблоне">
В шаблоне уже есть заполнители, показывающие "Loading...". Замените их вашими computed-сигналами:

1. Для уведомлений замените `Loading...` на блок @if:

```angular-html
@if (notificationsEnabled()) {
  Enabled
} @else {
  Disabled
}
```

2. Для сообщения замените `Loading...` на:

```angular-html
{{ statusMessage() }}
```

3. Для рабочего времени замените `Loading...` на блок @if:

```angular-html
@if (isWithinWorkingHours()) {
  Yes
} @else {
  No
}
```

Обратите внимание, что computed-сигналы вызываются так же, как и обычные сигналы — со скобками!
</docs-step>

</docs-workflow>

Отлично! Теперь вы научились создавать computed-сигналы.

Вот несколько ключевых моментов, которые следует запомнить:

- **Computed-сигналы реактивны**: они автоматически обновляются при изменении их зависимостей.
- **Они доступны только для чтения**: вы не можете напрямую задавать вычисляемые значения, они являются производными от
  других сигналов.
- **Они могут содержать сложную логику**: используйте их для вычислений, преобразований и получения производного
  состояния.
- **Они обеспечивают способ выполнения производительных вычислений на основе динамического состояния**: Angular
  пересчитывает их только тогда, когда их зависимости действительно изменяются.

В следующем уроке вы узнаете
о [другом способе получения состояния с помощью linkedSignals](/tutorials/signals/3-deriving-state-with-linked-signals)!
