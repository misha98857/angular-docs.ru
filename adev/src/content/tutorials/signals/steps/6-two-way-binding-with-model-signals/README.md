# Двусторонняя привязка с использованием сигналов model()

Теперь, когда вы узнали,
как [передавать данные в компоненты с помощью input-сигналов](/tutorials/signals/5-component-communication-with-signals),
давайте изучим API `model()` в Angular для двусторонней привязки. Сигналы `model()` идеально подходят для
UI-компонентов, таких как чекбоксы, слайдеры или пользовательские элементы управления формой, где компонент должен как
получать значение, ТАК И обновлять его.

В этом задании вы создадите пользовательский компонент чекбокса, который управляет своим собственным состоянием,
сохраняя синхронизацию с родительским компонентом.

<hr />

<docs-workflow>

<docs-step title="Настройка пользовательского чекбокса с сигналом model()">
Создайте сигнал `model()` в компоненте `custom-checkbox`, который может как получать, так и обновлять значение родителя.

```ts
// Add imports for model signals
import {Component, model, input, ChangeDetectionStrategy} from '@angular/core';

// Model signal for two-way binding
checked = model.required<boolean>();

// Optional input for label
label = input<string>('');
```

В отличие от сигналов `input()`, которые доступны только для чтения, сигналы `model()` можно как читать, так и
записывать.
</docs-step>

<docs-step title="Создание шаблона чекбокса">
Создайте шаблон чекбокса, который реагирует на клики и обновляет свою модель.

```html
<label class="custom-checkbox">
  <input
    type="checkbox"
    [checked]="checked()"
    (change)="toggle()">
  <span class="checkmark"></span>
  {{ label() }}
</label>
```

Компонент считывает данные из своего сигнала `model()` и имеет метод для его обновления.
</docs-step>

<docs-step title="Добавление метода переключения">
Реализуйте метод `toggle`, который обновляет сигнал `model()` при клике на чекбокс.

```ts
toggle() {
  // This updates BOTH the component's state AND the parent's model!
  this.checked.set(!this.checked());
}
```

Когда дочерний компонент вызывает `this.checked.set()`, он автоматически передает изменение обратно родителю. Это
ключевое отличие от сигналов `input()`.
</docs-step>

<docs-step title="Настройка двусторонней привязки в родительском компоненте">
Сначала раскомментируйте свойства model-сигналов и методы в `app.ts`:

```ts
// Parent signal models
agreedToTerms = model(false);
enableNotifications = model(true);

// Methods to test two-way binding
toggleTermsFromParent() {
  this.agreedToTerms.set(!this.agreedToTerms());
}

resetAll() {
  this.agreedToTerms.set(false);
  this.enableNotifications.set(false);
}
```

Затем обновите шаблон:

Часть 1. **Раскомментируйте чекбоксы и добавьте двустороннюю привязку:**

- Замените `___ADD_TWO_WAY_BINDING___` на `[(checked)]="agreedToTerms"` для первого чекбокса
- Замените `___ADD_TWO_WAY_BINDING___` на `[(checked)]="enableNotifications"` для второго

Часть 2. **Замените заполнители `???` на блоки @if:**

```angular-html
@if (agreedToTerms()) {
  Yes
} @else {
  No
}

@if (enableNotifications()) {
  Yes
} @else {
  No
}
```

Часть 3. **Добавьте обработчики кликов к кнопкам:**

```html
<button (click)="toggleTermsFromParent()">Toggle Terms from Parent</button>
<button (click)="resetAll()">Reset All</button>
```

Синтаксис `[(checked)]` создает двустороннюю привязку — данные передаются вниз в компонент, А изменения передаются
обратно родителю путем генерации события, которое ссылается на сам сигнал и _не_ вызывает геттер сигнала напрямую.
</docs-step>

<docs-step title="Проверка двусторонней привязки">
Взаимодействуйте с приложением, чтобы увидеть двустороннюю привязку в действии:

1. **Нажмите на чекбоксы** — Компонент обновляет свое состояние и уведомляет родителя
2. **Нажмите «Toggle Terms from Parent»** — Обновления родителя передаются вниз в компонент
3. **Нажмите «Reset All»** — Родитель сбрасывает обе модели, и компоненты обновляются автоматически

И родитель, и дочерний компонент могут обновлять общее состояние, и оба автоматически остаются синхронизированными!
</docs-step>

</docs-workflow>

Отлично! Вы узнали, как сигналы `model()` обеспечивают двустороннюю привязку:

- **Сигналы `model()`** — Используйте `model()` и `model.required()` для значений, которые можно как читать, так и
  записывать
- **Двусторонняя привязка** — Используйте синтаксис `[(property)]` для привязки сигналов родителя к моделям дочернего
  компонента
- **Идеально для UI-компонентов** — Чекбоксы, элементы управления формами и виджеты, которым нужно управлять своим
  собственным состоянием
- **Автоматическая синхронизация** — Родитель и дочерний компонент остаются синхронизированными без ручной обработки
  событий

**Когда использовать `model()` вместо `input()`:**

- Используйте `input()` для данных, которые передаются только вниз (данные для отображения, конфигурация)
- Используйте `model()` для UI-компонентов, которым нужно обновлять свое значение (элементы управления формами,
  переключатели)

В следующем уроке вы узнаете об [использовании сигналов с сервисами](/tutorials/signals/7-using-signals-with-services)!
