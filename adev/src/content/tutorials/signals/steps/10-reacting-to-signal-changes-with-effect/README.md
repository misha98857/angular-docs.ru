# Reacting to signal changes with effect

Теперь, когда вы
изучили [запрос дочерних элементов с помощью сигнальных запросов](/tutorials/signals/9-query-child-elements-with-signal-queries),
давайте рассмотрим, как реагировать на изменения сигналов с помощью эффектов. Эффекты — это функции, которые запускаются
автоматически при изменении их зависимостей, что делает их идеальными для побочных эффектов, таких как логирование,
манипуляции с DOM или вызовы API.

**Важно: Эффекты должны быть последним средством, к которому вы прибегаете.** Всегда отдавайте предпочтение `computed()`
для производных значений и `linkedSignal()` для значений, которые могут быть как производными, так и заданными вручную.
Если вы копируете данные из одного сигнала в другой с помощью эффекта, это признак того, что вам следует переместить
источник истины выше и использовать вместо этого `computed()` или `linkedSignal()`. Эффекты лучше всего подходят для
синхронизации состояния сигналов с императивными API, не использующими сигналы.

В этом упражнении вы узнаете, как правильно использовать функцию `effect()` для обоснованных побочных эффектов,
реагирующих на изменения сигналов.

<hr />

У вас есть приложение менеджера тем с уже настроенными сигналами. Теперь вы добавите эффекты для автоматического
реагирования на изменения сигналов.

<docs-workflow>

<docs-step title="Импорт функции effect">
Добавьте `effect` в существующие импорты.

```ts
// Add effect to existing imports
import {Component, signal, computed, effect, ChangeDetectionStrategy} from '@angular/core';
```

Функция `effect` создает реактивный побочный эффект, который запускается автоматически при изменении любых сигналов,
которые он читает.
</docs-step>

<docs-step title="Создание эффекта для local storage">
Добавьте эффект, который автоматически сохраняет тему в локальное хранилище (local storage) при её изменении.

```ts
constructor() {
  // Save theme to localStorage whenever it changes
  effect(() => {
    localStorage.setItem('theme', this.theme());
    console.log('Theme saved to localStorage:', this.theme());
  });
}
```

Этот эффект запускается всякий раз, когда меняется сигнал темы, автоматически сохраняя предпочтения пользователя.
</docs-step>

<docs-step title="Создание эффекта для логирования активности пользователя">
Добавьте эффект, который логирует вход или выход пользователя из системы.

```ts
constructor() {
  // ... previous effect

  // Log user activity changes
  effect(() => {
    const status = this.isLoggedIn() ? 'logged in' : 'logged out';
    const user = this.username();
    console.log(`User ${user} is ${status}`);
  });
}
```

Этот пример демонстрирует, как эффекты могут читать несколько сигналов и реагировать на изменения в любом из них.
</docs-step>

<docs-step title="Создание эффекта с очисткой">
Добавьте эффект, который устанавливает таймер и выполняет очистку при уничтожении компонента.

```ts
constructor() {
  // ... previous effects

  // Timer effect with cleanup
  effect((onCleanup) => {
    const interval = setInterval(() => {
      console.log('Timer tick - Current theme:', this.theme());
    }, 5000);

    // Clean up the interval when the effect is destroyed
    onCleanup(() => {
      clearInterval(interval);
      console.log('Timer cleaned up');
    });
  });
}
```

Этот эффект демонстрирует, как очищать ресурсы при уничтожении или повторном запуске эффектов.
</docs-step>

<docs-step title="Проверка эффектов">
Откройте консоль браузера и повзаимодействуйте с приложением:

- **Toggle Theme** — Убедитесь, что данные сохраняются в localStorage и появляются логи таймера.
- **Login/Logout** — Убедитесь в наличии логов активности пользователя.
- **Watch Timer** — Наблюдайте за периодическим логированием темы каждые 5 секунд.

Эффекты запускаются автоматически всякий раз, когда меняются отслеживаемые ими сигналы!
</docs-step>

</docs-workflow>

Отлично! Теперь вы научились использовать эффекты с сигналами. Ключевые концепции, которые нужно запомнить:

- **Эффекты реактивны**: Они автоматически запускаются при изменении любого сигнала, который они читают.
- **Только побочные эффекты**: Идеально подходят для логирования, манипуляций с DOM, вызовов API и синхронизации с
  императивными API.
- **Очистка**: Используйте колбэк `onCleanup` для очистки ресурсов, таких как таймеры или подписки.
- **Автоматическое отслеживание**: Эффекты автоматически отслеживают, какие сигналы они читают, и перезапускаются при
  изменении этих сигналов.

**Помните: используйте эффекты с осторожностью!** Примеры в этом уроке (синхронизация с localStorage, логирование,
таймеры) являются подходящими вариантами использования. Избегайте эффектов для:

- Вычисления значений на основе других сигналов — используйте вместо этого `computed()`.
- Создания записываемого производного состояния — используйте вместо этого `linkedSignal()`.
- Копирования данных между сигналами — реструктурируйте код, чтобы использовать общий источник истины.

Эффекты мощны, но должны быть вашим последним средством, когда `computed()` и `linkedSignal()` не могут решить вашу
задачу.
