# Nullish coalescing для не-nullable значений

Эта диагностика обнаруживает бесполезные символы оператора объединения с null (`??`) в шаблонах Angular.
В частности, она ищет операции, где входное значение не является "nullable", то есть его тип не включает `null` или
`undefined`.
Для таких значений правая часть `??` никогда не будет использована.

```angular-ts
import {Component} from '@angular/core';

@Component({
  // Шаблон отображает `username`, если он есть, или 'root', если он
  // `null` или `undefined`.
  template: `<div>{{ username ?? 'root' }}</div>`,
})
class MyComponent {
  // `username` объявлен как `string`, который _не может_ быть `null` или
  // `undefined`.
  username: string = 'Angelino';
}
```

## В чем проблема?

Использование оператора объединения с null с не-nullable входным значением не имеет эффекта и указывает на
несоответствие между допустимым типом значения и тем, как оно представлено в шаблоне.
Разработчик может обоснованно предположить, что правая часть оператора объединения с null будет отображена в каком-то
случае, но на самом деле она никогда не будет показана.
Это может привести к путанице относительно ожидаемого вывода программы.

## Что следует сделать вместо этого?

Обновите шаблон и объявленный тип, чтобы синхронизировать их.
Дважды проверьте тип входных данных и убедитесь, действительно ли ожидается, что он может быть nullable.

Если входное значение должно быть nullable, добавьте `null` или `undefined` к его типу, чтобы указать это.

```angular-ts

import {Component} from '@angular/core';

@Component({
template: `<div>{{ username ?? 'root' }}</div>`,
})
class MyComponent {
// Теперь `username` является nullable. Если он когда-либо станет `null`, отобразится 'root'.
username: string | null = 'Angelino';
}

```

Если входное значение _не_ должно быть nullable, удалите оператор `??` и его правый операнд, так как TypeScript
гарантирует, что значение всегда будет не-nullable.

```angular-ts

import {Component} from '@angular/core';

@Component({
// Шаблон всегда отображает `username`, который гарантированно никогда не будет `null`
// или `undefined`.
template: `<div>{{ username }}</div>`,
})
class MyComponent {
username: string = 'Angelino';
}

```

## Требования к конфигурации

Для работы любой расширенной диагностики должен быть включен параметр [
`strictTemplates`](tools/cli/template-typecheck#strict-mode).
Также должен быть включен параметр [`strictNullChecks`](tools/cli/template-typecheck#strict-null-checks) для вывода
диагностики `nullishCoalescingNotNullable`.

## Что делать, если этого нельзя избежать?

Эту диагностику можно отключить, отредактировав файл `tsconfig.json` проекта:

```json

{
  "angularCompilerOptions": {
    "extendedDiagnostics": {
      "checks": {
        "nullishCoalescingNotNullable": "suppress"
      }
    }
  }
}
```

См. [конфигурацию расширенной диагностики](extended-diagnostics#configuration) для получения дополнительной информации.
