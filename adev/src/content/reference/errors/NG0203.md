# inject() должен вызываться в контексте внедрения

Эта ошибка возникает при попытке использовать функцию [`inject`](api/core/inject) вне
допустимого [контекста внедрения](guide/di/dependency-injection-context). Контекст внедрения доступен во время создания
и инициализации класса. Он также доступен для функций, используемых внутри `runInInjectionContext`.

На практике вызовы `inject()` допускаются в конструкторе, в качестве параметра конструктора и в инициализаторе поля:

```typescript
@Injectable({providedIn: 'root'})
export class Car {
  radio: Radio|undefined;

  // OK: инициализатор поля
  spareTyre = inject(Tyre);

  constructor() {
    // OK: тело конструктора
    this.radio = inject(Radio);
  }
}
```

Также допустимо вызывать [`inject`](api/core/inject) из фабрики провайдера:

```typescript
providers: [
  {provide: Car, useFactory: () => {
    // OK: фабрика класса
    const engine = inject(Engine);
    return new Car(engine);
  }}
]
```

Вызовы функции [`inject`](api/core/inject) вне процесса создания класса или `runInInjectionContext` приведут к ошибке. В
частности, вызовы `inject()` недопустимы после создания экземпляра класса, например, в методах (включая хуки жизненного
цикла):

```typescript
@Component({ ... })
export class CarComponent {
  ngOnInit() {
    // ОШИБКА: слишком поздно, экземпляр компонента уже создан
    const engine = inject(Engine);
    engine.start();
  }
}
```

## Отладка ошибки

Проанализируйте трассировку стека (stack trace) ошибки, чтобы найти место, где происходит недопустимый вызов `inject()`.

Для исправления ошибки переместите вызов [`inject`](api/core/inject) в допустимое место (обычно это конструктор класса
или инициализатор поля).

**ПРИМЕЧАНИЕ:** Если вы работаете в контексте тестирования, `TestBed.runInInjectionContext` позволит успешно
использовать `inject()`.

```typescript
TestBed.runInInjectionContext(() => {
   // ...
});
```
