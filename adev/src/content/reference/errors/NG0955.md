# Выражение track вернуло дублирующиеся ключи для заданной коллекции

Выражение `track`, указанное в цикле `@for`, вычислило дублирующиеся ключи для данной коллекции. Например:

```angular-ts
@Component({
    template: `@for (item of items; track item.value) {{{item.value}}}`,
})
class TestComponent {
    items = [{key: 1, value: 'a'}, {key: 2, value: 'b'}, {key: 3, value: 'a'}];
}
```

В приведенном примере выражение отслеживания `item.value` обнаружит два дублирующихся ключа `a` (с индексами 0 и 2).

Дублирующиеся ключи создают проблемы с точки зрения корректности: поскольку цикл `@for` не может однозначно
идентифицировать элементы, при перемещении или удалении узлов DOM он может выбрать узлы, соответствующие _другому_
элементу (с таким же ключом).

Кроме того, дублирование ключей снижает производительность: при итерации по коллекциям с дублирующимися ключами Angular
вынужден использовать более сложные и медленные внутренние структуры данных.

## Исправление ошибки

Измените выражение `track` так, чтобы оно однозначно идентифицировало элемент в коллекции. В рассматриваемом примере
правильное выражение должно использовать уникальное свойство `key` (`item.key`):

```angular-ts
@Component({
    template: `@for (item of items; track item.key) {{{item.value}}}`,
})
class TestComponent {
    items = [{key: 1, value: 'a'}, {key: 2, value: 'b'}, {key: 3, value: 'a'}];
}
```
