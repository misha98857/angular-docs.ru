# Недопустимый вызов функции внутри реактивного контекста

Функция, запуск которой запрещен внутри реактивного контекста, была вызвана из реактивного контекста.

Например, `effect` нельзя планировать внутри `computed` или активно выполняющегося эффекта.
Избегайте вызова функций, таких как `effect`, в выражениях шаблона, так как они выполняются в собственном реактивном
контексте.

Ожидается, что выражения `computed` будут чистыми.
"Чистое" означает, что выражение не вызывает никаких побочных эффектов.
Побочные эффекты — это такие операции, как планирование `afterNextRender`/`afterEveryRender`, создание нового `effect`
или подписка на Observable.

Некоторые операции явно запрещены внутри реактивных контекстов, чтобы избежать распространенных ошибок.
Например, использование `afterNextRender`/`afterEveryRender` внутри `computed` будет планировать новые хуки рендеринга
каждый раз при вычислении выражения.
Вероятно, это не то, что задумывалось, и может снизить производительность приложения.

### Исправление ошибки

Это руководство по ошибкам не является исчерпывающим.
В нем описаны несколько распространенных сценариев и способы устранения ошибки.

#### `afterNextRender`/`afterEveryRender`

Переместите вызов `afterNextRender`/`afterEveryRender` за пределы реактивного контекста.

Хорошим местом для планирования хука после рендеринга является конструктор класса компонента.
В качестве альтернативы используйте `untracked`, чтобы выйти из реактивного контекста и явно отказаться от проверки этой
ошибки.

#### `effect`

Переместите вызов `effect` за пределы реактивного контекста.

Хорошим местом для планирования эффекта является конструктор класса `@Component`.

#### `toSignal`

Переместите вызов `toSignal` за пределы реактивного контекста.

```typescript
result = computed(() => {
  const dataSignal = toSignal(dataObservable$);
  return doSomething(dataSignal());
});
```

можно переписать так:

```typescript
dataSignal = toSignal(dataObservable$);
result = computed(() => doSomething(dataSignal()));
```

В качестве альтернативы, если это невозможно, рассмотрите возможность подписки на Observable вручную.

В крайнем случае используйте `untracked` для выхода из реактивного контекста.
Будьте осторожны, так как выход из реактивного контекста может привести к тому, что чтение сигналов внутри `untracked`
будет проигнорировано.

@debugging

В сообщении об ошибке упоминается функция, которая была неожиданно вызвана.
Найдите вызов этой функции в коде вашего приложения.

Кроме того, трассировка стека (stack trace) в браузере покажет, где была вызвана функция и где она находится.
