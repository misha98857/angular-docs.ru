# Система сборки приложений Angular

В версии 17 и выше новая система сборки предоставляет улучшенный способ сборки приложений Angular. Эта новая система
сборки включает:

- Современный формат вывода с использованием ESM, с выражениями динамического импорта для поддержки ленивой загрузки
  модулей.
- Более высокую производительность сборки как для начальных, так и для инкрементальных сборок.
- Новые инструменты экосистемы JavaScript, такие как [esbuild](https://esbuild.github.io/)
  и [Vite](https://vitejs.dev/).
- Интегрированные возможности SSR и пререндеринга.
- Автоматическую горячую замену глобальных стилей и стилей компонентов.

Эта новая система сборки стабильна и полностью поддерживается для использования в приложениях Angular.
Вы можете перевести на новую систему сборки приложения, использующие билдер `browser`.
Если используется пользовательский билдер, пожалуйста, обратитесь к документации этого билдера для получения информации
о возможных вариантах миграции.

ВАЖНО: Существующая система сборки на основе webpack по-прежнему считается стабильной и полностью поддерживается.
Приложения могут продолжать использовать билдер `browser`, и проекты могут отказаться от миграции во время обновления.

## Для новых приложений

Новые приложения будут использовать эту новую систему сборки по умолчанию через билдер `application`.

## Для существующих приложений

Доступны как автоматические, так и ручные процедуры в зависимости от требований проекта.
Начиная с v18, процесс обновления спросит, хотите ли вы перенести существующие приложения на новую систему сборки с
помощью автоматической миграции.
Перед миграцией рассмотрите возможность ознакомления с разделом [Известные проблемы](#known-issues), так как он может
содержать важную информацию для вашего проекта.

ПОЛЕЗНО: Не забудьте удалить любые предположения CommonJS в коде сервера приложения при использовании SSR, такие как
`require`, `__filename`, `__dirname` или другие конструкции
из [области видимости модуля CommonJS](https://nodejs.org/api/modules.html#the-module-scope). Весь код приложения должен
быть совместим с ESM. Это не относится к сторонним зависимостям.

### Автоматическая миграция (Рекомендуется)

Автоматическая миграция скорректирует как конфигурацию приложения в `angular.json`, так и код и таблицы стилей, чтобы
удалить использование функций, специфичных для webpack.
Хотя многие изменения могут быть автоматизированы, и большинству приложений не потребуются дальнейшие изменения, каждое
приложение уникально, и могут потребоваться некоторые ручные правки.
После миграции попробуйте собрать приложение, так как могут возникнуть новые ошибки, требующие корректировки кода.
Ошибки будут пытаться предложить решения проблемы, когда это возможно, а в последующих разделах этого руководства
описаны некоторые из наиболее распространенных ситуаций, с которыми вы можете столкнуться.
При обновлении до Angular v18 через `ng update` вам будет предложено выполнить миграцию.
Эта миграция полностью необязательна для v18 и может быть запущена вручную в любое время после обновления с помощью
следующей команды:

```shell

ng update @angular/cli --name use-application-builder

```

Миграция выполняет следующее:

- Преобразует существующий таргет `browser` или `browser-esbuild` в `application`.
- Удаляет любые предыдущие SSR-билдеры (поскольку `application` теперь делает это сам).
- Соответствующим образом обновляет конфигурацию.
- Объединяет `tsconfig.server.json` с `tsconfig.app.json` и добавляет опцию TypeScript `"esModuleInterop": true`, чтобы
  гарантировать [совместимость импортов `express` с ESM](#esm-default-imports-vs-namespace-imports).
- Обновляет код сервера приложения для использования новой начальной загрузки и структуры выходных каталогов.
- Удаляет любое использование таблиц стилей, специфичное для webpack-билдера, такое как тильда или карет в `@import`/
  `url()`, и обновляет конфигурацию для обеспечения эквивалентного поведения.
- Переводит на использование нового пакета Node.js `@angular/build` с меньшим количеством зависимостей, если не найдено
  другое использование `@angular-devkit/build-angular`.

### Ручная миграция

Кроме того, для существующих проектов вы можете вручную включить использование нового билдера для каждого приложения с
двумя различными вариантами.
Оба варианта считаются стабильными и полностью поддерживаются командой Angular.
Выбор варианта зависит от того, сколько изменений вам нужно внести для миграции и какие новые функции вы хотели бы
использовать в проекте.

- Билдер `browser-esbuild` собирает только клиентский бандл приложения, разработанный для совместимости с существующим
  билдером `browser`, который предоставляет прежнюю систему сборки.
  Этот билдер предоставляет эквивалентные параметры сборки и во многих случаях служит прямой заменой для существующих
  приложений `browser`.
- Билдер `application` охватывает все приложение, например, клиентский бандл, а также опционально сборку сервера для
  SSR (рендеринга на стороне сервера) и выполнение пререндеринга статических страниц во время сборки.

Билдер `application` обычно предпочтительнее, так как он улучшает сборки с рендерингом на стороне сервера (SSR) и
упрощает внедрение SSR в будущем для проектов с рендерингом на стороне клиента.
Однако это требует немного больше усилий по миграции, особенно для существующих SSR-приложений, если выполняется
вручную.
Если внедрение билдера `application` затруднительно для вашего проекта, `browser-esbuild` может стать более простым
решением, которое дает большинство преимуществ производительности сборки с меньшим количеством критических изменений.

#### Ручная миграция на билдер совместимости

Билдер с именем `browser-esbuild` доступен в пакете `@angular-devkit/build-angular`, который присутствует в приложении,
созданном Angular CLI.
Вы можете попробовать новую систему сборки для приложений, использующих билдер `browser`.
Если используется пользовательский билдер, пожалуйста, обратитесь к документации этого билдера для получения информации
о возможных вариантах миграции.

Опция совместимости была реализована для минимизации количества изменений, необходимых для первоначальной миграции ваших
приложений.
Это обеспечивается через альтернативный билдер (`browser-esbuild`).
Вы можете обновить таргет `build` для любого приложения, чтобы перейти на новую систему сборки.

Ниже приведено то, что вы обычно найдете в `angular.json` для приложения:

```json
...
"architect": {
  "build": {
    "builder": "@angular-devkit/build-angular:browser",
...
```

Изменение поля `builder` — это единственное изменение, которое вам нужно сделать.

```json
...
"architect": {
  "build": {
    "builder": "@angular-devkit/build-angular:browser-esbuild",
...
```

#### Ручная миграция на новый билдер `application`

Билдер с именем `application` также доступен в пакете `@angular-devkit/build-angular`, который присутствует в
приложении, созданном Angular CLI.
Этот билдер является стандартным для всех новых приложений, созданных через `ng new`.

Ниже приведено то, что вы обычно найдете в `angular.json` для приложения:

```json
...
"architect": {
  "build": {
    "builder": "@angular-devkit/build-angular:browser",
...
```

Изменение поля `builder` — это первое изменение, которое вам нужно сделать.

```json
...
"architect": {
  "build": {
    "builder": "@angular-devkit/build-angular:application",
...
```

После изменения имени билдера необходимо обновить опции внутри таргета `build`.
В следующем списке обсуждаются все опции билдера `browser`, которые необходимо скорректировать.

- `main` следует переименовать в `browser`.
- `polyfills` должен быть массивом, а не одним файлом.
- `buildOptimizer` следует удалить, так как это покрывается опцией `optimization`.
- `resourcesOutputPath` следует удалить, теперь это всегда `media`.
- `vendorChunk` следует удалить, так как эта оптимизация производительности больше не нужна.
- `commonChunk` следует удалить, так как эта оптимизация производительности больше не нужна.
- `deployUrl` следует удалить, так как она не поддерживается. Вместо этого используйте [
  `<base href>`](guide/routing/common-router-tasks).
  См. [документацию по развертыванию](tools/cli/deployment#--deploy-url) для получения дополнительной информации.
- `ngswConfigPath` следует переименовать в `serviceWorker`.

Если приложение в данный момент не использует SSR, это должно быть последним шагом, позволяющим `ng build` работать.
После выполнения `ng build` в первый раз могут появиться новые предупреждения или ошибки, основанные на поведенческих
различиях или использовании приложением функций, специфичных для webpack.
Многие предупреждения предложат способы устранения проблемы.
Если кажется, что предупреждение неверно или решение неочевидно, пожалуйста, откройте issue
на [GitHub](https://github.com/angular/angular-cli/issues).
Кроме того, в последующих разделах этого руководства представлена дополнительная информация по нескольким конкретным
случаям, а также по текущим известным проблемам.

Для приложений, впервые использующих SSR, [Руководство по Angular SSR](guide/ssr) предоставляет дополнительную
информацию о процессе настройки для добавления SSR в приложение.

Для приложений, которые уже используют SSR, потребуются дополнительные корректировки для обновления сервера приложения,
чтобы поддерживать новые интегрированные возможности SSR.
Билдер `application` теперь предоставляет интегрированную функциональность для всех следующих ранее существовавших
билдеров:

- `app-shell`
- `prerender`
- `server`
- `ssr-dev-server`

Процесс `ng update` автоматически удалит использование пакетов области видимости `@nguniversal`, где ранее находились
некоторые из этих билдеров.
Новый пакет `@angular/ssr` также будет автоматически добавлен и использован с корректировкой конфигурации и кода во
время обновления.
Пакет `@angular/ssr` поддерживает как билдер `browser`, так и билдер `application`.

## Выполнение сборки

После обновления конфигурации приложения сборки можно выполнять с помощью `ng build`, как это делалось ранее.
В зависимости от выбора миграции билдера некоторые параметры командной строки могут отличаться.
Если команда сборки содержится в каких-либо скриптах `npm` или других скриптах, убедитесь, что они проверены и
обновлены.
Для приложений, которые перешли на билдер `application` и используют SSR и/или пререндеринг, вы также можете удалить
лишние команды `ng run` из скриптов, так как `ng build` теперь имеет встроенную поддержку SSR.

```shell

ng build

```

## Запуск сервера разработки

Сервер разработки автоматически обнаружит новую систему сборки и будет использовать ее для сборки приложения.
Для запуска сервера разработки не требуется никаких изменений в конфигурации билдера `dev-server` или командной строке.

```shell

ng serve

```

Вы можете продолжать использовать [параметры командной строки](/cli/serve), которые вы использовали в прошлом с сервером
разработки.

ПОЛЕЗНО: При использовании сервера разработки вы можете заметить небольшую вспышку нестилизованного контента (FOUC) при
запуске, пока сервер инициализируется.
Сервер разработки пытается отложить обработку таблиц стилей до первого использования, чтобы улучшить время пересборки.
Это не будет происходить в сборках вне сервера разработки.

### Hot module replacement (Горячая замена модулей)

Hot Module Replacement (HMR) — это техника, используемая серверами разработки, чтобы избежать перезагрузки всей страницы
при изменении только части приложения.
Изменения во многих случаях могут быть немедленно отображены в браузере, что позволяет улучшить цикл
редактирования/обновления при разработке приложения.
Хотя общая замена горячих модулей (HMR) на основе JavaScript в настоящее время не поддерживается, доступны несколько
более специфичных форм HMR:

- **глобальная таблица стилей** (опция сборки `styles`)
- **таблица стилей компонента** (встроенная и файловая)
- **шаблон компонента** (встроенный и файловый)

Возможности HMR включаются автоматически и не требуют изменений кода или конфигурации для использования.
Angular предоставляет поддержку HMR как для файловых (`templateUrl`/`styleUrl`/`styleUrls`), так и для встроенных (
`template`/`styles`) стилей и шаблонов компонентов.
Система сборки попытается скомпилировать и обработать минимальное количество кода приложения, когда обнаружит изменение
только таблицы стилей.

При желании возможности HMR можно отключить, установив опцию сервера разработки `hmr` в `false`.
Это также можно изменить в командной строке с помощью:

```shell

ng serve --no-hmr

```

### Vite в качестве сервера разработки

Использование Vite в Angular CLI в настоящее время осуществляется _только в качестве сервера разработки_. Даже без
использования базовой системы сборки Vite, Vite предоставляет полнофункциональный сервер разработки с поддержкой
клиентской части, который был упакован в npm-пакет с малым количеством зависимостей. Это делает его идеальным кандидатом
для обеспечения комплексной функциональности сервера разработки. Текущий процесс сервера разработки использует новую
систему сборки для создания сборки приложения для разработки в памяти и передает результаты в Vite для обслуживания
приложения. Использование Vite, как и сервера разработки на основе Webpack, инкапсулировано внутри билдера Angular CLI
`dev-server` и в настоящее время не может быть настроено напрямую.

### Предварительная сборка (Prebundling)

Предварительная сборка обеспечивает улучшенное время сборки и пересборки при использовании сервера разработки.
Vite предоставляет [возможности предварительной сборки](https://vite.dev/guide/dep-pre-bundling), которые включены по
умолчанию при использовании Angular CLI.
Процесс предварительной сборки анализирует все сторонние зависимости проекта и обрабатывает их при первом запуске
сервера разработки.
Этот процесс устраняет необходимость пересобирать зависимости проекта каждый раз, когда происходит пересборка или
запускается сервер разработки.

В большинстве случаев дополнительная настройка не требуется. Однако некоторые ситуации, где она может понадобиться,
включают:

- Настройка поведения загрузчика для импортов внутри зависимости, например, [опция
  `loader`](#file-extension-loader-customization).
- Создание символической ссылки на зависимость к локальному коду для разработки, например, [
  `npm link`](https://docs.npmjs.com/cli/v10/commands/npm-link).
- Обход ошибки, возникшей во время предварительной сборки зависимости.

Процесс предварительной сборки может быть полностью отключен, или отдельные зависимости могут быть исключены, если это
необходимо проекту.
Для этих настроек можно использовать опцию `prebundle` билдера `dev-server`.
Чтобы исключить конкретные зависимости, доступна опция `prebundle.exclude`:

```json
    "serve": {
      "builder": "@angular/build:dev-server",
      "options": {
        "prebundle": {
          "exclude": ["some-dep"]
        }
      },
```

По умолчанию `prebundle` установлено в `true`, но может быть установлено в `false` для полного отключения
предварительной сборки.
Однако вместо этого рекомендуется исключать конкретные зависимости, так как время пересборки увеличится при отключенной
предварительной сборке.

```json
    "serve": {
      "builder": "@angular/build:dev-server",
      "options": {
        "prebundle": false
      },
```

## Новые функции

Одним из главных преимуществ системы сборки `application` является улучшенная скорость сборки и пересборки.
Однако новая система сборки приложений также предоставляет дополнительные функции, отсутствующие в билдере `browser`.

ВАЖНО: Новые функции билдера `application`, описанные здесь, по умолчанию несовместимы с билдером тестов `karma`,
поскольку он внутренне использует билдер `browser`.
Пользователи могут включить использование билдера `application`, установив опцию `builderMode` в значение `application`
для билдера `karma`.
Эта опция в настоящее время находится в стадии предварительного просмотра для разработчиков.
Если вы заметите какие-либо проблемы, пожалуйста, сообщите о них [здесь](https://github.com/angular/angular-cli/issues).

### Замена значений во время сборки с помощью `define`

Опция `define` позволяет заменять идентификаторы, присутствующие в коде, на другое значение во время сборки.
Это похоже на поведение `DefinePlugin` из Webpack, который ранее использовался в некоторых пользовательских
конфигурациях Webpack со сторонними билдерами.
Опцию можно использовать либо в файле конфигурации `angular.json`, либо в командной строке.
Настройка `define` в `angular.json` полезна для случаев, когда значения являются постоянными и могут быть зафиксированы
в системе контроля версий.

В файле конфигурации опция имеет форму объекта.
Ключи объекта представляют идентификатор для замены, а значения объекта представляют соответствующее значение замены для
идентификатора.
Пример выглядит следующим образом:

```json
  "build": {
    "builder": "@angular/build:application",
    "options": {
      ...
      "define": {
          "SOME_NUMBER": "5",
          "ANOTHER": "'this is a string literal, note the extra single quotes'",
          "REFERENCE": "globalThis.someValue.noteTheAbsentSingleQuotes"
      }
    }
  }
```

ПОЛЕЗНО: Все значения замены определяются как строки в файле конфигурации.
Если замена должна быть фактическим строковым литералом, она должна быть заключена в одинарные кавычки.
Это обеспечивает гибкость использования любого допустимого типа JSON, а также другого идентификатора в качестве замены.

Использование командной строки предпочтительнее для значений, которые могут меняться при каждом выполнении сборки, таких
как хеш коммита git или переменная окружения.
CLI объединит значения `--define` из командной строки со значениями `define` из `angular.json`, включив и те, и другие в
сборку.
Использование командной строки имеет приоритет, если один и тот же идентификатор присутствует в обоих местах.
Для использования в командной строке опция `--define` использует формат `IDENTIFIER=VALUE`.

```shell
ng build --define SOME_NUMBER=5 --define "ANOTHER='these will overwrite existing'"
```

Переменные окружения также могут быть выборочно включены в сборку.
Для оболочек, отличных от Windows, кавычки вокруг хеш-литерала можно экранировать напрямую, если это предпочтительно.
Этот пример предполагает bash-подобную оболочку, но аналогичное поведение доступно и для других оболочек.

```shell
export MY_APP_API_HOST="http://example.com"
export API_RETRY=3
ng build --define API_HOST=\'$MY_APP_API_HOST\' --define API_RETRY=$API_RETRY
```

Для любого варианта использования TypeScript должен знать типы идентификаторов, чтобы предотвратить ошибки проверки
типов во время сборки.
Этого можно достичь с помощью дополнительного файла определения типов в исходном коде приложения (например,
`src/types.d.ts`) с похожим содержимым:

```ts
declare const SOME_NUMBER: number;
declare const ANOTHER: string;
declare const GIT_HASH: string;
declare const API_HOST: string;
declare const API_RETRY: number;
```

Конфигурация проекта по умолчанию уже настроена на использование любых файлов определения типов, присутствующих в
исходных каталогах проекта.
Если конфигурация TypeScript для проекта была изменена, возможно, ее потребуется скорректировать, чтобы ссылаться на
этот недавно добавленный файл определения типов.

ВАЖНО: Эта опция не заменит идентификаторы, содержащиеся в метаданных Angular, таких как декоратор компонента или
директивы.

### Настройка загрузчика расширений файлов {#file-extension-loader-customization}

ВАЖНО: Эта функция доступна только с билдером `application`.

Некоторым проектам может потребоваться контролировать, как все файлы с определенным расширением загружаются и собираются
в приложение.
При использовании билдера `application` для обработки этих случаев можно использовать опцию `loader`.
Опция позволяет проекту определить тип загрузчика для использования с указанным расширением файла.
Файл с определенным расширением затем может быть использован в коде приложения через оператор импорта или выражение
динамического импорта.
Доступные загрузчики, которые можно использовать:

- `text` - встраивает содержимое как `string`, доступную как экспорт по умолчанию.
- `binary` - встраивает содержимое как `Uint8Array`, доступный как экспорт по умолчанию.
- `file` - создает файл в выходном пути приложения и предоставляет расположение файла во время выполнения как экспорт по
  умолчанию.
- `dataurl` - встраивает содержимое
  как [Data URL](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs).
- `base64` - встраивает содержимое как строку, закодированную в Base64.
- `empty` - считает содержимое пустым и не будет включать его в бандлы.

Значение `empty`, хотя и менее распространенное, может быть полезно для совместимости сторонних библиотек, которые могут
содержать специфичное для сборщика использование импорта, которое необходимо удалить.
Одним из примеров этого являются импорты с побочными эффектами (`import 'my.css';`) CSS-файлов, которые не имеют эффекта
в браузере.
Вместо этого проект может использовать `empty`, а затем CSS-файлы могут быть добавлены в опцию сборки `styles` или
использовать какой-либо другой метод внедрения.

Опция загрузчика представляет собой объект, где ключи используются для определения расширения файла, а значения — для
определения типа загрузчика.

Пример использования опции сборки для встраивания содержимого SVG-файлов в собранное приложение будет выглядеть
следующим образом:

```json
  "build": {
    "builder": "@angular/build:application",
    "options": {
      ...
      "loader": {
        ".svg": "text"
      }
    }
  }
```

Затем SVG-файл можно импортировать:

```ts
import contents from './some-file.svg';

console.log(contents); // <svg>...</svg>
```

Кроме того, TypeScript должен знать тип модуля для импорта, чтобы предотвратить ошибки проверки типов во время сборки.
Этого можно достичь с помощью дополнительного файла определения типов в исходном коде приложения (например,
`src/types.d.ts`) со следующим или похожим содержимым:

```ts
declare module "*.svg" {
  const content: string;
  export default content;
}
```

Конфигурация проекта по умолчанию уже настроена на использование любых файлов определения типов (`.d.ts`),
присутствующих в исходных каталогах проекта. Если конфигурация TypeScript для проекта была изменена, tsconfig может
потребоваться скорректировать, чтобы ссылаться на этот недавно добавленный файл определения типов.

### Настройка загрузчика атрибутов импорта

Для случаев, когда только определенные файлы должны загружаться определенным образом, доступен контроль поведения
загрузки для каждого файла.
Это достигается с помощью атрибута импорта
`loader` ([import attribute](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import/with)),
который можно использовать как с операторами импорта, так и с выражениями.
Наличие атрибута импорта имеет приоритет над всем остальным поведением загрузки, включая JS/TS и любые значения опции
сборки `loader`.
Для общей загрузки всех файлов иначе не поддерживаемого типа файла рекомендуется использовать опцию сборки [
`loader`](#file-extension-loader-customization).

Для атрибута импорта поддерживаются следующие значения загрузчика:

- `text` - встраивает содержимое как `string`, доступную как экспорт по умолчанию.
- `binary` - встраивает содержимое как `Uint8Array`, доступный как экспорт по умолчанию.
- `file` - создает файл в выходном пути приложения и предоставляет расположение файла во время выполнения как экспорт по
  умолчанию.
- `dataurl` - встраивает содержимое
  как [Data URL](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs).
- `base64` - встраивает содержимое как строку, закодированную в Base64.

Дополнительным требованием для использования атрибутов импорта является то, что опция TypeScript `module` должна быть
установлена в `esnext`, чтобы TypeScript мог успешно собрать код приложения.
Как только `ES2025` станет доступен в TypeScript, это изменение больше не потребуется.

В настоящее время TypeScript не поддерживает определения типов, основанные на значениях атрибутов импорта.
В настоящее время требуется использование `@ts-expect-error`/`@ts-ignore` или использование отдельных файлов определения
типов (при условии, что файл импортируется только с тем же атрибутом загрузчика).
В качестве примера, SVG-файл можно импортировать как текст следующим образом:

```ts
// @ts-expect-error TypeScript cannot provide types based on attributes yet
import contents from './some-file.svg' with { loader: 'text' };
```

То же самое можно сделать с помощью выражения импорта внутри асинхронной функции.

```ts
async function loadSvg(): Promise<string> {
  // @ts-expect-error TypeScript cannot provide types based on attributes yet
  return import('./some-file.svg', { with: { loader: 'text' } }).then((m) => m.default);
}
```

Для выражения импорта значение `loader` должно быть строковым литералом для статического анализа.
Будет выдано предупреждение, если значение не является строковым литералом.

Загрузчик `file` полезен, когда файл будет загружен во время выполнения через `fetch()`, установку `src` элемента
изображения или другой подобный метод.

```ts
// @ts-expect-error TypeScript cannot provide types based on attributes yet
import imagePath from './image.webp' with { loader: 'file' };

console.log(imagePath); // media/image-ULK2SIIB.webp
```

Загрузчик `base64` полезен, когда файл необходимо встроить непосредственно в бандл в виде закодированной строки, которую
позже можно использовать для создания Data URL.

```ts
// @ts-expect-error TypeScript cannot provide types based on attributes yet
import logo from './logo.png' with { loader: 'base64' };

console.log(logo) // "iVBORw0KGgoAAAANSUhEUgAA..."
```

Загрузчик `dataurl` для встраивания ресурсов как полных Data URL.

```ts
// @ts-expect-error TypeScript cannot provide types based on attributes yet
import icon from './icon.svg' with { loader: 'dataurl' };

console.log(icon);// "data:image/svg+xml;..."
```

Для производственных сборок, как показано в комментарии к коду выше, к пути будет автоматически добавлено хеширование
для долгосрочного кэширования.

ПОЛЕЗНО: При использовании сервера разработки и использовании атрибута `loader` для импорта файла из пакета Node.js,
этот пакет должен быть исключен из предварительной сборки с помощью опции `prebundle` сервера разработки.

### Условия импорта/экспорта

Проектам может потребоваться сопоставить определенные пути импорта с разными файлами в зависимости от типа сборки.
Это может быть особенно полезно для таких случаев, как `ng serve`, которому нужно использовать код, специфичный для
отладки/разработки, но `ng build`, которому нужно использовать код без каких-либо функций/информации разработки.
Несколько условий импорта/экспорта ([conditions](https://nodejs.org/api/packages.html#community-conditions-definitions))
автоматически применяются для поддержки этих потребностей проекта:

- Для оптимизированных сборок включено условие `production`.
- Для неоптимизированных сборок включено условие `development`.
- Для выходного кода браузера включено условие `browser`.

Оптимизированная сборка определяется значением опции `optimization`.
Когда `optimization` установлено в `true` или, более конкретно, если `optimization.scripts` установлено в `true`, то
сборка считается оптимизированной.
Эта классификация применяется как к `ng build`, так и к `ng serve`.
В новом проекте `ng build` по умолчанию оптимизирован, а `ng serve` по умолчанию не оптимизирован.

Полезный метод использования этих условий в коде приложения — комбинировать их
с [импортами подпутей](https://nodejs.org/api/packages.html#subpath-imports).
Используя следующий оператор импорта:

```ts
import {verboseLogging} from '#logger';
```

Файл можно переключить в поле `imports` в `package.json`:

```json
{
  ...
  "imports": {
    "#logger": {
      "development": "./src/logging/debug.ts",
      "default": "./src/logging/noop.ts"
    }
  }
}
```

Для приложений, которые также используют SSR, код браузера и сервера можно переключать с помощью условия `browser`:

```json
{
  ...
  "imports": {
    "#crashReporter": {
      "browser": "./src/browser-logger.ts",
      "default": "./src/server-logger.ts"
    }
  }
}
```

Эти условия также применяются к пакетам Node.js и любым определенным [
`exports`](https://nodejs.org/api/packages.html#conditional-exports) внутри пакетов.

ПОЛЕЗНО: Если в настоящее время используется опция сборки `fileReplacements`, эта функция может заменить ее
использование.

## Известные проблемы {#known-issues}

В настоящее время существует несколько известных проблем, с которыми вы можете столкнуться при попытке использовать
новую систему сборки. Этот список будет обновляться, чтобы оставаться актуальным. Если какая-либо из этих проблем в
настоящее время мешает вам попробовать новую систему сборки, пожалуйста, проверьте позже, так как она может быть решена.

### Проверка типов кода Web Worker и обработка вложенных Web Workers

Web Workers могут использоваться в коде приложения с использованием того же синтаксиса (
`new Worker(new URL('<workerfile>', import.meta.url))`), который поддерживается билдером `browser`.
Однако код внутри Worker в настоящее время не будет проверяться компилятором TypeScript на типы. Код TypeScript
поддерживается, просто не проверяется на типы.
Кроме того, любые вложенные воркеры не будут обрабатываться системой сборки. Вложенный воркер — это создание экземпляра
Worker внутри другого файла Worker.

### Импорты по умолчанию ESM против импортов пространства имен {#esm-default-imports-vs-namespace-imports}

TypeScript по умолчанию позволяет импортировать экспорты по умолчанию как импорты пространства имен (namespace imports),
а затем использовать их в выражениях вызова.
К сожалению, это расхождение со спецификацией ECMAScript.
Базовый сборщик (`esbuild`) в новой системе сборки ожидает код ESM, соответствующий спецификации.
Система сборки теперь будет генерировать предупреждение, если ваше приложение использует неправильный тип импорта
пакета.
Однако, чтобы TypeScript принял правильное использование, в файле `tsconfig` приложения должна быть включена опция
TypeScript.
При включении опция [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop) обеспечивает лучшее
соответствие спецификации ECMAScript и также рекомендуется командой TypeScript.
После включения вы можете обновить импорты пакетов, где это применимо, до формы, соответствующей ECMAScript.

Используя пакет [`moment`](https://npmjs.com/package/moment) в качестве примера, следующий код приложения вызовет ошибки
во время выполнения:

```ts
import * as moment from 'moment';

console.log(moment().format());
```

Сборка сгенерирует предупреждение, чтобы уведомить вас о потенциальной проблеме. Предупреждение будет похоже на:

```text
▲ [WARNING] Calling "moment" will crash at run-time because it's an import namespace object, not a function [call-import-namespace]

    src/main.ts:2:12:
      2 │ console.log(moment().format());
        ╵             ~~~~~~

Consider changing "moment" to a default import instead:

    src/main.ts:1:7:
      1 │ import * as moment from 'moment';
        │        ~~~~~~~~~~~
        ╵        moment

```

Однако вы можете избежать ошибок во время выполнения и предупреждения, включив опцию TypeScript `esModuleInterop` для
приложения и изменив импорт на следующий:

```ts
import moment from 'moment';

console.log(moment().format());
```

### Зависящие от порядка импорты с побочными эффектами в ленивых модулях

Операторы импорта, зависящие от определенного порядка и также используемые в нескольких ленивых модулях, могут привести
к выполнению операторов верхнего уровня не по порядку.
Это не часто встречается, так как зависит от использования модулей с побочными эффектами и не относится к опции
`polyfills`.
Это вызвано [дефектом](https://github.com/evanw/esbuild/issues/399) в базовом сборщике, но будет исправлено в будущем
обновлении.

ВАЖНО: Рекомендуется избегать использования модулей с нелокальными побочными эффектами (за исключением полифилов), когда
это возможно, независимо от используемой системы сборки, что позволяет избежать этой конкретной проблемы. Модули с
нелокальными побочными эффектами также могут негативно влиять как на размер приложения, так и на производительность во
время выполнения.

### Изменения расположения выходных файлов

По умолчанию после успешной сборки билдером `application` бандл располагается в каталоге `dist/<project-name>/browser` (
вместо `dist/<project-name>` для билдера `browser`).
Это может нарушить работу некоторых инструментов, которые полагаются на предыдущее расположение. В этом случае вы
можете [настроить путь вывода](reference/configs/workspace-config#output-path-configuration) в соответствии с вашими
потребностями.

## Сообщения об ошибках

Сообщайте о проблемах и запросах на новые функции на [GitHub](https://github.com/angular/angular-cli/issues).

Пожалуйста, предоставьте минимальное воспроизведение, где это возможно, чтобы помочь команде в решении проблем.
