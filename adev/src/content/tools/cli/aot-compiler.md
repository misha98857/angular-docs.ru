# Компиляция Ahead-of-time (AOT)

Приложение Angular состоит в основном из компонентов и их HTML-шаблонов.
Поскольку компоненты и шаблоны, предоставляемые Angular, не могут быть поняты браузером напрямую, приложения Angular
требуют процесса компиляции перед запуском в браузере.

Компилятор Angular Ahead-of-time (AOT) преобразует ваш HTML и TypeScript код Angular в эффективный JavaScript код на
этапе сборки (build phase), _до того_, как браузер загрузит и запустит этот код.
Компиляция приложения во время процесса сборки обеспечивает более быстрый рендеринг в браузере.

В этом руководстве объясняется, как указывать метаданные и применять доступные параметры компилятора для эффективной
компиляции приложений с использованием AOT-компилятора.

ПОЛЕЗНО: [Посмотрите, как Алекс Рикабо объясняет компилятор Angular](https://www.youtube.com/watch?v=anphffaCZrQ) на
конференции AngularConnect 2019.

Вот несколько причин, по которым вам может понадобиться использование AOT.

| Причины                                        | Подробности                                                                                                                                                                                                                                                                   |
| :--------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Более быстрый рендеринг                        | С AOT браузер загружает предварительно скомпилированную версию приложения. Браузер загружает исполняемый код, поэтому он может отрисовать приложение немедленно, не ожидая предварительной компиляции.                                                                        |
| Меньше асинхронных запросов                    | Компилятор _встраивает_ (inlines) внешние HTML-шаблоны и таблицы стилей CSS в JavaScript-код приложения, исключая отдельные ajax-запросы для этих исходных файлов.                                                                                                            |
| Меньший размер загружаемого фреймворка Angular | Нет необходимости загружать компилятор Angular, если приложение уже скомпилировано. Компилятор составляет примерно половину объема самого Angular, поэтому его исключение значительно уменьшает размер полезной нагрузки приложения.                                          |
| Раннее обнаружение ошибок в шаблонах           | Компилятор AOT обнаруживает и сообщает об ошибках привязки в шаблонах на этапе сборки, до того как их увидят пользователи.                                                                                                                                                    |
| Повышенная безопасность                        | AOT компилирует HTML-шаблоны и компоненты в файлы JavaScript задолго до того, как они будут переданы клиенту. Без шаблонов для чтения и без рискованной оценки HTML или JavaScript на стороне клиента остается меньше возможностей для инъекционных атак (injection attacks). |

## Выбор компилятора

Angular предлагает два способа компиляции вашего приложения:

| Компиляция Angular    | Подробности                                                                                               |
| :-------------------- | :-------------------------------------------------------------------------------------------------------- |
| Just-in-Time \(JIT\)  | Компилирует ваше приложение в браузере во время выполнения. Это было значением по умолчанию до Angular 8. |
| Ahead-of-Time \(AOT\) | Компилирует ваше приложение и библиотеки во время сборки. Это значение по умолчанию, начиная с Angular 9. |

Когда вы запускаете CLI-команды [`ng build`](cli/build) \(только сборка\) или [`ng serve`](cli/serve) \(сборка и
локальный запуск\), тип компиляции \(JIT или AOT\) зависит от значения свойства `aot` в конфигурации сборки, указанной в
`angular.json`.
По умолчанию для новых CLI-приложений `aot` установлено в `true`.

Смотрите [справочник команд CLI](cli) и [Сборка и запуск приложений Angular](tools/cli/build) для получения
дополнительной информации.

## Как работает AOT

Компилятор Angular AOT извлекает **метаданные** для интерпретации частей приложения, которыми должен управлять Angular.
Вы можете указать метаданные явно в **декораторах**, таких как `@Component()`, или неявно в объявлениях конструкторов
декорируемых классов.
Метаданные сообщают Angular, как создавать экземпляры классов вашего приложения и взаимодействовать с ними во время
выполнения.

В следующем примере объект метаданных `@Component()` и конструктор класса сообщают Angular, как создать и отобразить
экземпляр `TypicalComponent`.

```angular-ts

@Component({
  selector: 'app-typical',
  template: '<div>A typical component for {{data.name}}</div>'
})
export class TypicalComponent {
  data = input.required<TypicalData>();
  private someService = inject(SomeService);
}

```

Компилятор Angular извлекает метаданные _один раз_ и генерирует _фабрику_ для `TypicalComponent`.
Когда необходимо создать экземпляр `TypicalComponent`, Angular вызывает фабрику, которая создает новый визуальный
элемент, привязанный к новому экземпляру класса компонента с его внедренной зависимостью.

### Фазы компиляции

Существует три фазы AOT-компиляции.

|     | Фаза                      | Подробности                                                                                                                                                                                                                                                                                            |
| :-- | :------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   | анализ кода               | На этой фазе компилятор TypeScript и _AOT-коллектор_ создают представление исходного кода. Коллектор не пытается интерпретировать собранные метаданные. Он представляет метаданные наилучшим образом и записывает ошибки при обнаружении нарушения синтаксиса метаданных.                              |
| 2   | генерация кода            | На этой фазе `StaticReflector` компилятора интерпретирует метаданные, собранные на фазе 1, выполняет дополнительную валидацию метаданных и выбрасывает ошибку, если обнаруживает нарушение ограничений метаданных.                                                                                     |
| 3   | проверка типов в шаблонах | На этой необязательной фазе _компилятор шаблонов_ Angular использует компилятор TypeScript для валидации выражений привязки в шаблонах. Вы можете включить эту фазу явно, установив опцию конфигурации `strictTemplates`; см. [Опции компилятора Angular](reference/configs/angular-compiler-options). |

### Ограничения метаданных

Вы пишете метаданные на _подмножестве_ TypeScript, которое должно соответствовать следующим общим ограничениям:

- Ограничить [синтаксис выражений](#expression-syntax-limitations) поддерживаемым подмножеством JavaScript.
- Ссылаться только на экспортируемые символы после [свертывания кода](#code-folding).
- Вызывать только [функции, поддерживаемые](#supported-classes-and-functions) компилятором.
- Input/Output и привязанные к данным члены класса должны быть public или protected. Дополнительные рекомендации и
  инструкции по подготовке приложения к AOT-компиляции см. в
  статье [Angular: Написание AOT-friendly приложений](https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f).

ПОЛЕЗНО: Ошибки при AOT-компиляции часто возникают из-за метаданных, которые не соответствуют требованиям компилятора
\(как описано более подробно ниже\).
Для помощи в понимании и решении этих проблем см. [Ошибки метаданных AOT](tools/cli/aot-metadata-errors).

### Настройка AOT-компиляции

Вы можете указать параметры
в [файле конфигурации TypeScript](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html), который управляет
процессом компиляции.
См. [Опции компилятора Angular](reference/configs/angular-compiler-options) для полного списка доступных опций.

## Фаза 1: Анализ кода

Компилятор TypeScript выполняет часть аналитической работы первой фазы.
Он генерирует _файлы определений типов_ `.d.ts` с информацией о типах, необходимой AOT-компилятору для генерации кода
приложения.
В то же время AOT **коллектор** анализирует метаданные, записанные в декораторах Angular, и выводит информацию о
метаданных в файлы **`.metadata.json`**, по одному на каждый файл `.d.ts`.

Вы можете рассматривать `.metadata.json` как диаграмму общей структуры метаданных декоратора, представленную в
виде [абстрактного синтаксического дерева (AST)](https://ru.wikipedia.org/wiki/Абстрактное_синтаксическое_дерево).

ПОЛЕЗНО: Файл [schema.ts](https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts)
Angular описывает формат JSON как коллекцию интерфейсов TypeScript.

### Ограничения синтаксиса выражений

AOT-коллектор понимает только подмножество JavaScript.
Определяйте объекты метаданных с использованием следующего ограниченного синтаксиса:

| Синтаксис                          | Пример                                                     |
| :--------------------------------- | :--------------------------------------------------------- |
| Литерал объекта                    | `{cherry: true, apple: true, mincemeat: false}`            |
| Литерал массива                    | `['cherries', 'flour', 'sugar']`                           |
| Spread в литерале массива          | `['apples', 'flour', …]`                                   |
| Вызовы                             | `bake(ingredients)`                                        |
| New                                | `new Oven()`                                               |
| Доступ к свойству                  | `pie.slice`                                                |
| Индекс массива                     | `ingredients[0]`                                           |
| Ссылка на идентификатор            | `Component`                                                |
| Шаблонная строка                   | <code>`pie is ${multiplier} times better than cake`</code> |
| Строковый литерал                  | `'pi'`                                                     |
| Числовой литерал                   | `3.14153265`                                               |
| Булевый литерал                    | `true`                                                     |
| Литерал null                       | `null`                                                     |
| Поддерживаемый префиксный оператор | `!cake`                                                    |
| Поддерживаемый бинарный оператор   | `a+b`                                                      |
| Условный оператор                  | `a ? b : c`                                                |
| Скобки                             | `(a+b)`                                                    |

Если выражение использует неподдерживаемый синтаксис, коллектор записывает узел ошибки в файл `.metadata.json`.
Позже компилятор сообщит об ошибке, если ему понадобится эта часть метаданных для генерации кода приложения.

ПОЛЕЗНО: Если вы хотите, чтобы `ngc` сообщал о синтаксических ошибках немедленно, а не создавал файл `.metadata.json` с
ошибками, установите опцию `strictMetadataEmit` в файле конфигурации TypeScript.

```json

"angularCompilerOptions": {
  …
  "strictMetadataEmit" : true
}

```

Библиотеки Angular имеют эту опцию, чтобы гарантировать чистоту всех файлов `.metadata.json` Angular, и хорошей
практикой является делать то же самое при сборке собственных библиотек.

### Отсутствие стрелочных функций

AOT-компилятор не
поддерживает [функциональные выражения](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function)
и [стрелочные функции](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions), также
называемые _лямбда-функциями_.

Рассмотрим следующий декоратор компонента:

```ts

@Component({
  …
  providers: [{provide: server, useFactory: () => new Server()}]
})

```

AOT-коллектор не поддерживает стрелочную функцию `() => new Server()` в выражении метаданных.
Он генерирует узел ошибки вместо функции.
Когда компилятор позже интерпретирует этот узел, он сообщает об ошибке, предлагая вам превратить стрелочную функцию в
_экспортируемую функцию_.

Вы можете исправить ошибку, преобразовав код следующим образом:

```ts

export function serverFactory() {
  return new Server();
}

@Component({
  …
  providers: [{provide: server, useFactory: serverFactory}]
})

```

В версии 5 и более поздних компилятор автоматически выполняет это переписывание при генерации файла `.js`.

### Свертывание кода (Code folding)

Компилятор может разрешать ссылки только на **_экспортируемые_** символы.
Однако коллектор может вычислить выражение во время сбора и записать результат в `.metadata.json` вместо исходного
выражения.
Это позволяет вам ограниченно использовать неэкспортируемые символы внутри выражений.

Например, коллектор может вычислить выражение `1 + 2 + 3 + 4` и заменить его результатом `10`.
Этот процесс называется _свертыванием_ (folding).
Выражение, которое может быть сокращено таким образом, называется _свертываемым_ (foldable).

Коллектор может вычислять ссылки на локальные для модуля объявления `const` и инициализированные объявления `var` и
`let`, фактически удаляя их из файла `.metadata.json`.

Рассмотрим следующее определение компонента:

```angular-ts

const template = '<div>{{hero().name}}</div>';

@Component({
  selector: 'app-hero',
  template: template
})
export class HeroComponent {
  hero = input.required<Hero>();
}

```

Компилятор не мог бы сослаться на константу `template`, так как она не экспортируется.
Однако коллектор может свернуть константу `template` в определение метаданных, встроив ее содержимое.
Эффект такой же, как если бы вы написали:

```angular-ts

@Component({
  selector: 'app-hero',
  template: '<div>{{hero().name}}</div>'
})
export class HeroComponent {
  hero = input.required<Hero>();
}

```

Больше нет ссылки на `template`, и, следовательно, ничто не побеспокоит компилятор, когда он позже будет
интерпретировать вывод _коллектора_ в `.metadata.json`.

Вы можете пойти дальше, включив константу `template` в другое выражение:

```angular-ts

const template = '<div>{{hero().name}}</div>';

@Component({
  selector: 'app-hero',
  template: template + '<div>{{hero().title}}</div>'
})
export class HeroComponent {
  hero = input.required<Hero>();
}

```

Коллектор сокращает это выражение до его эквивалентной _свернутой_ строки:

```angular-ts

'<div>{{hero().name}}</div><div>{{hero().title}}</div>'

```

#### Свертываемый синтаксис

В следующей таблице описано, какие выражения коллектор может свернуть, а какие нет:

| Синтаксис                          | Свертываемый                                |
| :--------------------------------- | :------------------------------------------ |
| Литерал объекта                    | да                                          |
| Литерал массива                    | да                                          |
| Spread в литерале массива          | нет                                         |
| Вызовы                             | нет                                         |
| New                                | нет                                         |
| Доступ к свойству                  | да, если цель свертываемая                  |
| Индекс массива                     | да, если цель и индекс свертываемые         |
| Ссылка на идентификатор            | да, если это ссылка на локальную переменную |
| Шаблон без подстановок             | да                                          |
| Шаблон с подстановками             | да, если подстановки свертываемые           |
| Строковый литерал                  | да                                          |
| Числовой литерал                   | да                                          |
| Булевый литерал                    | да                                          |
| Литерал null                       | да                                          |
| Поддерживаемый префиксный оператор | да, если операнд свертываемый               |
| Поддерживаемый бинарный оператор   | да, если левая и правая части свертываемые  |
| Условный оператор                  | да, если условие свертываемое               |
| Скобки                             | да, если выражение свертываемое             |

Если выражение не является свертываемым, коллектор записывает его в `.metadata.json`
как [AST](https://ru.wikipedia.org/wiki/Абстрактное_синтаксическое_дерево) для разрешения компилятором.

## Фаза 2: Генерация кода

Коллектор не пытается понять метаданные, которые он собирает и выводит в `.metadata.json`.
Он представляет метаданные наилучшим образом и записывает ошибки при обнаружении нарушения синтаксиса метаданных.
Задача компилятора — интерпретировать `.metadata.json` на этапе генерации кода.

Компилятор понимает все формы синтаксиса, поддерживаемые коллектором, но может отклонить _синтаксически_ правильные
метаданные, если _семантика_ нарушает правила компилятора.

### Public или protected символы

Компилятор может ссылаться только на _экспортируемые символы_.

- Члены класса декорированного компонента должны быть public или protected.
  Вы не можете сделать свойство `input()` приватным.

- Свойства, привязанные к данным, также должны быть public или protected.

### Поддерживаемые классы и функции

Коллектор может представить вызов функции или создание объекта с помощью `new`, пока синтаксис валиден.
Однако компилятор может позже отказаться генерировать вызов _конкретной_ функции или создание _конкретного_ объекта.

Компилятор может создавать экземпляры только определенных классов, поддерживает только основные декораторы и
поддерживает вызовы только макросов \(функций или статических методов\), которые возвращают выражения.

| Действие компилятора      | Подробности                                                                                                                                                           |
| :------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Новые экземпляры          | Компилятор разрешает только метаданные, создающие экземпляры класса `InjectionToken` из `@angular/core`.                                                              |
| Поддерживаемые декораторы | Компилятор поддерживает метаданные только для [декораторов Angular в модуле `@angular/core`](api/core#decorators).                                                    |
| Вызовы функций            | Фабричные функции должны быть экспортируемыми именованными функциями. AOT-компилятор не поддерживает лямбда-выражения \("стрелочные функции"\) для фабричных функций. |

### Функции и вызовы статических методов

Коллектор принимает любую функцию или статический метод, содержащий единственный оператор `return`.
Однако компилятор поддерживает только макросы в форме функций или статических методов, возвращающих _выражение_.

Например, рассмотрим следующую функцию:

```ts

export function wrapInArray<T>(value: T): T[] {
  return [value];
}

```

Вы можете вызвать `wrapInArray` в определении метаданных, потому что она возвращает значение выражения, соответствующего
ограничительному подмножеству JavaScript компилятора.

Вы можете использовать `wrapInArray()` следующим образом:

```ts

@NgModule({
  declarations: wrapInArray(TypicalComponent)
})
export class TypicalModule {}

```

Компилятор обрабатывает это использование так, как если бы вы написали:

```ts

@NgModule({
  declarations: [TypicalComponent]
})
export class TypicalModule {}

```

[`RouterModule`](api/router/RouterModule) Angular экспортирует два статических метода-макроса, `forRoot` и `forChild`,
чтобы помочь объявить корневые и дочерние маршруты.
Изучите [исходный код](https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139 'Исходный код RouterModule.forRoot')
этих методов, чтобы увидеть, как макросы могут упростить конфигурацию сложных [NgModules](guide/ngmodules).

### Переписывание метаданных

Компилятор обрабатывает объектные литералы, содержащие поля `useClass`, `useValue`, `useFactory` и `data`, особым
образом, преобразуя выражение, инициализирующее одно из этих полей, в экспортируемую переменную, которая заменяет
выражение.
Этот процесс переписывания выражений снимает все ограничения на то, что может быть в них, потому что
компилятору не нужно знать значение выражения — ему просто нужно иметь возможность сгенерировать ссылку на значение.

Вы можете написать что-то вроде:

```ts

class TypicalServer {

}

@NgModule({
  providers: [{provide: SERVER, useFactory: () => TypicalServer}]
})
export class TypicalModule {}

```

Без переписывания это было бы недействительно, так как лямбды не поддерживаются, а `TypicalServer` не экспортируется.
Чтобы разрешить это, компилятор автоматически переписывает это во что-то вроде:

```ts

class TypicalServer {

}

export const θ0 = () => new TypicalServer();

@NgModule({
  providers: [{provide: SERVER, useFactory: θ0}]
})
export class TypicalModule {}

```

Это позволяет компилятору сгенерировать ссылку на `θ0` в фабрике, не зная, что содержит значение `θ0`.

Компилятор выполняет переписывание во время генерации файла `.js`.
Однако он не переписывает файл `.d.ts`, поэтому TypeScript не распознает это как экспорт.
И это не мешает экспортируемому API ES-модуля.

## Фаза 3: Проверка типов в шаблонах

Одной из самых полезных функций компилятора Angular является возможность проверки типов выражений внутри шаблонов и
перехвата любых ошибок до того, как они вызовут сбои во время выполнения.
На этапе проверки типов в шаблонах компилятор шаблонов Angular использует компилятор TypeScript для валидации выражений
привязки в шаблонах.

Включите эту фазу явно, добавив опцию компилятора `"fullTemplateTypeCheck"` в `"angularCompilerOptions"` файла
конфигурации TypeScript проекта
(см. [Опции компилятора Angular](reference/configs/angular-compiler-options)).

Валидация шаблона выдает сообщения об ошибках при обнаружении ошибки типа в выражении привязки шаблона, подобно тому,
как ошибки типов сообщаются компилятором TypeScript для кода в файле `.ts`.

Например, рассмотрим следующий компонент:

```angular-ts

@Component({
  selector: 'my-component',
  template: '{{person.addresss.street}}'
})
class MyComponent {
  person?: Person;
}

```

Это вызывает следующую ошибку:

<docs-code hideCopy language="shell">

my.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?

</docs-code>

Имя файла, указанное в сообщении об ошибке, `my.component.ts.MyComponent.html`, является синтетическим файлом,
сгенерированным компилятором шаблонов, который содержит содержимое шаблона класса `MyComponent`.
Компилятор никогда не записывает этот файл на диск.
Номера строк и столбцов относятся к строке шаблона в аннотации `@Component` класса, в данном случае `MyComponent`.
Если компонент использует `templateUrl` вместо `template`, ошибки сообщаются в HTML-файле, на который ссылается
`templateUrl`, вместо синтетического файла.

Местоположение ошибки — это начало текстового узла, содержащего выражение интерполяции с ошибкой.
Если ошибка находится в привязке атрибута, например `[value]="person.address.street"`, местоположением ошибки
является местоположение атрибута, содержащего ошибку.

Валидация использует проверку типов TypeScript и опции, переданные компилятору TypeScript, для управления детализацией
проверки типов.
Например, если указано `strictTypeChecks`, ошибка

<docs-code hideCopy language="shell">

my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'

</docs-code>

сообщается наряду с вышеуказанным сообщением об ошибке.

### Сужение типов (Type narrowing)

Выражение, используемое в директиве `ngIf`, используется для сужения объединений типов в компиляторе шаблонов Angular
так же, как выражение `if` делает это в TypeScript.
Например, чтобы избежать ошибки `Object is possibly 'undefined'` в шаблоне выше, измените его так, чтобы интерполяция
выполнялась только если значение `person` инициализировано, как показано ниже:

```angular-ts

@Component({
  selector: 'my-component',
  template: '<span *ngIf="person"> {{person.address.street}} </span>'
})
class MyComponent {
  person?: Person;
}

```

Использование `*ngIf` позволяет компилятору TypeScript сделать вывод, что `person`, используемый в выражении привязки,
никогда не будет `undefined`.

Для получения дополнительной информации о сужении типов входных данных
см. [Улучшение проверки типов в шаблонах для пользовательских директив](guide/directives/structural-directives#directive-type-checks).

### Оператор утверждения ненулевого типа (Non-null type assertion operator)

Используйте оператор утверждения ненулевого типа, чтобы подавить ошибку `Object is possibly 'undefined'`, когда неудобно
использовать `*ngIf` или когда какое-то ограничение в компоненте гарантирует, что выражение всегда не равно null при
интерполяции выражения привязки.

В следующем примере свойства `person` и `address` всегда устанавливаются вместе, подразумевая, что `address` всегда не
null, если `person` не null.
Нет удобного способа описать это ограничение для TypeScript и компилятора шаблонов, но ошибка подавляется в примере с
помощью `address!.street`.

```ts

@Component({
  selector: 'my-component',
  template: '<span *ngIf="person"> {{person.name}} lives on {{address!.street}} </span>'
})
class MyComponent {
  person?: Person;
  address?: Address;

  setData(person: Person, address: Address) {
    this.person = person;
    this.address = address;
  }
}

```

Оператор утверждения ненулевого типа следует использовать с осторожностью, так как рефакторинг компонента может нарушить
это ограничение.

В этом примере рекомендуется включить проверку `address` в `*ngIf`, как показано ниже:

```ts

@Component({
  selector: 'my-component',
  template: '<span *ngIf="person && address"> {{person.name}} lives on {{address.street}} </span>'
})
class MyComponent {
  person?: Person;
  address?: Address;

  setData(person: Person, address: Address) {
    this.person = person;
    this.address = address;
  }
}

```
