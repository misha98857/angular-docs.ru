# Билдеры Angular CLI

Ряд команд Angular CLI запускает сложный процесс в вашем коде, такой как сборка, тестирование или запуск приложения.
Команды используют внутренний инструмент под названием Architect для запуска _CLI builders_ (билдеров CLI), которые
вызывают другой инструмент (сборщик, раннер тестов, сервер) для выполнения желаемой задачи.
Пользовательские билдеры могут выполнять совершенно новую задачу или изменять то, какой сторонний инструмент
используется существующей командой.

Этот документ объясняет, как билдеры CLI интегрируются с файлом конфигурации рабочей области, и показывает, как вы
можете создать свой собственный билдер.

ПОЛЕЗНО: Код примеров, используемых здесь, можно найти в
этом [GitHub репозитории](https://github.com/mgechev/cli-builders-demo).

## Билдеры CLI

Внутренний инструмент Architect делегирует работу функциям-обработчикам, называемым _билдерами_.
Функция-обработчик билдера получает два аргумента:

| Аргумент  | Тип              |
| :-------- | :--------------- |
| `options` | `JSONObject`     |
| `context` | `BuilderContext` |

Разделение ответственности здесь такое же, как и в [схематиках](tools/cli/schematics-authoring), которые используются
для других команд CLI, затрагивающих ваш код (например, `ng generate`).

- Объект `options` предоставляется опциями и конфигурацией пользователя CLI, в то время как объект `context`
  предоставляется API билдера CLI автоматически.
- Помимо контекстной информации, объект `context` также предоставляет доступ к методу планирования
  `context.scheduleTarget()`.
  Планировщик выполняет функцию-обработчик билдера с заданной целевой конфигурацией.

Функция-обработчик билдера может быть синхронной (возвращать значение), асинхронной (возвращать `Promise`) или наблюдать
и возвращать несколько значений (возвращать `Observable`).
Возвращаемые значения всегда должны быть типа `BuilderOutput`.
Этот объект содержит булево поле `success` и необязательное поле `error`, которое может содержать сообщение об ошибке.

Angular предоставляет несколько билдеров, которые используются CLI для таких команд, как `ng build` и `ng test`.
Целевые конфигурации по умолчанию для этих и других встроенных билдеров CLI можно найти и настроить в секции "
architect" [файла конфигурации рабочей области](reference/configs/workspace-config), `angular.json`.
Также можно расширять и настраивать Angular, создавая собственные билдеры, которые можно запускать напрямую с
помощью [команды CLI `ng run`](cli/run).

### Структура проекта билдера

Билдер находится в папке "проекта", которая по структуре похожа на рабочую область Angular, с глобальными файлами
конфигурации на верхнем уровне и более специфичной конфигурацией в исходной папке с файлами кода, определяющими
поведение.
Например, ваша папка `myBuilder` может содержать следующие файлы.

| Файлы                    | Назначение                                                                                               |
| :----------------------- | :------------------------------------------------------------------------------------------------------- |
| `src/my-builder.ts`      | Основной исходный файл определения билдера.                                                              |
| `src/my-builder.spec.ts` | Исходный файл для тестов.                                                                                |
| `src/schema.json`        | Определение входных опций билдера.                                                                       |
| `builders.json`          | Определение билдеров.                                                                                    |
| `package.json`           | Зависимости. См. [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json). |
| `tsconfig.json`          | [Конфигурация TypeScript](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html).              |

Билдеры могут быть опубликованы в `npm`, см. [Публикация вашей библиотеки](tools/libraries/creating-libraries).

## Создание билдера

В качестве примера создадим билдер, который копирует файл в новое место.
Чтобы создать билдер, используйте функцию `createBuilder()` из CLI Builder API и верните объект
`Promise<BuilderOutput>`.

<docs-code header="src/my-builder.ts (каркас билдера)" path="adev/src/content/examples/cli-builder/src/my-builder.ts" visibleRegion="builder-skeleton"/>

Теперь добавим в него логику.
Следующий код получает пути к исходному и целевому файлам из опций пользователя и копирует файл из источника в место
назначения (используя [Promise-версию встроенной функции NodeJS
`copyFile()`](https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode)).
Если операция копирования не удалась, возвращается ошибка с сообщением о возникшей проблеме.

<docs-code header="src/my-builder.ts (билдер)" path="adev/src/content/examples/cli-builder/src/my-builder.ts" visibleRegion="builder"/>

### Обработка вывода

По умолчанию `copyFile()` ничего не выводит в стандартный вывод или поток ошибок процесса.
Если возникает ошибка, может быть трудно понять, что именно пытался сделать билдер в момент возникновения проблемы.
Добавьте дополнительный контекст, логируя дополнительную информацию с помощью API `Logger`.
Это также позволяет выполнять сам билдер в отдельном процессе, даже если стандартный вывод и вывод ошибок
деактивированы.

Вы можете получить экземпляр `Logger` из контекста.

<docs-code header="src/my-builder.ts (обработка вывода)" path="adev/src/content/examples/cli-builder/src/my-builder.ts" visibleRegion="handling-output"/>

### Отчет о прогрессе и статусе

API билдеров CLI включает инструменты для отчета о прогрессе и статусе, которые могут предоставлять подсказки для
определенных функций и интерфейсов.

Чтобы сообщить о прогрессе, используйте метод `context.reportProgress()`, который принимает текущее значение,
необязательное общее значение и строку статуса в качестве аргументов.
Общее значение может быть любым числом. Например, если вы знаете, сколько файлов вам нужно обработать, общим значением
может быть количество файлов, а текущим — количество обработанных на данный момент.
Строка статуса остается неизменной, если вы не передадите новое строковое значение.

В нашем примере операция копирования либо завершается, либо все еще выполняется, поэтому нет необходимости в отчете о
прогрессе, но вы можете сообщить статус, чтобы родительский билдер, вызвавший наш билдер, знал, что происходит.
Используйте метод `context.reportStatus()` для генерации строки статуса любой длины.

ПОЛЕЗНО: Нет гарантии, что длинная строка будет показана полностью; она может быть обрезана, чтобы соответствовать
интерфейсу, который ее отображает.

Передайте пустую строку, чтобы удалить статус.

<docs-code header="src/my-builder.ts (отчет о прогрессе)" path="adev/src/content/examples/cli-builder/src/my-builder.ts" visibleRegion="progress-reporting"/>

## Входные данные билдера

Вы можете вызвать билдер косвенно через команду CLI, такую как `ng build`, или напрямую с помощью команды Angular CLI
`ng run`.
В любом случае вы должны предоставить обязательные входные данные, но можете оставить для других входных данных значения
по умолчанию, которые предварительно настроены для конкретной _цели_ (target), указанной
в [конфигурации](tools/cli/environments), или установлены в командной строке.

### Валидация входных данных

Вы определяете входные данные билдера в JSON-схеме, связанной с этим билдером.
Подобно схематикам, инструмент Architect собирает разрешенные входные значения в объект `options` и проверяет их типы на
соответствие схеме перед передачей их функции билдера.

Для нашего примера билдера `options` должен быть `JsonObject` с двумя ключами:
`source` и `destination`, каждый из которых является строкой.

Вы можете предоставить следующую схему для валидации типов этих значений.

```json {header: "schema.json"}

{
  "$schema": "http://json-schema.org/schema",
  "type": "object",
  "properties": {
    "source": {
      "type": "string"
    },
    "destination": {
      "type": "string"
    }
  }
}
```

ПОЛЕЗНО: Это минимальный пример, но использование схемы для валидации может быть очень мощным инструментом.
Для получения дополнительной информации см. [веб-сайт JSON schemas](http://json-schema.org).

Чтобы связать реализацию нашего билдера с его схемой и именем, вам нужно создать файл _определения билдера_, на который
можно указать в `package.json`.

Создайте файл с именем `builders.json`, который выглядит следующим образом:

```json {header: "builders.json"}

{
  "builders": {
    "copy": {
      "implementation": "./dist/my-builder.js",
      "schema": "./src/schema.json",
      "description": "Copies a file."
    }
  }
}
```

В файле `package.json` добавьте ключ `builders`, который сообщает инструменту Architect, где найти наш файл определения
билдера.

```json {header: "package.json"}
{
  "name": "@example/copy-file",
  "version": "1.0.0",
  "description": "Builder for copying files",
  "builders": "builders.json",
  "dependencies": {
    "@angular-devkit/architect": "~0.1200.0",
    "@angular-devkit/core": "^12.0.0"
  }
}
```

Официальное имя нашего билдера теперь `@example/copy-file:copy`.
Первая часть — это имя пакета, а вторая часть — имя билдера, указанное в файле `builders.json`.

Доступ к этим значениям осуществляется через `options.source` и `options.destination`.

<docs-code header="src/my-builder.ts (отчет о статусе)" path="adev/src/content/examples/cli-builder/src/my-builder.ts" visibleRegion="report-status"/>

### Конфигурация цели (Target configuration)

Билдер должен иметь определенную цель (target), которая связывает его с конкретной конфигурацией входных данных и
проектом.

Цели определяются в [файле конфигурации CLI](reference/configs/workspace-config) `angular.json`.
Цель указывает используемый билдер, конфигурацию его опций по умолчанию и именованные альтернативные конфигурации.
Architect в Angular CLI использует определение цели для разрешения входных опций для данного запуска.

Файл `angular.json` имеет секцию для каждого проекта, и секция "architect" каждого проекта настраивает цели для
билдеров, используемых командами CLI, такими как 'build', 'test' и 'serve'.
Например, по умолчанию команда `ng build` запускает билдер `@angular-devkit/build-angular:browser` для выполнения задачи
сборки и передает значения опций по умолчанию, указанные для цели `build` в `angular.json`.

```json {header: "angular.json"}
{
  "myApp": {
    "...": "...",
    "architect": {
      "build": {
        "builder": "@angular-devkit/build-angular:browser",
        "options": {
          "outputPath": "dist/myApp",
          "index": "src/index.html",
          "...": "..."
        },
        "configurations": {
          "production": {
            "fileReplacements": [
              {
                "replace": "src/environments/environment.ts",
                "with": "src/environments/environment.prod.ts"
              }
            ],
            "optimization": true,
            "outputHashing": "all",
            "...": "..."
          }
        }
      },
      "...": "..."
    }
  }
}
```

Команда передает билдеру набор опций по умолчанию, указанных в секции "options".
Если вы передадите флаг `--configuration=production`, она использует значения переопределения, указанные в конфигурации
`production`.
Дополнительные переопределения опций можно указать индивидуально в командной строке.

#### Строки целей (Target strings)

Универсальная команда CLI `ng run` принимает в качестве первого аргумента строку цели следующего вида.

```shell

project:target[:configuration]

```

|               | Детали                                                                                                               |
| :------------ | :------------------------------------------------------------------------------------------------------------------- |
| project       | Имя проекта Angular CLI, с которым связана цель.                                                                     |
| target        | Именованная конфигурация билдера из секции `architect` файла `angular.json`.                                         |
| configuration | (необязательно) Имя конкретного переопределения конфигурации для данной цели, как определено в файле `angular.json`. |

Если ваш билдер вызывает другой билдер, ему может потребоваться прочитать переданную строку цели.
Распарсите эту строку в объект, используя утилитарную функцию `targetFromTargetString()` из `@angular-devkit/architect`.

## Планирование и запуск

Architect запускает билдеры асинхронно.
Чтобы вызвать билдер, вы планируете задачу, которая будет запущена после завершения разрешения конфигурации.

Функция билдера не выполняется до тех пор, пока планировщик не вернет управляющий объект `BuilderRun`.
CLI обычно планирует задачи, вызывая функцию `context.scheduleTarget()`, а затем разрешает входные опции, используя
определение цели в файле `angular.json`.

Architect разрешает входные опции для заданной цели, беря объект опций по умолчанию, затем перезаписывая значения из
конфигурации, а затем дополнительно перезаписывая значения из объекта переопределений, переданного в
`context.scheduleTarget()`.
Для Angular CLI объект переопределений формируется из аргументов командной строки.

Architect проверяет полученные значения опций на соответствие схеме билдера.
Если входные данные валидны, Architect создает контекст и выполняет билдер.

Для получения дополнительной информации см. [Конфигурация рабочей области](reference/configs/workspace-config).

ПОЛЕЗНО: Вы также можете вызвать билдер напрямую из другого билдера или теста, вызвав `context.scheduleBuilder()`.
Вы передаете объект `options` непосредственно в метод, и эти значения опций проверяются на соответствие схеме билдера
без дальнейшей корректировки.

Только метод `context.scheduleTarget()` разрешает конфигурацию и переопределения через файл `angular.json`.

### Конфигурация Architect по умолчанию

Давайте создадим простой файл `angular.json`, который поместит целевые конфигурации в контекст.

Вы можете опубликовать билдер в npm (
см. [Публикация вашей библиотеки](tools/libraries/creating-libraries#publishing-your-library)) и установить его с
помощью следующей команды:

```shell

npm install @example/copy-file

```

Если вы создадите новый проект с помощью `ng new builder-test`, сгенерированный файл `angular.json` будет выглядеть
примерно так, только с конфигурациями билдеров по умолчанию.

```json {header: "angular.json"}
{
  "projects": {
    "builder-test": {
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:browser",
          "options": {
            "outputPath": "dist/builder-test",
            "index": "src/index.html",
            "main": "src/main.ts",
            "polyfills": "src/polyfills.ts",
            "tsConfig": "src/tsconfig.app.json"
          },
          "configurations": {
            "production": {
              "optimization": true,
              "aot": true,
              "buildOptimizer": true
            }
          }
        }
      }
    }
  }
}
```

### Добавление цели

Добавьте новую цель, которая запустит наш билдер для копирования файла.
Эта цель сообщает билдеру скопировать файл `package.json`.

- Мы добавим новую секцию цели в объект `architect` для нашего проекта.
- Цель с именем `copy-package` использует наш билдер, который вы опубликовали в `@example/copy-file`.
- Объект опций предоставляет значения по умолчанию для двух входных данных, которые вы определили.
  - `source` — Существующий файл, который вы копируете.
  - `destination` — Путь, по которому вы хотите скопировать.

<docs-code header="angular.json" language="json">

{
"projects": {
"builder-test": {
"architect": {
"copy-package": {
"builder": "@example/copy-file:copy",
"options": {
"source": "package.json",
"destination": "package-copy.json"
}
},

        // Existing targets...
      }
    }

}
}
</docs-code>

### Запуск билдера

Чтобы запустить наш билдер с конфигурацией по умолчанию новой цели, используйте следующую команду CLI.

```shell

ng run builder-test:copy-package

```

Это скопирует файл `package.json` в `package-copy.json`.

Используйте аргументы командной строки для переопределения настроенных значений по умолчанию.
Например, чтобы запустить с другим значением `destination`, используйте следующую команду CLI.

```shell

ng run builder-test:copy-package --destination=package-other.json

```

Это скопирует файл в `package-other.json` вместо `package-copy.json`.
Поскольку вы не переопределили опцию _source_, он все равно будет копировать из файла `package.json` по умолчанию.

## Тестирование билдера

Используйте интеграционное тестирование для вашего билдера, чтобы вы могли использовать планировщик Architect для
создания контекста, как в этом [примере](https://github.com/mgechev/cli-builders-demo).
В исходной директории билдера создайте новый файл теста `my-builder.spec.ts`. Тест создает новые экземпляры
`JsonSchemaRegistry` (для валидации схемы), `TestingArchitectHost` (реализация `ArchitectHost` в памяти) и `Architect`.

Вот пример теста, который запускает билдер копирования файла.
Тест использует билдер для копирования файла `package.json` и проверяет, что содержимое скопированного файла совпадает с
источником.

<docs-code header="src/my-builder.spec.ts" path="adev/src/content/examples/cli-builder/src/my-builder.spec.ts"/>

ПОЛЕЗНО: При запуске этого теста в вашем репозитории вам понадобится пакет [
`ts-node`](https://github.com/TypeStrong/ts-node).
Вы можете избежать этого, переименовав `my-builder.spec.ts` в `my-builder.spec.js`.

### Режим наблюдения (Watch mode)

Большинство билдеров запускаются один раз и возвращают результат. Однако это поведение не полностью совместимо с
билдером, который отслеживает изменения (например, devserver).
Architect может поддерживать режим наблюдения, но есть некоторые моменты, на которые следует обратить внимание.

- Для использования в режиме наблюдения функция-обработчик билдера должна возвращать `Observable`.
  Architect подписывается на `Observable` до тех пор, пока он не завершится, и может использовать его повторно, если
  билдер будет запланирован снова с теми же аргументами.

- Билдер всегда должен выдавать объект `BuilderOutput` после каждого выполнения.
  После выполнения он может перейти в режим наблюдения, который будет инициирован внешним событием.
  Если событие инициирует его перезапуск, билдер должен выполнить функцию `context.reportRunning()`, чтобы сообщить
  Architect, что он снова работает.
  Это предотвращает остановку билдера инструментом Architect, если запланирован другой запуск.

Когда ваш билдер вызывает `BuilderRun.stop()` для выхода из режима наблюдения, Architect отписывается от `Observable`
билдера и вызывает логику очистки (teardown) билдера.
Это поведение также позволяет останавливать и очищать длительные сборки.

В общем случае, если ваш билдер наблюдает за внешним событием, вам следует разделить выполнение на три фазы.

| Фазы       | Детали                                                                                                                                                                                                                                                                      |
| :--------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Выполнение | Выполняемая задача, например, вызов компилятора. Заканчивается, когда компилятор завершает работу и ваш билдер выдает объект `BuilderOutput`.                                                                                                                               |
| Наблюдение | Между двумя запусками наблюдайте за потоком внешних событий. Например, следите за файловой системой на предмет любых изменений. Это заканчивается, когда компилятор перезапускается и вызывается `context.reportRunning()`.                                                 |
| Завершение | Либо задача полностью завершена (например, компилятор, который должен запуститься определенное количество раз), либо выполнение билдера было остановлено (с помощью `BuilderRun.stop()`). Architect выполняет логику очистки и отписывается от `Observable` вашего билдера. |

## Резюме

API билдеров CLI предоставляет средства для изменения поведения Angular CLI путем использования билдеров для выполнения
пользовательской логики.

- Билдеры могут быть синхронными или асинхронными, выполняться один раз или наблюдать за внешними событиями, а также
  могут планировать другие билдеры или цели.
- Билдеры имеют значения опций по умолчанию, указанные в файле конфигурации `angular.json`, которые могут быть
  перезаписаны альтернативной конфигурацией для цели и дополнительно перезаписаны флагами командной строки.
- Команда Angular рекомендует использовать интеграционные тесты для тестирования билдеров Architect. Используйте
  модульные тесты для проверки логики, которую выполняет билдер.
- Если ваш билдер возвращает `Observable`, он должен очищать ресурсы билдера в логике завершения (teardown) этого
  `Observable`.
