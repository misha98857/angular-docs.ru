# Создание библиотек

Эта страница содержит концептуальный обзор того, как создавать и публиковать новые библиотеки для расширения
функциональности Angular.

Если вам приходится решать одну и ту же задачу в нескольких приложениях (или вы хотите поделиться своим решением с
другими разработчиками), то это кандидат для создания библиотеки.
Простым примером может быть кнопка, перенаправляющая пользователей на веб-сайт вашей компании, которая будет включена во
все приложения, создаваемые вашей компанией.

## Начало работы

Используйте Angular CLI для создания скелета новой библиотеки в новом рабочем пространстве с помощью следующих команд.

```shell

ng new my-workspace --no-create-application
cd my-workspace
ng generate library my-lib

```

<docs-callout title="Именование вашей библиотеки">

Вам следует очень внимательно подходить к выбору имени библиотеки, если вы планируете опубликовать её в публичном
реестре пакетов, таком как npm.
См. [Публикация вашей библиотеки](tools/libraries/creating-libraries#publishing-your-library).

Избегайте использования имен с префиксом `ng-`, например `ng-library`.
Префикс `ng-` зарезервирован для фреймворка Angular и его библиотек.
Предпочтительным является префикс `ngx-`, который принято использовать для обозначения того, что библиотека подходит для
использования с Angular.
Это также отличный способ для пользователей реестра отличить библиотеки для разных JavaScript-фреймворков.

</docs-callout>

Команда `ng generate` создает папку `projects/my-lib` в вашем рабочем пространстве, которая содержит компонент.

HELPFUL: Для получения более подробной информации о структуре проекта библиотеки обратитесь к
разделу [Файлы проекта библиотеки](reference/configs/file-structure#library-project-files)
руководства [Структура файлов проекта](reference/configs/file-structure).

Используйте модель монорепозитория, чтобы использовать одно рабочее пространство для нескольких проектов.
См. [Настройка рабочего пространства для нескольких проектов](reference/configs/file-structure#multiple-projects).

При генерации новой библиотеки файл конфигурации рабочего пространства `angular.json` обновляется проектом типа
`library`.

```json

"projects": {
  …
  "my-lib": {
    "root": "projects/my-lib",
    "sourceRoot": "projects/my-lib/src",
    "projectType": "library",
    "prefix": "lib",
    "architect": {
      "build": {
        "builder": "@angular-devkit/build-angular:ng-packagr",
        …

```

Соберите, протестируйте и проверьте проект с помощью команд CLI:

```shell

ng build my-lib --configuration development
ng test my-lib
ng lint my-lib

```

Обратите внимание, что настроенный билдер для проекта отличается от билдера по умолчанию для проектов приложений.
Этот билдер, помимо прочего, гарантирует, что библиотека всегда собирается с
помощью [AOT-компилятора](tools/cli/aot-compiler).

Чтобы сделать код библиотеки пригодным для повторного использования, вы должны определить для него публичный API.
Этот «пользовательский слой» определяет, что доступно потребителям вашей библиотеки.
Пользователь вашей библиотеки должен иметь возможность доступа к публичной функциональности (такой как провайдеры
сервисов и общие утилитарные функции) через единый путь импорта.

Публичный API вашей библиотеки поддерживается в файле `public-api.ts` в папке вашей библиотеки.
Все, что экспортируется из этого файла, становится публичным при импорте вашей библиотеки в приложение.

Ваша библиотека должна предоставлять документацию (обычно файл README) по установке и обслуживанию.

## Рефакторинг частей приложения в библиотеку

Чтобы сделать ваше решение пригодным для повторного использования, необходимо адаптировать его так, чтобы оно не
зависело от специфичного для приложения кода.
Вот некоторые моменты, которые следует учитывать при переносе функциональности приложения в библиотеку.

- Объявления, такие как компоненты и Pipe, должны быть спроектированы как stateless (без состояния), то есть они не
  должны зависеть от внешних переменных или изменять их.
  Если вы полагаетесь на состояние, вам нужно оценить каждый случай и решить, является ли это состоянием приложения или
  состоянием, которым должна управлять библиотека.

- Любые Observable, на которые компоненты подписываются внутри, должны быть очищены и удалены в течение жизненного цикла
  этих компонентов.
- Компоненты должны предоставлять свои взаимодействия через Input-свойства для передачи контекста и Output-свойства для
  сообщения о событиях другим компонентам.

- Проверьте все внутренние зависимости.
  - Для пользовательских классов или интерфейсов, используемых в компонентах или сервисах, проверьте, зависят ли они от
    дополнительных классов или интерфейсов, которые также необходимо перенести.
  - Аналогично, если код вашей библиотеки зависит от сервиса, этот сервис также необходимо перенести.
  - Если код вашей библиотеки или её шаблоны зависят от других библиотек (например, Angular Material), вы должны
    настроить вашу библиотеку с учетом этих зависимостей.

- Подумайте, как вы предоставляете сервисы клиентским приложениям.
  - Сервисы должны объявлять свои собственные провайдеры, а не объявлять провайдеры в NgModule или компоненте.
    Объявление провайдера делает этот сервис поддерживающим _Tree Shaking_.
    Эта практика позволяет компилятору исключить сервис из бандла, если он никогда не внедряется в приложение,
    импортирующее библиотеку.
    Подробнее об этом см. в разделе [Tree-shakable провайдеры](guide/di/lightweight-injection-tokens).

  - Если вы регистрируете глобальные провайдеры сервисов, предоставьте функцию-провайдер `provideXYZ()`.
  - Если ваша библиотека предоставляет необязательные сервисы, которые могут использоваться не всеми клиентскими
    приложениями, обеспечьте правильную поддержку Tree Shaking для этого случая,
    используя [шаблон проектирования легковесных токенов](guide/di/lightweight-injection-tokens).

## Интеграция с CLI с использованием схем генерации кода

Библиотека обычно содержит _повторно используемый код_, определяющий компоненты, сервисы и другие артефакты Angular (
Pipe, директивы), которые вы импортируете в проект.
Библиотека упаковывается в npm-пакет для публикации и распространения.
Этот пакет также может включать схемы (schematics), которые предоставляют инструкции для генерации или преобразования
кода непосредственно в вашем проекте, так же как CLI создает новый типовой компонент с помощью `ng generate component`.
Схема, упакованная вместе с библиотекой, может, например, предоставить Angular CLI информацию, необходимую для генерации
компонента, который настраивает и использует определенную функцию или набор функций, определенных в этой библиотеке.
Одним из примеров этого
является [схема навигации Angular Material](https://material.angular.dev/guide/schematics#navigation-schematic), которая
настраивает [BreakpointObserver](https://material.angular.dev/cdk/layout/overview#breakpointobserver) из CDK и
использует его с компонентами [MatSideNav](https://material.angular.dev/components/sidenav/overview)
и [MatToolbar](https://material.angular.dev/components/toolbar/overview) из Material.

Создайте и включите следующие виды схем:

- Включите схему установки, чтобы `ng add` могла добавить вашу библиотеку в проект.
- Включите схемы генерации в вашу библиотеку, чтобы `ng generate` могла создавать каркас ваших определенных артефактов (
  компонентов, сервисов, тестов) в проекте.
- Включите схему обновления, чтобы `ng update` могла обновлять зависимости вашей библиотеки и предоставлять миграции для
  критических изменений в новых версиях.

То, что вы включите в свою библиотеку, зависит от вашей задачи.
Например, вы можете определить схему для создания выпадающего списка, предварительно заполненного готовыми данными,
чтобы показать, как добавить его в приложение.
Если вам нужен выпадающий список, который каждый раз будет содержать разные передаваемые значения, ваша библиотека может
определить схему для его создания с заданной конфигурацией.
Разработчики затем смогут использовать `ng generate` для настройки экземпляра для своего собственного приложения.

Предположим, вы хотите прочитать файл конфигурации, а затем сгенерировать форму на основе этой конфигурации.
Если эта форма требует дополнительной настройки разработчиком, использующим вашу библиотеку, то лучше всего подойдет
схема.
Однако, если форма всегда будет одинаковой и не потребует особой настройки разработчиками, то вы можете создать
динамический компонент, который принимает конфигурацию и генерирует форму.
В целом, чем сложнее настройка, тем полезнее подход со схемами.

Для получения дополнительной информации см. [Обзор схем](tools/cli/schematics)
и [Схемы для библиотек](tools/cli/schematics-for-libraries).

## Публикация вашей библиотеки

Используйте Angular CLI и менеджер пакетов npm для сборки и публикации вашей библиотеки в виде npm-пакета.

Angular CLI использует инструмент под
названием [ng-packagr](https://github.com/ng-packagr/ng-packagr/blob/master/README.md) для создания пакетов из вашего
скомпилированного кода, которые можно опубликовать в npm.
См. [Сборка библиотек с Ivy](tools/libraries/creating-libraries#publishing-libraries) для получения информации о
форматах распространения, поддерживаемых `ng-packagr`, и рекомендаций по выбору правильного формата для вашей
библиотеки.

Всегда следует собирать библиотеки для распространения, используя конфигурацию `production`.
Это гарантирует, что сгенерированный результат использует соответствующие оптимизации и правильный формат пакета для
npm.

```shell

ng build my-lib
cd dist/my-lib
npm publish

```

## Управление ассетами в библиотеке

В вашей библиотеке Angular дистрибутив может включать дополнительные ассеты, такие как файлы тем, миксины Sass или
документацию (например, журнал изменений).
Для получения дополнительной информации
см. [копирование ассетов в библиотеку как часть сборки](https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md)
и [встраивание ассетов в стили компонентов](https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md).

IMPORTANT: При включении дополнительных ассетов, таких как миксины Sass или предварительно скомпилированный CSS.
Вам необходимо добавить их вручную в условные ["exports"](tools/libraries/angular-package-format#quotexportsquot) в
файле `package.json` основной точки входа.

`ng-packagr` объединит написанные вручную `"exports"` с автоматически сгенерированными, позволяя авторам библиотек
настраивать дополнительные подпути экспорта или пользовательские условия.

```json

"exports": {
  ".": {
    "sass": "./_index.scss",
  },
  "./theming": {
    "sass": "./_theming.scss"
  },
  "./prebuilt-themes/indigo-pink.css": {
    "style": "./prebuilt-themes/indigo-pink.css"
  }
}

```

Выше приведен фрагмент из дистрибутива [@angular/material](https://unpkg.com/browse/@angular/material/package.json).

## Peer dependencies (Партнерские зависимости)

Библиотеки Angular должны указывать любые зависимости `@angular/*`, от которых зависит библиотека, как
`peerDependencies`.
Это гарантирует, что когда модули запрашивают Angular, они все получают один и тот же модуль.
Если библиотека указывает `@angular/core` в `dependencies` вместо `peerDependencies`, она может получить другой модуль
Angular, что приведет к поломке вашего приложения.

## Использование собственной библиотеки в приложениях

Вам не обязательно публиковать библиотеку в менеджере пакетов npm, чтобы использовать её в том же рабочем пространстве,
но сначала её нужно собрать.

Чтобы использовать собственную библиотеку в приложении:

- Соберите библиотеку.
  Вы не можете использовать библиотеку до того, как она будет собрана.

```shell
  ng build my-lib
```

- В ваших приложениях импортируйте библиотеку по имени:

```ts
  import { myExport } from 'my-lib';
```

### Сборка и пересборка вашей библиотеки

Этап сборки важен, если вы не опубликовали свою библиотеку как npm-пакет и затем не установили пакет обратно в свое
приложение из npm.
Например, если вы клонируете свой git-репозиторий и запускаете `npm install`, ваш редактор покажет импорты `my-lib` как
отсутствующие, если вы еще не собрали свою библиотеку.

HELPFUL: Когда вы импортируете что-то из библиотеки в приложении Angular, Angular ищет сопоставление между именем
библиотеки и расположением на диске.
Когда вы устанавливаете пакет библиотеки, сопоставление находится в папке `node_modules`.
Когда вы собираете свою собственную библиотеку, он должен найти сопоставление в путях `tsconfig`.

Генерация библиотеки с помощью Angular CLI автоматически добавляет её путь в файл `tsconfig`.
Angular CLI использует пути `tsconfig`, чтобы сообщить системе сборки, где найти библиотеку.

Для получения дополнительной информации
см. [Обзор сопоставления путей](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping).

Вы можете пересобирать библиотеку всякий раз, когда вносите в неё изменения, но этот дополнительный шаг занимает время.
Функциональность _инкрементальных сборок_ улучшает опыт разработки библиотек.
Каждый раз при изменении файла выполняется частичная сборка, которая выдает измененные файлы.

Инкрементальные сборки могут запускаться как фоновый процесс в вашей среде разработки.
Чтобы воспользоваться этой функцией, добавьте флаг `--watch` к команде сборки:

```shell

ng build my-lib --watch

```

IMPORTANT: Команда CLI `build` использует другой билдер и вызывает другой инструмент сборки для библиотек, чем для
приложений.

- Система сборки для приложений, `@angular-devkit/build-angular`, основана на `webpack` и включена во все новые проекты
  Angular CLI.
- Система сборки для библиотек основана на `ng-packagr`.
  Она добавляется в ваши зависимости только тогда, когда вы добавляете библиотеку с помощью
  `ng generate library my-lib`.

Две системы сборки поддерживают разные вещи, и даже там, где они поддерживают одни и те же вещи, они делают это
по-разному.
Это означает, что исходный код TypeScript может привести к другому коду JavaScript в собранной библиотеке, чем в
собранном приложении.

По этой причине приложение, зависящее от библиотеки, должно использовать только сопоставления путей TypeScript,
указывающие на _собранную библиотеку_.
Сопоставления путей TypeScript _не должны_ указывать на исходные `.ts` файлы библиотеки.

### Линковка библиотек для локальной разработки

В этом разделе объясняется, как использовать функцию локальной линковки вашего менеджера пакетов
(например, [`npm link`](https://pnpm.io/cli/link) или [`pnpm link`](https://pnpm.io/cli/link)) для тестирования
standalone-библиотеки Angular с внешним приложением во время
локальной разработки, не полагаясь на структуру монорепозитория и не публикуя её в реестре NPM.

NOTE: Если ваша библиотека и приложение находятся в одном рабочем пространстве Angular (настройка монорепозитория),
стандартный рабочий процесс монорепозитория автоматически обрабатывает линковку и, как правило, более эффективен. Этот
подход локальной линковки лучше всего подходит, когда:

- Вы разрабатываете standalone-библиотеку и вам нужно протестировать изменения с внешним потребляющим приложением.
- Вы тестируете изменения библиотеки в потребляющем приложении за пределами рабочего пространства монорепозитория.

#### Настройка потребляющего приложения

Чтобы использовать прилинкованные библиотеки, вам необходимо настроить файл `angular.json` вашего приложения со
следующими параметрами:

```json
{
  "projects": {
    "your-app": {
      "architect": {
        "build": {
          "builder": "@angular/build:application",
          "options": {
            "preserveSymlinks": true
          },
          "configurations": {
            "development": {
              "sourceMap": {
                "scripts": true,
                "styles": true,
                "vendor": true
              }
            }
          }
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "options": {
            "prebundle": {
              "exclude": [
                "my-lib"
              ]
            }
          }
        }
      }
    }
  }
}
```

**Пояснение параметров конфигурации:**

- `preserveSymlinks: true`: Указывает системе сборки следовать по символическим ссылкам, созданным командой линковки
  вашего менеджера пакетов, вместо разрешения исходного местоположения символической ссылки. Это необходимо, чтобы
  избежать создания нескольких копий зависимых node-пакетов.
- `sourceMap.vendor`: Включение карт кода (source maps) поставщиков (особенно `vendor: true`) для упрощения отладки кода
  прилинкованной библиотеки.
- `prebundle.exclude`: По умолчанию Angular CLI может предварительно собирать все node-зависимости. Исключение вашей
  библиотеки гарантирует, что прилинкованный исходный код будет правильно отслеживаться и пересобираться при
  возникновении изменений.

## Публикация библиотек

Существует два формата распространения, используемых при публикации библиотеки:

| Форматы распространения     | Подробности                                                                                                                                                                                                                                                                                                                             |
| :-------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Partial-Ivy (рекомендуется) | Содержит переносимый код, который может использоваться Ivy-приложениями, созданными с любой версией Angular, начиная с v12.                                                                                                                                                                                                             |
| Full-Ivy                    | Содержит приватные инструкции Angular Ivy, работа которых не гарантируется в разных версиях Angular. Этот формат требует, чтобы библиотека и приложение были собраны с использованием _одной и той же_ версии Angular. Этот формат полезен для сред, где весь код библиотеки и приложения собирается непосредственно из исходного кода. |

Для публикации в npm используйте формат partial-Ivy, так как он стабилен между патч-версиями Angular.

Избегайте компиляции библиотек с кодом full-Ivy, если вы публикуете их в npm, поскольку сгенерированные инструкции Ivy
не являются частью публичного API Angular и могут изменяться между патч-версиями.

## Обеспечение совместимости версий библиотеки

Версия Angular, используемая для сборки приложения, всегда должна быть такой же или новее, чем версии Angular,
используемые для сборки любой из его зависимых библиотек.
Например, если у вас есть библиотека, использующая Angular версии 13, приложение, зависящее от этой библиотеки, должно
использовать Angular версии 13 или новее.
Angular не поддерживает использование более ранней версии для приложения.

Если вы намерены опубликовать свою библиотеку в npm, скомпилируйте её с кодом partial-Ivy, установив
`"compilationMode": "partial"` в `tsconfig.prod.json`.
Этот частичный формат стабилен между различными версиями Angular, поэтому его безопасно публиковать в npm.
Код в этом формате обрабатывается во время сборки приложения с использованием той же версии компилятора Angular,
гарантируя, что приложение и все его библиотеки используют единую версию Angular.

Избегайте компиляции библиотек с кодом full-Ivy, если вы публикуете их в npm, поскольку сгенерированные инструкции Ivy
не являются частью публичного API Angular и могут изменяться между патч-версиями.

Если вы никогда раньше не публиковали пакет в npm, вам необходимо создать учетную запись пользователя.
Подробнее читайте в [Публикация пакетов npm](https://docs.npmjs.com/getting-started/publishing-npm-packages).

## Использование кода partial-Ivy вне Angular CLI

Приложение устанавливает множество библиотек Angular из npm в свой каталог `node_modules`.
Однако код в этих библиотеках не может быть упакован непосредственно вместе с собранным приложением, так как он не
полностью скомпилирован.
Для завершения компиляции используйте линкер Angular.

Для приложений, которые не используют Angular CLI, линкер доступен как плагин [Babel](https://babeljs.io).
Плагин следует импортировать из `@angular/compiler-cli/linker/babel`.

Плагин линкера Angular для Babel поддерживает кэширование сборки, что означает, что библиотеки должны обрабатываться
линкером только один раз, независимо от других операций npm.

Пример интеграции плагина в пользовательскую сборку [webpack](https://webpack.js.org) путем регистрации линкера как
плагина [Babel](https://babeljs.io) с
использованием [babel-loader](https://webpack.js.org/loaders/babel-loader/#options).

<docs-code header="webpack.config.mjs" path="adev/src/content/examples/angular-linker-plugin/webpack.config.mjs" visibleRegion="webpack-config"/>

HELPFUL: Angular CLI интегрирует плагин линкера автоматически, поэтому, если потребители вашей библиотеки используют
CLI, они могут устанавливать Ivy-native библиотеки из npm без какой-либо дополнительной настройки.
