# Формат пакетов Angular

Этот документ описывает формат пакетов Angular (APF).
APF — это специфичная для Angular спецификация структуры и формата npm-пакетов, которая используется всеми официальными
пакетами Angular (`@angular/core`, `@angular/material` и т.д.) и большинством сторонних библиотек Angular.

APF позволяет пакету беспрепятственно работать в большинстве распространенных сценариев использования Angular.
Пакеты, использующие APF, совместимы с инструментарием, предлагаемым командой Angular, а также с более широкой
экосистемой JavaScript.
Разработчикам сторонних библиотек рекомендуется придерживаться того же формата npm-пакетов.

HELPFUL: Версионирование APF происходит вместе с остальной частью Angular, и каждая мажорная версия улучшает формат
пакета.
Вы можете найти версии спецификации до v13 в
этом [google doc](https://docs.google.com/document/d/1CZC2rcpxffTDfRDs6p1cfbmKNLA6x5O-NtkJglDaBVs/preview).

## Зачем нужен формат пакета?

В современном ландшафте JavaScript разработчики используют пакеты множеством различных способов, применяя разные наборы
инструментов (webpack, Rollup, esbuild и т.д.).
Эти инструменты могут понимать и требовать разные входные данные: некоторые могут обрабатывать последнюю версию языка
ES, в то время как другие выигрывают от прямого использования более старой версии ES.

Формат дистрибуции Angular поддерживает все часто используемые инструменты разработки и рабочие процессы, а также делает
упор на оптимизации, которые приводят либо к меньшему размеру загружаемого приложения, либо к более быстрому циклу
итерации разработки (времени сборки).

Разработчики могут положиться на Angular CLI и [ng-packagr](https://github.com/ng-packagr/ng-packagr) (инструмент
сборки, используемый Angular CLI) для создания пакетов в формате Angular.
Смотрите руководство [Создание библиотек](tools/libraries/creating-libraries) для получения более подробной информации.

## Структура файлов

Следующий пример показывает упрощенную версию структуры файлов пакета `@angular/core` с пояснением для каждого файла в
пакете.

```markdown
node_modules/@angular/core
├── README.md
├── package.json
├── fesm2022
│   ├── core.mjs
│   ├── core.mjs.map
│   ├── testing.mjs
│   └── testing.mjs.map
└── types
│   ├── core.d.ts
│   ├── testing.d.ts
```

Эта таблица описывает структуру файлов в `node_modules/@angular/core` с аннотациями, описывающими назначение файлов и
директорий:

| Файлы                                                                                                                                                     | Назначение                                                                                                                                                                                                                       |
| :-------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `README.md`                                                                                                                                               | README пакета, используется веб-интерфейсом npmjs.                                                                                                                                                                               |
| `package.json`                                                                                                                                            | Основной `package.json`, описывающий сам пакет, а также все доступные точки входа и форматы кода. Этот файл содержит сопоставление "exports", используемое средами выполнения и инструментами для выполнения разрешения модулей. |
| `fesm2022/` <br /> &nbsp;&nbsp;─ `core.mjs` <br /> &nbsp;&nbsp;─ `core.mjs.map` <br /> &nbsp;&nbsp;─ `testing.mjs` <br /> &nbsp;&nbsp;─ `testing.mjs.map` | Код для всех точек входа в плоском (FESM) формате ES2022 вместе с картами кода (source maps).                                                                                                                                    |
| `types/` <br /> &nbsp;&nbsp;─ `core.d.ts` <br /> &nbsp;&nbsp;─ `testing.d.ts`                                                                             | Сборка определений типов TypeScript для всех публичных точек входа.                                                                                                                                                              |

## `package.json`

Основной `package.json` содержит важные метаданные пакета, включая следующее:

- Он [объявляет](#esm-declaration), что пакет находится в формате EcmaScript Module (ESM).
- Он содержит поле `"exports"`, которое определяет доступные форматы исходного кода для всех точек входа.
- Он содержит [ключи](#legacy-resolution-keys), которые определяют доступные форматы исходного кода основной точки входа
  `@angular/core` для инструментов, не понимающих `"exports"`.
  Эти ключи считаются устаревшими и могут быть удалены по мере распространения поддержки `"exports"` в экосистеме.

- Он объявляет, содержит ли пакет [побочные эффекты](#side-effects).

### Объявление ESM {#esm-declaration}

`package.json` верхнего уровня содержит ключ:

```js
{
  "type": "module"
}
```

Это сообщает резолверам, что код внутри пакета использует модули EcmaScript, а не модули CommonJS.

### `"exports"`

Поле `"exports"` имеет следующую структуру:

```js
"exports": {
  "./schematics/*": {
    "default": "./schematics/*.js"
  },
  "./package.json": {
    "default": "./package.json"
  },
  ".": {
    "types": "./types/core.d.ts",
    "default": "./fesm2022/core.mjs"
  },
  "./testing": {
    "types": "./types/testing.d.ts",
    "default": "./fesm2022/testing.mjs"
  }
}
```

Основной интерес представляют ключи `"."` и `"./testing"`, которые определяют доступные форматы кода для основной точки
входа `@angular/core` и вторичной точки входа `@angular/core/testing` соответственно.
Для каждой точки входа доступными форматами являются:

| Форматы                   | Детали                                                                           |
| :------------------------ | :------------------------------------------------------------------------------- |
| Типизация (файлы `.d.ts`) | Файлы `.d.ts` используются TypeScript при наличии зависимости от данного пакета. |
| `default`                 | Код ES2022, собранный в один файл (плоский формат).                              |

Инструменты, которые знают об этих ключах, могут предпочтительно выбирать желаемый формат кода из `"exports"`.

Библиотеки могут захотеть предоставить дополнительные статические файлы, которые не охватываются экспортом точек входа
на основе JavaScript, например, миксины Sass или предварительно скомпилированный CSS.

Для получения дополнительной информации
см. [Управление ассетами в библиотеке](tools/libraries/creating-libraries#managing-assets-in-a-library).

### Устаревшие ключи разрешения {#legacy-resolution-keys}

В дополнение к `"exports"`, `package.json` верхнего уровня также определяет устаревшие ключи разрешения модулей для
резолверов, которые не поддерживают `"exports"`.
Для `@angular/core` это:

```js
{
  "module": "./fesm2022/core.mjs",
  "typings": "./types/core.d.ts",
}
```

Как показано в приведенном выше фрагменте кода, резолвер модулей может использовать эти ключи для загрузки определенного
формата кода.

### Побочные эффекты {#side-effects}

Последняя функция `package.json` — объявить, имеет ли пакет [побочные эффекты](#sideeffects-flag).

```js
{
  "sideEffects": false
}
```

Большинство пакетов Angular не должны зависеть от побочных эффектов верхнего уровня и, следовательно, должны включать
это объявление.

## Точки входа и разделение кода

Пакеты в формате Angular содержат одну основную точку входа и ноль или более вторичных точек входа (например,
`@angular/common/http`).
Точки входа выполняют несколько функций.

1. Они определяют спецификаторы модулей, из которых пользователи импортируют код (например, `@angular/core` и
   `@angular/core/testing`).

   Пользователи обычно воспринимают эти точки входа как отдельные группы символов с различными целями или возможностями.

   Определенные точки входа могут использоваться только для специальных целей, таких как тестирование.
   Такие API могут быть отделены от основной точки входа, чтобы уменьшить вероятность их случайного или неправильного
   использования.

1. Они определяют гранулярность, с которой код может быть загружен лениво (отложенно).

   Многие современные инструменты сборки способны выполнять "разделение кода" (code splitting, или ленивую загрузку)
   только на уровне ES-модулей.
   Формат пакетов Angular использует преимущественно один "плоский" ES-модуль на точку входа. Это означает, что
   большинство инструментов сборки не могут разделить код с одной точкой входа на несколько выходных чанков.

Общее правило для пакетов APF — использовать точки входа для наименьших наборов логически связанного кода.
Например, пакет Angular Material публикует каждый логический компонент или набор компонентов как отдельную точку входа —
одну для Button, одну для Tabs и т.д.
Это позволяет каждому компоненту Material загружаться лениво и по отдельности, если это необходимо.

Не всем библиотекам требуется такая детализация.
Большинство библиотек с одной логической целью должны публиковаться как одна точка входа.
`@angular/core`, например, использует одну точку входа для среды выполнения, поскольку среда выполнения Angular обычно
используется как единое целое.

### Разрешение вторичных точек входа

Вторичные точки входа могут быть разрешены через поле `"exports"` в `package.json` пакета.

## README.md

Файл README в формате Markdown, который используется для отображения описания пакета на npm и GitHub.

Пример содержимого README пакета @angular/core:

```html

Angular
&equals;&equals;&equals;&equals;&equals;&equals;&equals;

The sources for this package are in the main [Angular](https://github.com/angular/angular) repo.Please file issues and pull requests against that repo.

License: MIT

```

## Частичная компиляция

Библиотеки в формате пакетов Angular должны публиковаться в режиме "частичной компиляции".
Это режим компиляции для `ngc`, который создает скомпилированный код Angular, не привязанный к конкретной версии среды
выполнения Angular, в отличие от полной компиляции, используемой для приложений, где версии компилятора и среды
выполнения Angular должны точно совпадать.

Чтобы частично скомпилировать код Angular, используйте флаг `compilationMode` в свойстве `angularCompilerOptions` вашего
`tsconfig.json`:

```js
{
  …
  "angularCompilerOptions": {
    "compilationMode": "partial",
  }
}
```

Частично скомпилированный код библиотеки затем преобразуется в полностью скомпилированный код в процессе сборки
приложения с помощью Angular CLI.

Если ваш конвейер сборки не использует Angular CLI, обратитесь к
руководству [Использование частичного кода Ivy вне Angular CLI](tools/libraries/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli).

## Оптимизации

### Преобразование в плоские ES-модули

Формат пакетов Angular определяет, что код должен публиковаться в "плоском" (flattened) формате ES-модулей.
Это значительно сокращает время сборки приложений Angular, а также время загрузки и парсинга итогового бандла
приложения.
Пожалуйста, ознакомьтесь с отличным
постом ["Стоимость маленьких модулей"](https://nolanlawson.com/2016/08/15/the-cost-of-small-modules) от Нолана Лоусона.

Компилятор Angular может генерировать индексные файлы ES-модулей. Инструменты, такие как Rollup, могут использовать эти
файлы для генерации плоских модулей в формате _Flattened ES Module_ (FESM).

FESM — это формат файла, созданный путем объединения (уплощения) всех ES-модулей, доступных из точки входа, в один
ES-модуль.
Он формируется путем отслеживания всех импортов из пакета и копирования этого кода в один файл с сохранением всех
публичных ES-экспортов и удалением всех приватных импортов.

Аббревиатура FESM, произносимая как _фе-сом_, может сопровождаться числом, например FESM2020.
Число относится к уровню языка JavaScript внутри модуля.
Соответственно, файл FESM2022 будет ESM+ES2022 и будет включать операторы import/export и исходный код ES2022.

Чтобы сгенерировать индексный файл плоского ES-модуля, используйте следующие параметры конфигурации в вашем файле
tsconfig.json:

```js
{
  "compilerOptions": {
    …
    "module": "esnext",
    "target": "es2022",
    …
  },
  "angularCompilerOptions": {
    …
    "flatModuleOutFile": "my-ui-lib.js",
    "flatModuleId": "my-ui-lib"
  }
}
```

Как только индексный файл (например, `my-ui-lib.js`) сгенерирован с помощью ngc, бандлеры и оптимизаторы, такие как
Rollup, могут быть использованы для создания плоского ESM-файла.

### Флаг "sideEffects" {#sideeffects-flag}

По умолчанию модули EcmaScript считаются имеющими побочные эффекты: импорт из модуля гарантирует, что любой код на
верхнем уровне этого модуля будет выполнен.
Это часто нежелательно, так как большинство кода с побочными эффектами в типичных модулях на самом деле не имеет
истинных побочных эффектов, а влияет только на конкретные символы.
Если эти символы не импортируются и не используются, часто желательно удалить их в процессе оптимизации, известном как
Tree Shaking, но код с побочными эффектами может этому помешать.

Инструменты сборки, такие как webpack, поддерживают флаг, который позволяет пакетам объявлять, что они не зависят от
кода с побочными эффектами на верхнем уровне своих модулей, предоставляя инструментам больше свободы для применения Tree
Shaking к коду из пакета.
Конечным результатом этих оптимизаций должен стать меньший размер бандла и лучшее распределение кода по чанкам после
разделения кода.
Эта оптимизация может сломать ваш код, если он содержит нелокальные побочные эффекты — однако это не распространено в
приложениях Angular и обычно является признаком плохого проектирования.
Рекомендация для всех пакетов — заявлять о статусе отсутствия побочных эффектов, устанавливая свойство `sideEffects` в
`false`, и чтобы разработчики следовали [Angular Style Guide](/style-guide), что естественным образом приводит к коду
без нелокальных побочных эффектов.

Больше
информации: [документация webpack о побочных эффектах](https://github.com/webpack/webpack/tree/master/examples/side-effects)

### Уровень языка ES2022

Уровень языка ES2022 теперь является уровнем языка по умолчанию, который потребляется Angular CLI и другими
инструментами.
Angular CLI понижает версию бандла до уровня языка, который поддерживается всеми целевыми браузерами во время сборки
приложения.

### Сборка d.ts / уплощение определений типов

Начиная с APF v8, рекомендуется собирать (bundle) определения TypeScript.
Сборка определений типов может значительно ускорить компиляцию для пользователей, особенно если в вашей библиотеке много
отдельных исходных файлов `.ts`.

Angular использует [`rollup-plugin-dts`](https://github.com/Swatinem/rollup-plugin-dts) для уплощения файлов `.d.ts` (
используя `rollup`, аналогично тому, как создаются файлы FESM).

Использование rollup для сборки `.d.ts` полезно, так как оно поддерживает разделение кода между точками входа.
Например, если у вас есть несколько точек входа, полагающихся на один и тот же общий тип, будет создан общий файл
`.d.ts` вместе с более крупными плоскими файлами `.d.ts`.
Это желательно и позволяет избежать дублирования типов.

### Tslib

Начиная с APF v10, рекомендуется добавлять tslib как прямую зависимость вашей основной точки входа.
Это связано с тем, что версия tslib привязана к версии TypeScript, используемой для компиляции вашей библиотеки.

## Примеры

<docs-pill-row>
  <docs-pill href="https://unpkg.com/browse/@angular/core@17.0.0/" title="пакет @angular/core"/>
  <docs-pill href="https://unpkg.com/browse/@angular/material@17.0.0/" title="пакет @angular/material"/>
</docs-pill-row>

## Определение терминов

Следующие термины используются в этом документе намеренно.
В этом разделе приведены определения всех терминов для обеспечения дополнительной ясности.

### Пакет (Package)

Наименьший набор файлов, которые публикуются в NPM и устанавливаются вместе, например `@angular/core`.
Этот пакет включает манифест под названием package.json, скомпилированный исходный код, файлы определений typescript,
карты кода (source maps), метаданные и т.д.
Пакет устанавливается с помощью `npm install @angular/core`.

### Символ (Symbol)

Класс, функция, константа или переменная, содержащаяся в модуле и, возможно, сделанная видимой для внешнего мира через
экспорт модуля.

### Модуль (Module)

Сокращение от ECMAScript Modules.
Файл, содержащий операторы, которые импортируют и экспортируют символы.
Это идентично определению модулей в спецификации ECMAScript.

### ESM

Сокращение от ECMAScript Modules (см. выше).

### FESM

Сокращение от Flattened ES Modules (Плоские ES-модули) и представляет собой формат файла, созданный путем объединения
всех ES-модулей, доступных из точки входа, в один ES-модуль.

### ID модуля (Module ID)

Идентификатор модуля, используемый в операторах импорта (например, `@angular/core`).
ID часто напрямую сопоставляется с путем в файловой системе, но это не всегда так из-за различных стратегий разрешения
модулей.

### Спецификатор модуля (Module specifier)

Идентификатор модуля (см. выше).

### Стратегия разрешения модулей (Module resolution strategy)

Алгоритм, используемый для преобразования ID модулей в пути в файловой системе.
У Node.js есть хорошо специфицированная и широко используемая стратегия, TypeScript поддерживает несколько стратегий
разрешения модулей, у [Closure Compiler](https://developers.google.com/closure/compiler) есть еще одна стратегия.

### Формат модуля (Module format)

Спецификация синтаксиса модуля, которая охватывает как минимум синтаксис для импорта и экспорта из файла.
Распространенными форматами модулей являются CommonJS (CJS, обычно используемый для приложений Node.js) или ECMAScript
Modules (ESM).
Формат модуля указывает только на упаковку отдельных модулей, но не на возможности языка JavaScript, используемые для
создания содержимого модуля.
По этой причине команда Angular часто использует спецификатор уровня языка в качестве суффикса к формату модуля (
например, ESM+ES2022 указывает, что модуль находится в формате ESM и содержит код ES2022).

### Бандл (Bundle)

Артефакт в виде одного JS-файла, созданный инструментом сборки (например, [webpack](https://webpack.js.org)
или [Rollup](https://rollupjs.org)), который содержит символы, происходящие из одного или нескольких модулей.
Бандлы — это специфичный для браузера обходной путь, который снижает нагрузку на сеть, которая возникла бы, если бы
браузеры начали загружать сотни, если не десятки тысяч файлов.
Node.js обычно не использует бандлы.
Распространенными форматами бандлов являются UMD и System.register.

### Уровень языка (Language level)

Язык кода (ES2022).
Не зависит от формата модуля.

### Точка входа (Entry point)

Модуль, предназначенный для импорта пользователем.
На него ссылается уникальный ID модуля, и он экспортирует публичный API, на который ссылается этот ID модуля.
Примером является `@angular/core` или `@angular/core/testing`.
Обе точки входа существуют в пакете `@angular/core`, но они экспортируют разные символы.
Пакет может иметь много точек входа.

### Глубокий импорт (Deep import)

Процесс получения символов из модулей, которые не являются точками входа.
Эти ID модулей обычно считаются приватными API, которые могут изменяться в течение срока службы проекта или во время
создания бандла для данного пакета.

### Импорт верхнего уровня (Top-Level import)

Импорт, исходящий из точки входа.
Доступные импорты верхнего уровня — это то, что определяет публичный API и доступно в модулях "@angular/name", таких как
`@angular/core` или `@angular/common`.

### Tree-shaking

Процесс идентификации и удаления кода, не используемого приложением — также известный как удаление мертвого кода.
Это глобальная оптимизация, выполняемая на уровне приложения с использованием таких инструментов,
как [Rollup](https://rollupjs.org), [Closure Compiler](https://developers.google.com/closure/compiler)
или [Terser](https://github.com/terser/terser).

### AOT-компилятор (AOT compiler)

Компилятор Ahead of Time (компиляция перед исполнением) для Angular.

### Плоские определения типов (Flattened type definitions)

Собранные (bundled) определения TypeScript, сгенерированные с помощью [API Extractor](https://api-extractor.com).
