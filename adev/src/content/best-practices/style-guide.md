# Angular coding style guide

## Введение

Это руководство охватывает ряд соглашений по стилю для кода приложений Angular. Эти рекомендации не являются
обязательными для работы Angular, но устанавливают набор практик кодирования, способствующих единообразию во всей
экосистеме Angular. Единый набор практик упрощает обмен кодом и переход между проектами.

Это руководство _не_ охватывает TypeScript или общие практики кодирования, не связанные с Angular. Что касается
TypeScript, ознакомьтесь
с [руководством по стилю TypeScript от Google](https://google.github.io/styleguide/tsguide.html).

### В случае сомнений отдавайте предпочтение единообразию

Если вы столкнулись с ситуацией, когда эти правила противоречат стилю конкретного файла, отдайте приоритет сохранению
единообразия внутри файла. Смешивание разных стилей в одном файле создает больше путаницы, чем отступление от
рекомендаций этого руководства.

## Именование

### Разделяйте слова в именах файлов дефисами

Разделяйте слова в имени файла дефисами (`-`). Например, компонент с именем `UserProfile` должен иметь имя файла
`user-profile.ts`.

### Используйте то же имя для тестов файла с `.spec` в конце

Для модульных тестов (unit tests) заканчивайте имена файлов на `.spec.ts`. Например, файл модульного теста для
компонента `UserProfile` имеет имя `user-profile.spec.ts`.

### Сопоставляйте имена файлов с идентификатором TypeScript внутри

Имена файлов, как правило, должны описывать содержимое кода в файле. Если файл содержит класс TypeScript, имя файла
должно отражать имя этого класса. Например, файл, содержащий компонент с именем `UserProfile`, называется
`user-profile.ts`.

Если файл содержит более одного основного именуемого идентификатора, выберите имя, описывающее общую тему кода внутри.
Если код в файле не укладывается в общую тему или функциональную область, рассмотрите возможность разделения кода на
разные файлы. Избегайте слишком общих имен файлов, таких как `helpers.ts`, `utils.ts` или `common.ts`.

### Используйте одно и то же имя файла для TypeScript, шаблона и стилей компонента

Компоненты обычно состоят из одного файла TypeScript, одного файла шаблона и одного файла стилей. Эти файлы должны иметь
одно и то же имя с разными расширениями. Например, компонент `UserProfile` может иметь файлы `user-profile.ts`,
`user-profile.html` и `user-profile.css`.

Если у компонента более одного файла стилей, добавьте к имени дополнительные слова, описывающие стили, специфичные для
этого файла. Например, `UserProfile` может иметь файлы стилей `user-profile-settings.css` и
`user-profile-subscription.css`.

## Структура проекта

### Весь код приложения помещается в директорию с именем `src`

Весь ваш UI-код Angular (TypeScript, HTML и стили) должен находиться внутри директории с именем `src`. Код, не связанный
с UI, такой как файлы конфигурации или скрипты, должен находиться за пределами директории `src`.

Это сохраняет корневую директорию приложения единообразной для разных проектов Angular и создает четкое разделение между
UI-кодом и другим кодом в вашем проекте.

### Запускайте приложение в файле с именем `main.ts` непосредственно внутри `src`

Код для запуска или **бустрапинга** (bootstrap) приложения Angular всегда должен находиться в файле с именем `main.ts`.
Это представляет собой основную точку входа в приложение.

### Группируйте тесно связанные файлы вместе в одной директории

Компоненты Angular состоят из файла TypeScript и, возможно, шаблона и одного или нескольких файлов стилей. Следует
группировать их вместе в одной директории.

Модульные тесты должны находиться в той же директории, что и тестируемый код. Избегайте сбора несвязанных тестов в одну
директорию `tests`.

### Организуйте проект по функциональным областям

Организуйте проект в поддиректории на основе функций вашего приложения или общих тем кода в этих директориях. Например,
структура проекта для сайта кинотеатра MovieReel может выглядеть так:

```
src/
├─ movie-reel/
│ ├─ show-times/
│ │ ├─ film-calendar/
│ │ ├─ film-details/
│ ├─ reserve-tickets/
│ │ ├─ payment-info/
│ │ ├─ purchase-confirmation/
```

Избегайте создания поддиректорий на основе типа кода, который в них находится. Например, избегайте создания директорий
типа `components`, `directives` и `services`.

Избегайте размещения слишком большого количества файлов в одной директории, чтобы не затруднять чтение или навигацию. По
мере роста количества файлов в директории рассмотрите возможность дальнейшего разделения на дополнительные
поддиректории.

### Одна концепция на файл

Старайтесь фокусировать исходные файлы на одной _концепции_. Для классов Angular это обычно означает один компонент,
директиву или сервис на файл. Однако допустимо, если файл содержит более одного компонента или директивы, если ваши
классы относительно небольшие и связаны вместе как часть одной концепции.

В случае сомнений выбирайте подход, ведущий к созданию файлов меньшего размера.

## Внедрение зависимостей (DI)

### Предпочитайте функцию `inject` внедрению через параметры конструктора

Отдавайте предпочтение использованию функции `inject` вместо внедрения параметров конструктора. Функция `inject`
работает так же, как и внедрение через конструктор, но предлагает несколько преимуществ в стиле:

- `inject`, как правило, более читабельна, особенно когда класс внедряет много зависимостей.
- Синтаксически проще добавлять комментарии к внедряемым зависимостям.
- `inject` предлагает лучший вывод типов.
- При ориентации на ES2022+ с [
  `useDefineForClassFields`](https://www.typescriptlang.org/tsconfig/#useDefineForClassFields) можно избежать разделения
  объявления и инициализации полей при чтении полей во внедренных зависимостях.

[Вы можете рефакторить существующий код на
`inject` с помощью автоматического инструмента](reference/migrations/inject-function).

## Компоненты и директивы

### Выбор селекторов компонентов

Подробности о выборе селекторов компонентов см.
в [руководстве по компонентам](guide/components/selectors#choosing-a-selector).

### Именование членов компонентов и директив

Подробности об [именовании input-свойств](guide/components/inputs#choosing-input-names)
и [именовании output-свойств](guide/components/outputs#choosing-event-names) см. в руководстве по компонентам.

### Выбор селекторов директив

Директивы должны использовать тот
же [префикс, специфичный для приложения](guide/components/selectors#selector-prefixes), что и ваши компоненты.

При использовании селектора атрибута для директивы используйте имя атрибута в camelCase. Например, если ваше приложение
называется "MovieReel" и вы создаете директиву, добавляющую всплывающую подсказку к элементу, вы можете использовать
селектор `[mrTooltip]`.

### Группируйте специфичные для Angular свойства перед методами

Компоненты и директивы должны группировать специфичные для Angular свойства вместе, обычно в верхней части объявления
класса. Сюда входят внедренные зависимости, inputs, outputs и запросы (queries). Определяйте эти и другие свойства перед
методами класса.

Эта практика упрощает поиск API шаблона и зависимостей класса.

### Сохраняйте фокус компонентов и директив на представлении

Код внутри ваших компонентов и директив, как правило, должен относиться к UI, отображаемому на странице. Для кода,
который имеет смысл сам по себе, отдельно от UI, предпочтительнее рефакторинг в другие файлы. Например, вы можете
вынести правила валидации форм или преобразования данных в отдельные функции или классы.

### Избегайте слишком сложной логики в шаблонах

Шаблоны Angular разработаны для поддержки [JS-подобных выражений](guide/templates/expression-syntax). Вам следует
использовать эти выражения для реализации относительно простой логики непосредственно в выражениях шаблона.

Однако, когда код в шаблоне становится слишком сложным, рефакторите логику в код TypeScript (обычно с
помощью [computed](guide/signals#computed-signals)).

Не существует жесткого правила, определяющего, что считается "сложным". Используйте свое лучшее суждение.

### Используйте `protected` для членов класса, которые используются только шаблоном компонента

Публичные члены класса компонента по своей сути определяют публичный API, доступный через внедрение зависимостей
и [запросы](guide/components/queries). Отдавайте предпочтение модификатору доступа `protected` для любых членов, которые
предназначены для чтения из шаблона компонента.

```ts
@Component({
  ...,
  template: `<p>{{ fullName() }}</p>`,
})
export class UserProfile {
  firstName = input();
  lastName = input();

// `fullName` is not part of the component's public API, but is used in the template.
  protected fullName = computed(() => `${this.firstName()} ${this.lastName()}`);
}
```

### Используйте `readonly` для свойств, которые не должны изменяться

Помечайте свойства компонентов и директив, инициализируемые Angular, как `readonly`. Сюда входят свойства,
инициализируемые через `input`, `model`, `output` и запросы. Модификатор доступа `readonly` гарантирует, что значение,
установленное Angular, не будет перезаписано.

```ts
@Component({/* ... */})
export class UserProfile {
  readonly userId = input();
  readonly userSaved = output();
  readonly userName = model();
}
```

Для компонентов и директив, использующих API на основе декораторов `@Input`, `@Output` и запросов, этот совет применим к
output-свойствам и запросам, но не к input-свойствам.

```ts
@Component({/* ... */})
export class UserProfile {
  @Output() readonly userSaved = new EventEmitter<void>();
  @ViewChildren(PaymentMethod) readonly paymentMethods?: QueryList<PaymentMethod>;
}
```

### Предпочитайте `class` и `style` вместо `ngClass` и `ngStyle`

Отдавайте предпочтение привязкам `class` и `style` вместо использования директив [`NgClass`](/api/common/NgClass) и [
`NgStyle`](/api/common/NgStyle).

```html
<!-- PREFER -->
<div [class.admin]="isAdmin" [class.dense]="density === 'high'">
<div [style.color]="textColor" [style.background-color]="backgroundColor">
<!-- OR -->
<div [class]="{admin: isAdmin, dense: density === 'high'}">
<div [style]="{'color': textColor, 'background-color': backgroundColor}">


<!-- AVOID -->
<div [ngClass]="{admin: isAdmin, dense: density === 'high'}">
<div [ngStyle]="{'color': textColor, 'background-color': backgroundColor}">
```

Привязки `class` и `style` используют более простой синтаксис, который тесно согласуется со стандартными атрибутами
HTML. Это делает ваши шаблоны более легкими для чтения и понимания, особенно для разработчиков, знакомых с базовым HTML.

Кроме того, директивы `NgClass` и `NgStyle` влекут за собой дополнительные затраты на производительность по сравнению со
встроенным синтаксисом привязки `class` и `style`.

Подробнее см. в [руководстве по привязкам](/guide/templates/binding#css-class-and-style-property-bindings).

### Называйте обработчики событий по тому, что они _делают_, а не по событию, которое их вызывает

Предпочитайте называть обработчики событий по действию, которое они выполняют, а не по инициирующему событию:

```html
<!-- PREFER -->
<button (click)="saveUserData()">Save</button>

<!-- AVOID -->
<button (click)="handleClick()">Save</button>
```

Использование таких осмысленных имен облегчает понимание того, что делает событие, при чтении шаблона.

Для событий клавиатуры вы можете использовать модификаторы клавиш Angular с конкретными именами обработчиков:

```html
<textarea (keydown.control.enter)="commitNotes()" (keydown.control.space)="showSuggestions()">
```

Иногда логика обработки событий особенно длинная или сложная, что делает непрактичным объявление одного хорошо
названного обработчика. В этих случаях допустимо использовать имя типа 'handleKeydown', а затем делегировать выполнение
более конкретным поведениям на основе деталей события:

```ts

@Component({/* ... */})
class RichText {
  handleKeydown(event: KeyboardEvent) {
    if (event.ctrlKey) {
      if (event.key === 'B') {
        this.activateBold();
      } else if (event.key === 'I') {
        this.activateItalic();
      }
// ...
    }
  }
}
```

### Сохраняйте методы жизненного цикла простыми

Избегайте размещения длинной или сложной логики внутри хуков жизненного цикла, таких как `ngOnInit`. Вместо этого
создавайте хорошо названные методы, содержащие эту логику, и затем _вызывайте эти методы_ в хуках жизненного цикла.
Имена хуков жизненного цикла описывают, _когда_ они запускаются, а это означает, что код внутри не имеет осмысленного
имени, описывающего, что именно он делает.

```typescript
// PREFER
ngOnInit() {
  this.startLogging();
  this.runBackgroundTask();
}

// AVOID
ngOnInit() {
  this.logger.setMode('info');
  this.logger.monitorErrors();
  // ...and all the rest of the code that would be unrolled from these methods.
}
```

### Используйте интерфейсы хуков жизненного цикла

Angular предоставляет интерфейс TypeScript для каждого метода жизненного цикла. При добавлении хука жизненного цикла в
ваш класс импортируйте и реализуйте (`implement`) эти интерфейсы, чтобы гарантировать правильное именование методов.

```ts
import {Component, OnInit} from '@angular/core';

@Component({/* ... */})
export class UserProfile implements OnInit {

  // The `OnInit` interface ensures this method is named correctly.
  ngOnInit() { /* ... */ }
}
```
