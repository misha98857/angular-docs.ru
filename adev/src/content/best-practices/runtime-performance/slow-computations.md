# Медленные вычисления

В каждом цикле обнаружения изменений Angular синхронно:

- Оценивает все выражения шаблонов во всех компонентах, если не указано иное, в зависимости от стратегии обнаружения
  изменений каждого компонента.
- Выполняет хуки жизненного цикла `ngDoCheck`, `ngAfterContentChecked`, `ngAfterViewChecked` и `ngOnChanges`.

Одно медленное вычисление внутри шаблона или хука жизненного цикла может замедлить весь процесс обнаружения изменений,
так как Angular выполняет вычисления последовательно.

## Выявление медленных вычислений

Вы можете выявить тяжелые вычисления с помощью профилировщика Angular DevTools. На временной шкале производительности
нажмите на полосу, чтобы просмотреть конкретный цикл обнаружения изменений. Отобразится гистограмма, показывающая,
сколько времени фреймворк затратил на обнаружение изменений для каждого компонента. При нажатии на компонент можно
увидеть, сколько времени Angular потратил на вычисление его шаблона и хуков жизненного цикла.

<img alt="Angular DevTools profiler preview showing slow computation" src="assets/images/best-practices/runtime-performance/slow-computations.png">

Например, на предыдущем скриншоте выбран второй записанный цикл обнаружения изменений. Angular потратил более 573 мс на
этот цикл, при этом большая часть времени ушла на `EmployeeListComponent`. На панели деталей видно, что Angular потратил
более 297 мс на вычисление шаблона `EmployeeListComponent`.

## Оптимизация медленных вычислений

Вот несколько методов устранения медленных вычислений:

- **Оптимизация основного алгоритма**. Это рекомендуемый подход. Если вы сможете ускорить алгоритм, вызывающий проблему,
  вы ускорите весь механизм обнаружения изменений.
- **Кэширование с использованием pure pipes**. Вы можете перенести тяжелые вычисления в [pure pipe](guide/pipes).
  Angular пересчитывает pure pipe только в том случае, если обнаруживает, что его входные данные изменились по сравнению
  с предыдущим вызовом.
- **Использование мемоизации**. [Мемоизация](https://ru.wikipedia.org/wiki/Мемоизация) — это техника, похожая на pure
  pipes, с той разницей, что pure pipes сохраняют только последний результат вычислений, тогда как мемоизация может
  хранить несколько результатов.
- **Избегайте перерисовок (repaints) и перекомпоновок (reflows) в хуках жизненного цикла**.
  Определенные [операции](https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/) заставляют браузер
  синхронно пересчитывать макет страницы или выполнять её повторный рендеринг. Поскольку перекомпоновка и перерисовка
  обычно выполняются медленно, следует избегать их выполнения в каждом цикле обнаружения изменений.

Pure pipes и мемоизация имеют разные компромиссы. Pure pipes — это встроенная концепция Angular, в то время как
мемоизация — это общая практика разработки программного обеспечения для кэширования результатов функций. Накладные
расходы памяти при мемоизации могут быть значительными, если вы часто вызываете тяжелые вычисления с разными
аргументами.
